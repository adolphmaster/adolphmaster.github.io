<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java实现上传文件到指定服务器指定目录</title>
      <link href="/2020/05/24/2020-05-24-Java%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95/"/>
      <url>/2020/05/24/2020-05-24-Java%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java实现上传文件到指定服务器指定目录"><a href="#Java实现上传文件到指定服务器指定目录" class="headerlink" title="Java实现上传文件到指定服务器指定目录"></a>Java实现上传文件到指定服务器指定目录</h1><blockquote><p>遇到了此类问题，网上找到一篇文章，基于此，转载此篇文章，如有版本不一致，我遇到的就是自己私服版本不一致，根据示例代码很容易修改，实际代码对upload方法封装了一层，支持文件list上传，在远处桌面开发，就不贴出来了</p></blockquote><blockquote><p>原文地址 <a href="https://www.cnblogs.com/jichi/p/12158537.html" target="_blank" rel="noopener">https://www.cnblogs.com/jichi/p/12158537.html</a></p></blockquote><h3 id="前言需求"><a href="#前言需求" class="headerlink" title="前言需求"></a>前言需求</h3><p>使用 freemarker 生成的静态文件，统一存储在某个服务器上。本来一开始打算使用 ftp 实现的，奈何老连接不上，改用 jsch。毕竟有现成的就很舒服，在此介绍给大家。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="引入的-pom"><a href="#引入的-pom" class="headerlink" title="引入的 pom"></a>引入的 pom</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.ethz.ganymed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ganymed-ssh2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>262<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jcraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.55<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="建立实体类"><a href="#建立实体类" class="headerlink" title="建立实体类"></a>建立实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultEntity</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResultEntity</span><span class="params">(String code, String message, File file)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.code = code;</span><br><span class="line"><span class="keyword">this</span>.message = message;</span><br><span class="line"><span class="keyword">this</span>.file = file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.file = file;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScpConnectEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String targetPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTargetPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> targetPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetPath</span><span class="params">(String targetPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetPath = targetPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建立文件上传工具类"><a href="#建立文件上传工具类" class="headerlink" title="建立文件上传工具类"></a>建立文件上传工具类</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FileUploadUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">"$&#123;remoteServer.url&#125;"</span>)</span><br><span class="line">    private <span class="built_in">String</span> url;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">"$&#123;remoteServer.password&#125;"</span>)</span><br><span class="line">    private <span class="built_in">String</span> passWord;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">"$&#123;remoteServer.username&#125;"</span>)</span><br><span class="line">    private <span class="built_in">String</span> userName;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public ResultEntity uploadFile(File file, <span class="built_in">String</span> targetPath, <span class="built_in">String</span> remoteFileName) throws Exception&#123;</span><br><span class="line">        ScpConnectEntity scpConnectEntity=<span class="keyword">new</span> ScpConnectEntity();</span><br><span class="line">        scpConnectEntity.setTargetPath(targetPath);</span><br><span class="line">        scpConnectEntity.setUrl(url);</span><br><span class="line">        scpConnectEntity.setPassWord(passWord);</span><br><span class="line">        scpConnectEntity.setUserName(userName);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">String</span> code = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">String</span> message = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file == <span class="literal">null</span> || !file.exists()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"请确保上传文件不为空且存在！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(remoteFileName==<span class="literal">null</span> || <span class="string">""</span>.equals(remoteFileName.trim()))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"远程服务器新建文件名不能为空!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            remoteUploadFile(scpConnectEntity, file, remoteFileName);</span><br><span class="line">            code = <span class="string">"ok"</span>;</span><br><span class="line">            message = remoteFileName;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            code = <span class="string">"Exception"</span>;</span><br><span class="line">            message = e.getMessage();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSchException e) &#123;</span><br><span class="line">            code = <span class="string">"Exception"</span>;</span><br><span class="line">            message = e.getMessage();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            code = <span class="string">"Exception"</span>;</span><br><span class="line">            message = e.getMessage();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="built_in">Error</span> e) &#123;</span><br><span class="line">            code = <span class="string">"Error"</span>;</span><br><span class="line">            message = e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultEntity(code, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private <span class="keyword">void</span> remoteUploadFile(ScpConnectEntity scpConnectEntity, File file,</span><br><span class="line">                                 <span class="built_in">String</span> remoteFileName) throws JSchException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="literal">null</span>;</span><br><span class="line">        ch.ethz.ssh2.Session session = <span class="literal">null</span>;</span><br><span class="line">        SCPOutputStream scpo = <span class="literal">null</span>;</span><br><span class="line">        FileInputStream fis = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            createDir(scpConnectEntity);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JSchException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = <span class="keyword">new</span> Connection(scpConnectEntity.getUrl());</span><br><span class="line">            connection.connect();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!connection.authenticateWithPassword(scpConnectEntity.getUserName(),scpConnectEntity.getPassWord()))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"SSH连接服务器失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            session = connection.openSession();</span><br><span class="line"></span><br><span class="line">            SCPClient scpClient = connection.createSCPClient();</span><br><span class="line"></span><br><span class="line">            scpo = scpClient.put(remoteFileName, file.length(), scpConnectEntity.getTargetPath(), <span class="string">"0666"</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">            byte[] buf = <span class="keyword">new</span> byte[<span class="number">1024</span>];</span><br><span class="line">            int hasMore = fis.read(buf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(hasMore != <span class="number">-1</span>)&#123;</span><br><span class="line">                scpo.write(buf);</span><br><span class="line">                hasMore = fis.read(buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"SSH上传文件至服务器出错"</span>+e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != fis)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != scpo)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    scpo.flush();</span><br><span class="line"><span class="comment">//                    scpo.close();</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != session)&#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != connection)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private boolean createDir(ScpConnectEntity scpConnectEntity ) throws JSchException &#123;</span><br><span class="line"></span><br><span class="line">        JSch jsch = <span class="keyword">new</span> JSch();</span><br><span class="line">        com.jcraft.jsch.Session sshSession = <span class="literal">null</span>;</span><br><span class="line">        Channel channel= <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sshSession = jsch.getSession(scpConnectEntity.getUserName(), scpConnectEntity.getUrl(), <span class="number">22</span>);</span><br><span class="line">            sshSession.setPassword(scpConnectEntity.getPassWord());</span><br><span class="line">            sshSession.setConfig(<span class="string">"StrictHostKeyChecking"</span>, <span class="string">"no"</span>);</span><br><span class="line">            sshSession.connect();</span><br><span class="line">            channel = sshSession.openChannel(<span class="string">"sftp"</span>);</span><br><span class="line">            channel.connect();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSchException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSchException(<span class="string">"SFTP连接服务器失败"</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        ChannelSftp channelSftp=(ChannelSftp) channel;</span><br><span class="line">        <span class="keyword">if</span> (isDirExist(scpConnectEntity.getTargetPath(),channelSftp)) &#123;</span><br><span class="line">            channel.disconnect();</span><br><span class="line">            channelSftp.disconnect();</span><br><span class="line">            sshSession.disconnect();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">String</span> pathArry[] = scpConnectEntity.getTargetPath().split(<span class="string">"/"</span>);</span><br><span class="line">            StringBuffer filePath=<span class="keyword">new</span> StringBuffer(<span class="string">"/"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">String</span> path : pathArry) &#123;</span><br><span class="line">                <span class="keyword">if</span> (path.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                filePath.append(path + <span class="string">"/"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDirExist(filePath.toString(),channelSftp)) &#123;</span><br><span class="line">                        channelSftp.cd(filePath.toString());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 建立目录</span></span><br><span class="line">                        channelSftp.mkdir(filePath.toString());</span><br><span class="line">                        <span class="comment">// 进入并设置为当前目录</span></span><br><span class="line">                        channelSftp.cd(filePath.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SftpException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSchException(<span class="string">"SFTP无法正常操作服务器"</span>+e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.disconnect();</span><br><span class="line">        channelSftp.disconnect();</span><br><span class="line">        sshSession.disconnect();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isDirExist(<span class="built_in">String</span> directory,ChannelSftp channelSftp) &#123;</span><br><span class="line">        boolean isDirExistFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SftpATTRS sftpATTRS = channelSftp.lstat(directory);</span><br><span class="line">            isDirExistFlag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> sftpATTRS.isDir();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getMessage().toLowerCase().equals(<span class="string">"no such file"</span>)) &#123;</span><br><span class="line">                isDirExistFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isDirExistFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性我都写在 Spring 的配置文件里面了。将这个类托管给 spring 容器。<br>如果在普通类里面使用这个类，就需要看一下上篇博客了。哈哈。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在我们使用的时候，主要调 uploadFile 这个方法即可。传递 File 文件，目标路径及文件名称。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目构建基础 - 统一结果，统一异常，统一日志</title>
      <link href="/2020/04/22/2020-04-22-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%20-%20%E7%BB%9F%E4%B8%80%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97/"/>
      <url>/2020/04/22/2020-04-22-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%20-%20%E7%BB%9F%E4%B8%80%E7%BB%93%E6%9E%9C%EF%BC%8C%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://juejin.im/post/5e073980f265da33f8653f2e" target="_blank" rel="noopener">https://juejin.im/post/5e073980f265da33f8653f2e</a></p><p>参考链接： <a href="https://juejin.im/post/5cbc744a6fb9a0685a3f01a7" target="_blank" rel="noopener">SpringBoot 之全局异常处理</a>_</p><p>推荐博客：<a href="https://juejin.im/post/5b51f85c5188251af91a7525" target="_blank" rel="noopener">glmapper 的 logback 博客</a>，<a href="https://blog.csdn.net/xu_san_duo/article/details/80364600" target="_blank" rel="noopener">logback-spring.xml 配置文件</a></p><p>代码地址：<a href="https://github.com/adolphmaster/javatools/tree/master/src/main/java/com/adolph/javatools/common" target="_blank" rel="noopener">github</a></p></blockquote><h1 id="项目构建基础-统一结果，统一异常，统一日志"><a href="#项目构建基础-统一结果，统一异常，统一日志" class="headerlink" title="项目构建基础 - 统一结果，统一异常，统一日志"></a>项目构建基础 - 统一结果，统一异常，统一日志</h1><h2 id="统一结果返回"><a href="#统一结果返回" class="headerlink" title="统一结果返回"></a>统一结果返回</h2><blockquote><p>目前的前后端开发大部分数据的传输格式都是 json，因此定义一个统一规范的数据格式有利于前后端的交互与 UI 的展示。</p></blockquote><h3 id="统一结果的一般形式"><a href="#统一结果的一般形式" class="headerlink" title="统一结果的一般形式"></a>统一结果的一般形式</h3><ol><li>是否响应成功；</li><li>响应状态码；</li><li>状态码描述；</li><li>响应数据</li><li>其他标识符</li></ol><h3 id="结果类枚举"><a href="#结果类枚举" class="headerlink" title="结果类枚举"></a>结果类枚举</h3><ul><li>前三者可定义结果枚举，如：success，code，message</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ResultCodeEnum &#123;</span><br><span class="line">    SUCCESS(<span class="keyword">true</span>,<span class="number">5000</span>,<span class="string">"成功"</span>),</span><br><span class="line">    FAIL(<span class="keyword">false</span>,<span class="number">5001</span>,<span class="string">"失败"</span>),</span><br><span class="line">    UNKNOWN_ERROR(<span class="keyword">false</span>,<span class="number">5002</span>,<span class="string">"未知错误"</span>),</span><br><span class="line">    PARAM_ERROR(<span class="keyword">false</span>,<span class="number">5003</span>,<span class="string">"参数错误"</span>) ,</span><br><span class="line">    NULL_POINTER(<span class="keyword">false</span>,<span class="number">5004</span>,<span class="string">"空指针异常"</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应是否成功</span></span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="comment">// 响应状态码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">// 响应信息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    ResultCodeEnum(<span class="keyword">boolean</span> success, Integer code, String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一结果类"><a href="#统一结果类" class="headerlink" title="统一结果类"></a>统一结果类</h3><ul><li>第 5 个属于自定义返回，利用前 4 者可定义统一返回对象</li></ul><p><strong>注意：</strong></p><ol><li>外接只可以调用统一返回类的方法，不可以直接创建，影刺构造器私有；</li><li>内置静态方法，返回对象；</li><li>为便于自定义统一结果的信息，建议使用链式编程，将返回对象设类本身，即 return this;</li><li>响应数据由于为 json 格式，可定义为 JsonObject 或 Map 形式；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResultResponse</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用返回成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultResponse <span class="title">ok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResultResponse resultResponse = <span class="keyword">new</span> ResultResponse();</span><br><span class="line">        resultResponse.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());</span><br><span class="line">        resultResponse.setCode(ResultCodeEnum.SUCCESS.getCode());</span><br><span class="line">        resultResponse.setMessage(ResultCodeEnum.SUCCESS.getMessage());</span><br><span class="line">        <span class="keyword">return</span> resultResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用返回失败，未知错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultResponse <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResultResponse resultResponse = <span class="keyword">new</span> ResultResponse();</span><br><span class="line">        resultResponse.setSuccess(ResultCodeEnum.UNKNOWN_ERROR.getSuccess());</span><br><span class="line">        resultResponse.setCode(ResultCodeEnum.UNKNOWN_ERROR.getCode());</span><br><span class="line">        resultResponse.setMessage(ResultCodeEnum.UNKNOWN_ERROR.getMessage());</span><br><span class="line">        <span class="keyword">return</span> resultResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置结果，形参为结果枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultResponse <span class="title">setResult</span><span class="params">(ResultCodeEnum result)</span> </span>&#123;</span><br><span class="line">        ResultResponse resultResponse = <span class="keyword">new</span> ResultResponse();</span><br><span class="line">        resultResponse.setSuccess(result.getSuccess());</span><br><span class="line">        resultResponse.setCode(result.getCode());</span><br><span class="line">        resultResponse.setMessage(result.getMessage());</span><br><span class="line">        <span class="keyword">return</span> resultResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义返回数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">data</span><span class="params">(Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(map);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用设置data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">data</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  自定义状态信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">message</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义状态码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">code</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCode(code);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> success</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">success</span><span class="params">(Boolean success)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setSuccess(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制层返回"><a href="#控制层返回" class="headerlink" title="控制层返回"></a>控制层返回</h3><ul><li>视图层使用统一结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/v1/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherAdminController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultResponse <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Teacher&gt; list = teacherService.list(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> ResultResponse.ok().data(<span class="string">"itms"</span>, list).message(<span class="string">"用户列表"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>json 结果</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"查询用户列表"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"itms"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="attr">"role"</span>: <span class="string">"ADMIN"</span>,</span><br><span class="line">        <span class="attr">"deleted"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"gmtCreate"</span>: <span class="string">"2019-12-26T15:32:29"</span>,</span><br><span class="line">        <span class="attr">"gmtModified"</span>: <span class="string">"2019-12-26T15:41:40"</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"zhangsan"</span>,</span><br><span class="line">        <span class="attr">"role"</span>: <span class="string">"USER"</span>,</span><br><span class="line">        <span class="attr">"deleted"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"gmtCreate"</span>: <span class="string">"2019-12-26T15:32:29"</span>,</span><br><span class="line">        <span class="attr">"gmtModified"</span>: <span class="string">"2019-12-26T15:41:40"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>统一结果类的使用参考了 mybatis-plus 中 R 对象的设计</em></p><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><blockquote><p>使用统一返回结果时，还有一种情况，就是程序的保存是由于运行时异常导致的结果，有些异常我们可以无法提前预知，不能正常走到我们 return 的 ResultResponse 对象返回。</p></blockquote><p>因此，我们需要定义一个统一的全局异常来捕获这些信息，并作为一种结果返回控制层</p><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>该注解为统一异常处理的核心</p><blockquote><p>是一种作用于控制层的切面通知（Advice），该注解能够将通用的 @ExceptionHandler、@InitBinder 和 @ModelAttributes 方法收集到一个类型，并应用到所有控制器上</p></blockquote><p>该类中的设计思路：</p><ol><li>使用 @ExceptionHandler 注解捕获指定或自定义的异常；</li><li>使用 @ControllerAdvice 集成 @ExceptionHandler 的方法到一个类中；</li><li>必须定义一个通用的异常捕获方法，便于捕获未定义的异常信息；</li><li>自定一个异常类，捕获针对项目或业务的异常;</li><li>异常的对象信息补充到统一结果枚举中；</li></ol><h3 id="自定义全局异常类"><a href="#自定义全局异常类" class="headerlink" title="自定义全局异常类"></a>自定义全局异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com._4paradigm.data.analysis.common.response.ResultCodeEnum;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ResultCodeEnum resultCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">(ResultCodeEnum resultCode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resultCode = resultCode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultCodeEnum <span class="title">getResultCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法</span></span><br><span class="line"><span class="comment">     *      用法：CustomException.cast(ResultCodeEnum.FAIL);</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cast</span><span class="params">(ResultCodeEnum resultCode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一异常处理器"><a href="#统一异常处理器" class="headerlink" title="统一异常处理器"></a>统一异常处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com._4paradigm.data.analysis.common.response.ResultCodeEnum;</span><br><span class="line"><span class="keyword">import</span> com._4paradigm.data.analysis.common.response.ResultResponse;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableMap;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageNotReadableException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义map，存贮常见错误信息。该类map不可修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImmutableMap&lt;Class&lt;? extends Throwable&gt;,ResultCodeEnum&gt; EXCEPTIONS;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建ImmutableMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;,ResultCodeEnum&gt; builder = ImmutableMap.builder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获CustomException类异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(CustomException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultResponse</span> <span class="title">customException</span>(<span class="title">CustomException</span> <span class="title">customException</span>)</span>&#123;</span><br><span class="line">        ResultCodeEnum resultCode = customException.getResultCode();</span><br><span class="line">        <span class="keyword">return</span> ResultResponse.setResult(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultResponse</span> <span class="title">error</span>(<span class="title">NullPointerException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(ExceptionUtil.getMessage(e));</span><br><span class="line">        <span class="keyword">return</span> ResultResponse.setResult(ResultCodeEnum.NULL_POINTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获非自定义类异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultResponse</span> <span class="title">exception</span>(<span class="title">Exception</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        log.error(ExceptionUtil.getMessage(exception));</span><br><span class="line">        <span class="keyword">if</span> (EXCEPTIONS == <span class="keyword">null</span>)&#123;</span><br><span class="line">            EXCEPTIONS = builder.build();</span><br><span class="line">        &#125;</span><br><span class="line">        ResultCodeEnum resultCode = EXCEPTIONS.get(exception.getClass());</span><br><span class="line">        <span class="keyword">if</span> (resultCode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultResponse.setResult(resultCode);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResultResponse.setResult(ResultCodeEnum.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        builder.put(HttpMessageNotReadableException<span class="class">.<span class="keyword">class</span>, <span class="title">ResultCodeEnum</span>.<span class="title">PARAM_ERROR</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制层展示"><a href="#控制层展示" class="headerlink" title="控制层展示"></a>控制层展示</h3><p>以下为展示当遇到 null 指定异常时，返回的结果信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"success"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">5004</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"空指针异常"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>本节介绍统一异常较为简略，推荐博客 <a href="https://juejin.im/post/5cbc744a6fb9a0685a3f01a7" target="_blank" rel="noopener">SpringBoot 之全局异常处理</a></em></p><h2 id="统一日志收集"><a href="#统一日志收集" class="headerlink" title="统一日志收集"></a>统一日志收集</h2><blockquote><p>日志是追踪错误定位问题的关键，尤其在生产环境中，需要及时修复热部署，不会提供开发者 debug 的环境，此时日志将会是最快解决问题的关键</p></blockquote><p>日志的框架比较丰富，由于 spring boot 对 logback 的集成，因此推荐使用 logback 在项目中使用。</p><h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h3><p>关于 logback 的配置和介绍，可以参考<a href="http://logback.qos.ch/documentation.html" target="_blank" rel="noopener">官网</a>或推荐博客 <a href="https://juejin.im/post/5b51f85c5188251af91a7525" target="_blank" rel="noopener">glmapper 的 logback 博客</a>，<a href="https://blog.csdn.net/xu_san_duo/article/details/80364600" target="_blank" rel="noopener">logback-spring.xml 配置文件</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>以下直接贴出配置信息，介绍信息科直接参考备注</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。</span></span><br><span class="line"><span class="comment">                 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- de<span class="doctag">bug:</span>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>  <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"10 seconds"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“$&#123;&#125;”来使用变量。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--0. 日志格式和颜色渲染 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志依赖的渲染类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"clr"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ColorConverter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wex"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">conversionRule</span> <span class="attr">conversionWord</span>=<span class="string">"wEx"</span> <span class="attr">converterClass</span>=<span class="string">"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 彩色日志格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> $&#123;<span class="attr">CONSOLE_LOG_PATTERN:-</span>%<span class="attr">clr</span>(%<span class="attr">d</span>&#123;<span class="attr">yyyy-MM-dd</span> <span class="attr">HH:mm:ss.SSS</span>&#125;)&#123;<span class="attr">faint</span>&#125; %<span class="attr">clr</span>($&#123;<span class="attr">LOG_LEVEL_PATTERN:-</span>%<span class="attr">5p</span>&#125;) %<span class="attr">clr</span>($&#123;<span class="attr">PID:-</span> &#125;)&#123;<span class="attr">magenta</span>&#125; %<span class="attr">clr</span>(<span class="attr">---</span>)&#123;<span class="attr">faint</span>&#125; %<span class="attr">clr</span>([%<span class="attr">15.15t</span>])&#123;<span class="attr">faint</span>&#125; %<span class="attr">clr</span>(%<span class="attr">-40.40logger</span>&#123;<span class="attr">39</span>&#125;)&#123;<span class="attr">cyan</span>&#125; %<span class="attr">clr</span>(<span class="attr">:</span>)&#123;<span class="attr">faint</span>&#125; %<span class="attr">m</span>%<span class="attr">n</span>$&#123;<span class="attr">LOG_EXCEPTION_CONVERSION_WORD:-</span>%<span class="attr">wEx</span>&#125;&#125;"/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1. 输出到控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2. 输出到文档--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.1 level为 DEBUG 日志，时间滚动输出  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/edu_debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文档输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志归档 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/web-debug-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文档保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文档只记录debug级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.2 level为 INFO 日志，时间滚动输出  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/edu_info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文档输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每天日志归档路径以及格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/web-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文档保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文档只记录info级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.3 level为 WARN 日志，时间滚动输出  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/edu_warn.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文档输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/web-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文档保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文档只记录warn级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.4 level为 ERROR 日志，时间滚动输出  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/edu_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文档输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/web-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文档保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文档只记录ERROR级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、</span></span><br><span class="line"><span class="comment">        以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，</span></span><br><span class="line"><span class="comment">        一个可选的level和一个可选的addtivity属性。</span></span><br><span class="line"><span class="comment">        name:用来指定受此logger约束的某一个包或者具体的某一个类。</span></span><br><span class="line"><span class="comment">        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class="line"><span class="comment">              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。</span></span><br><span class="line"><span class="comment">              如果未设置此属性，那么当前logger将会继承上级的级别。</span></span><br><span class="line"><span class="comment">        addtivity:是否向上级logger传递打印信息。默认是true。</span></span><br><span class="line"><span class="comment">        &lt;logger /&gt;</span></span><br><span class="line"><span class="comment">        &lt;logger /&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：</span></span><br><span class="line"><span class="comment">        第一种把&lt;root level="info"&gt;改成&lt;root level="DEBUG"&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息</span></span><br><span class="line"><span class="comment">        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：</span></span><br><span class="line"><span class="comment">        【logging.level.org.mybatis=debug logging.level.dao=debug】</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span></span><br><span class="line"><span class="comment">        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class="line"><span class="comment">        不能设置为INHERITED或者同义词NULL。默认是DEBUG</span></span><br><span class="line"><span class="comment">        可以包含零个或多个元素，标识这个appender将会添加到这个logger。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4. 最终的策略 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.1 开发环境:打印控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"DEBUG_FILE"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"INFO_FILE"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"WARN_FILE"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR_FILE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.2 生产环境:输出到文档--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR_FILE"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"WARN_FILE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="日志收集异常信息"><a href="#日志收集异常信息" class="headerlink" title="日志收集异常信息"></a>日志收集异常信息</h3><p>日志信息往往伴随着异常信息的输出，因此，我们需要修改统一异常的处理器，将异常信息以流的方式写到日志文件中</p><ul><li>异常信息文件工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        String swStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (StringWriter sw = <span class="keyword">new</span> StringWriter(); PrintWriter pw = <span class="keyword">new</span> PrintWriter(sw)) &#123;</span><br><span class="line">            e.printStackTrace(pw);</span><br><span class="line">            pw.flush();</span><br><span class="line">            sw.flush();</span><br><span class="line">            swStr = sw.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            log.error(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> swStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改统一异常处理器，将异常方法中的直接打印改为日志输入并打印</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com._4paradigm.data.analysis.common.response.ResultCodeEnum;</span><br><span class="line"><span class="keyword">import</span> com._4paradigm.data.analysis.common.response.ResultResponse;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ImmutableMap;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageNotReadableException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义map，存贮常见错误信息。该类map不可修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImmutableMap&lt;Class&lt;? extends Throwable&gt;,ResultCodeEnum&gt; EXCEPTIONS;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建ImmutableMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;,ResultCodeEnum&gt; builder = ImmutableMap.builder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获CustomException类异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(CustomException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultResponse</span> <span class="title">customException</span>(<span class="title">CustomException</span> <span class="title">customException</span>)</span>&#123;</span><br><span class="line">        ResultCodeEnum resultCode = customException.getResultCode();</span><br><span class="line">        <span class="keyword">return</span> ResultResponse.setResult(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultResponse</span> <span class="title">error</span>(<span class="title">NullPointerException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        log.error(ExceptionUtil.getMessage(e));</span><br><span class="line">        <span class="keyword">return</span> ResultResponse.setResult(ResultCodeEnum.NULL_POINTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获非自定义类异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResultResponse</span> <span class="title">exception</span>(<span class="title">Exception</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        log.error(ExceptionUtil.getMessage(exception));</span><br><span class="line">        <span class="keyword">if</span> (EXCEPTIONS == <span class="keyword">null</span>)&#123;</span><br><span class="line">            EXCEPTIONS = builder.build();</span><br><span class="line">        &#125;</span><br><span class="line">        ResultCodeEnum resultCode = EXCEPTIONS.get(exception.getClass());</span><br><span class="line">        <span class="keyword">if</span> (resultCode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultResponse.setResult(resultCode);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResultResponse.setResult(ResultCodeEnum.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        builder.put(HttpMessageNotReadableException<span class="class">.<span class="keyword">class</span>, <span class="title">ResultCodeEnum</span>.<span class="title">PARAM_ERROR</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>日志的环境即 spring.profiles.acticve，跟随项目启动；</li><li>启动后，即可到自定目录查找到生成的日志文件；</li><li>本地 idea 调试时，推荐 Grep Console 插件可实现控制台的自定义颜色输出</li></ol><p>详细过程，可参考源代码：<a href="https://github.com/chetwhy/cloud-flow" target="_blank" rel="noopener">github.com/chetwhy/clo…</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 项目构建基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 项目构建基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot与缓存</title>
      <link href="/2020/03/15/2020-03-15-Spring%20Boot%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
      <url>/2020/03/15/2020-03-15-Spring%20Boot%E4%B8%8E%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot与缓存"><a href="#Spring-Boot与缓存" class="headerlink" title="Spring Boot与缓存"></a>Spring Boot与缓存</h2><h3 id="一、JSR107"><a href="#一、JSR107" class="headerlink" title="一、JSR107"></a>一、JSR107</h3><p>Java Caching定义了5个核心接口，分别是<strong>CachingProvider</strong>, <strong>CacheManager</strong>, <strong>Cache</strong>, <strong>Entry</strong> 和 <strong>Expiry</strong>。</p><p>•<strong>CachingProvider</strong>定义了创建、配置、获取、管理和控制多个<strong>CacheManager</strong>。一个应用可以在运行期访问多个CachingProvider。</p><p>•<strong>CacheManager</strong>定义了创建、配置、获取、管理和控制多个唯一命名的<strong>Cache</strong>，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</p><p>•<strong>Cache</strong>是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。</p><p>•<strong>Entry</strong>是一个存储在Cache中的key-value对。</p><p>•<strong>Expiry</strong> 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190924154931.png" alt=""></p><h3 id="二、Spring缓存抽象"><a href="#二、Spring缓存抽象" class="headerlink" title="二、Spring缓存抽象"></a>二、Spring缓存抽象</h3><p>Spring从3.1开始定义了org.springframework.cache.Cacheorg.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发</p><ul><li>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</li><li>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等；</li><li>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</li><li>使用Spring缓存抽象时我们需要关注以下两点；<ul><li>1、确定方法需要被缓存以及他们的缓存策略</li><li>2、从缓存中读取之前缓存存储的数据</li></ul></li></ul><h3 id="三、几个重要概念-amp-缓存注解"><a href="#三、几个重要概念-amp-缓存注解" class="headerlink" title="三、几个重要概念&amp;缓存注解"></a>三、几个重要概念&amp;缓存注解</h3><table><thead><tr><th><strong>Cache</strong></th><th><strong>缓存接口，定义缓存操作。实现有：**</strong>RedisCache<strong><strong>、</strong></strong>EhCacheCache<strong><strong>、</strong></strong>ConcurrentMapCache<strong>**等</strong></th></tr></thead><tbody><tr><td><strong>CacheManager</strong></td><td><strong>缓存管理器，管理各种缓存（**</strong>Cache<strong>**）组件</strong></td></tr><tr><td><strong>@Cacheable</strong></td><td><strong>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</strong></td></tr><tr><td><strong>@CacheEvict</strong></td><td><strong>清空缓存</strong></td></tr><tr><td><strong>@CachePut</strong></td><td><strong>保证方法被调用，又希望结果被缓存。</strong></td></tr><tr><td><strong>@EnableCaching</strong></td><td><strong>开启基于注解的缓存</strong></td></tr><tr><td><strong>keyGenerator</strong></td><td><strong>缓存数据时**</strong>key<strong>**生成策略</strong></td></tr><tr><td><strong>serialize</strong></td><td><strong>缓存数据时**</strong>value<strong>**序列化策略</strong></td></tr></tbody></table><p> @Cacheable、@CachePut、@CacheEvict主要的参数</p><table><thead><tr><th align="left"></th><th></th><th align="center"></th></tr></thead><tbody><tr><td align="left">value</td><td>缓存的名称，在   spring 配置文件中定义，必须指定至少一个</td><td align="center">例如：      @Cacheable(value=”mycache”) 或者       @Cacheable(value={”cache1”,”cache2”}</td></tr><tr><td align="left">key</td><td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td><td align="center">例如：      @Cacheable(value=”testcache”,key=”#userName”)</td></tr><tr><td align="left">condition</td><td>缓存的条件，可以为空，使用   SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存/清除缓存，在调用方法之前之后都能判断</td><td align="center">例如：      @Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</td></tr><tr><td align="left">allEntries   (<strong>@CacheEvict</strong> )</td><td>是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存</td><td align="center">例如：      @CachEvict(value=”testcache”,allEntries=true)</td></tr><tr><td align="left">beforeInvocation   <strong>(@CacheEvict)</strong></td><td>是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td><td align="center">例如：   @CachEvict(value=”testcache”，beforeInvocation=true)</td></tr><tr><td align="left">unless   <strong>(@CachePut)</strong>   <strong>(@Cacheable)</strong></td><td>用于否决缓存的，不像condition，该表达式只在方法执行之后判断，此时可以拿到返回值result进行判断。条件为true不会缓存，fasle才缓存</td><td align="center">例如：      @Cacheable(value=”testcache”,unless=”#result   == null”)</td></tr></tbody></table><p><strong><em>Cache</em></strong> <strong><em>SpEL</em></strong> <strong><em>available metadata</em></strong></p><table><thead><tr><th><strong>名字</strong></th><th><strong>位置</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>methodName</td><td>root   object</td><td>当前被调用的方法名</td><td>#root.methodName</td></tr><tr><td>method</td><td>root   object</td><td>当前被调用的方法</td><td>#root.method.name</td></tr><tr><td>target</td><td>root   object</td><td>当前被调用的目标对象</td><td>#root.target</td></tr><tr><td>targetClass</td><td>root   object</td><td>当前被调用的目标对象类</td><td>#root.targetClass</td></tr><tr><td>args</td><td>root   object</td><td>当前被调用的方法的参数列表</td><td>#root.args[0]</td></tr><tr><td>caches</td><td>root   object</td><td>当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”,   “cache2”})），则有两个cache</td><td>#root.caches[0].name</td></tr><tr><td><em>argument name</em></td><td>evaluation   context</td><td>方法参数的名字. 可以直接   #参数名   ，也可以使用 #p0或#a0   的形式，0代表参数的索引；</td><td>#iban 、 #a0 、  #p0</td></tr><tr><td>result</td><td>evaluation   context</td><td>方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache   put’的表达式 ’cache evict’的表达式beforeInvocation=false）</td><td>#result</td></tr></tbody></table><h3 id="四、讲解实战例子"><a href="#四、讲解实战例子" class="headerlink" title="四、讲解实战例子"></a>四、讲解实战例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *快速体验缓存</span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1、开启基于注解的缓存 <span class="doctag">@EnableCaching</span></span></span><br><span class="line"><span class="comment"> * 2、标注缓存注解即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Cacheable</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CacheEvict</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CachePut</span></span></span><br><span class="line"><span class="comment"> * 默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在ConcurrentMap&lt;Object, Object&gt;中</span></span><br><span class="line"><span class="comment"> * 开发中使用缓存中间件；redis、memcached、ehcache；</span></span><br><span class="line"><span class="comment"> * 整合redis作为缓存</span></span><br><span class="line"><span class="comment"> * Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</span></span><br><span class="line"><span class="comment"> * 1、安装redis：使用docker；</span></span><br><span class="line"><span class="comment"> * 2、引入redis的starter</span></span><br><span class="line"><span class="comment"> * 3、配置redis</span></span><br><span class="line"><span class="comment"> * 4、测试缓存</span></span><br><span class="line"><span class="comment"> * 原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据</span></span><br><span class="line"><span class="comment"> *1）、引入redis的starter，容器中保存的是 RedisCacheManager；</span></span><br><span class="line"><span class="comment"> *2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的</span></span><br><span class="line"><span class="comment"> *3）、默认保存数据 k-v 都是Object；利用序列化保存；如何保存为json</span></span><br><span class="line"><span class="comment"> *   1、引入了redis的starter，cacheManager变为 RedisCacheManager；</span></span><br><span class="line"><span class="comment"> *   2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate&lt;Object, Object&gt;</span></span><br><span class="line"><span class="comment"> *   3、RedisTemplate&lt;Object, Object&gt; 是 默认使用jdk的序列化机制</span></span><br><span class="line"><span class="comment"> *      4）、自定义CacheManager；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.atguigu.cache.mapper"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot01CacheApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Springboot01CacheApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.cache.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.cache.mapper.EmployeeMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheConfig</span>(cacheNames=<span class="string">"emp"</span><span class="comment">/*,cacheManager = "employeeCacheManager"*/</span>) <span class="comment">//抽取缓存的公共配置</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法；</span></span><br><span class="line"><span class="comment">     * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 原理：</span></span><br><span class="line"><span class="comment">     *   1、自动配置类；CacheAutoConfiguration</span></span><br><span class="line"><span class="comment">     *   2、缓存的配置类</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】</span></span><br><span class="line"><span class="comment">     *   org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration</span></span><br><span class="line"><span class="comment">     *   3、哪个配置类默认生效：SimpleCacheConfiguration；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager</span></span><br><span class="line"><span class="comment">     *   5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   运行流程：</span></span><br><span class="line"><span class="comment">     *   <span class="doctag">@Cacheable</span>：</span></span><br><span class="line"><span class="comment">     *   1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；</span></span><br><span class="line"><span class="comment">     *      （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。</span></span><br><span class="line"><span class="comment">     *   2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数；</span></span><br><span class="line"><span class="comment">     *      key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key；</span></span><br><span class="line"><span class="comment">     *          SimpleKeyGenerator生成key的默认策略；</span></span><br><span class="line"><span class="comment">     *                  如果没有参数；key=new SimpleKey()；</span></span><br><span class="line"><span class="comment">     *                  如果有一个参数：key=参数的值</span></span><br><span class="line"><span class="comment">     *                  如果有多个参数：key=new SimpleKey(params)；</span></span><br><span class="line"><span class="comment">     *   3、没有查到缓存就调用目标方法；</span></span><br><span class="line"><span class="comment">     *   4、将目标方法返回的结果，放进缓存中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   <span class="doctag">@Cacheable</span>标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，</span></span><br><span class="line"><span class="comment">     *   如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   核心：</span></span><br><span class="line"><span class="comment">     *      1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件</span></span><br><span class="line"><span class="comment">     *      2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   几个属性：</span></span><br><span class="line"><span class="comment">     *      cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值  1-方法的返回值</span></span><br><span class="line"><span class="comment">     *              编写SpEL； #i d;参数id的值   #a0  #p0  #root.args[0]</span></span><br><span class="line"><span class="comment">     *              getEmp[2]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      keyGenerator：key的生成器；可以自己指定key的生成器的组件id</span></span><br><span class="line"><span class="comment">     *              key/keyGenerator：二选一使用;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      condition：指定符合条件的情况下才缓存；</span></span><br><span class="line"><span class="comment">     *              ,condition = "#id&gt;0"</span></span><br><span class="line"><span class="comment">     *          condition = "#a0&gt;1"：第一个参数的值》1的时候才进行缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断</span></span><br><span class="line"><span class="comment">     *              unless = "#result == null"</span></span><br><span class="line"><span class="comment">     *              unless = "#a0==2":如果第一个参数的值是2，结果不缓存；</span></span><br><span class="line"><span class="comment">     *      sync：是否使用异步模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = &#123;<span class="string">"emp"</span>&#125;<span class="comment">/*,keyGenerator = "myKeyGenerator",condition = "#a0&gt;1",unless = "#a0==2"*/</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmp</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询"</span>+id+<span class="string">"号员工"</span>);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@CachePut</span>：既调用方法，又更新缓存数据；同步更新缓存</span></span><br><span class="line"><span class="comment">     * 修改了数据库的某个数据，同时更新缓存；</span></span><br><span class="line"><span class="comment">     * 运行时机：</span></span><br><span class="line"><span class="comment">     *  1、先调用目标方法</span></span><br><span class="line"><span class="comment">     *  2、将目标方法的结果缓存起来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 测试步骤：</span></span><br><span class="line"><span class="comment">     *  1、查询1号员工；查到的结果会放在缓存中；</span></span><br><span class="line"><span class="comment">     *          key：1  value：lastName：张三</span></span><br><span class="line"><span class="comment">     *  2、以后查询还是之前的结果</span></span><br><span class="line"><span class="comment">     *  3、更新1号员工；【lastName:zhangsan；gender:0】</span></span><br><span class="line"><span class="comment">     *          将方法的返回值也放进缓存了；</span></span><br><span class="line"><span class="comment">     *          key：传入的employee对象  值：返回的employee对象；</span></span><br><span class="line"><span class="comment">     *  4、查询1号员工？</span></span><br><span class="line"><span class="comment">     *      应该是更新后的员工；</span></span><br><span class="line"><span class="comment">     *          key = "#employee.id":使用传入的参数的员工id；</span></span><br><span class="line"><span class="comment">     *          key = "#result.id"：使用返回后的id</span></span><br><span class="line"><span class="comment">     *             <span class="doctag">@Cacheable</span>的key是不能用#result</span></span><br><span class="line"><span class="comment">     *      为什么是没更新前的？【1号员工没有在缓存中更新】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CachePut</span>(<span class="comment">/*value = "emp",*/</span>key = <span class="string">"#result.id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">updateEmp</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"updateEmp:"</span>+employee);</span><br><span class="line">        employeeMapper.updateEmp(employee);</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@CacheEvict</span>：缓存清除</span></span><br><span class="line"><span class="comment">     *  key：指定要清除的数据</span></span><br><span class="line"><span class="comment">     *  allEntries = true：指定清除这个缓存中所有的数据</span></span><br><span class="line"><span class="comment">     *  beforeInvocation = false：缓存的清除是否在方法之前执行</span></span><br><span class="line"><span class="comment">     *      默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  beforeInvocation = true：</span></span><br><span class="line"><span class="comment">     *      代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value=<span class="string">"emp"</span>,beforeInvocation = <span class="keyword">true</span><span class="comment">/*key = "#id",*/</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmp</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"deleteEmp:"</span>+id);</span><br><span class="line">        <span class="comment">//employeeMapper.deleteEmpById(id);</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Caching 定义复杂的缓存规则</span></span><br><span class="line">    <span class="meta">@Caching</span>(</span><br><span class="line">         cacheable = &#123;</span><br><span class="line">             <span class="meta">@Cacheable</span>(<span class="comment">/*value="emp",*/</span>key = <span class="string">"#lastName"</span>)</span><br><span class="line">         &#125;,</span><br><span class="line">         put = &#123;</span><br><span class="line">             <span class="meta">@CachePut</span>(<span class="comment">/*value="emp",*/</span>key = <span class="string">"#result.id"</span>),</span><br><span class="line">             <span class="meta">@CachePut</span>(<span class="comment">/*value="emp",*/</span>key = <span class="string">"#result.email"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByLastName</span><span class="params">(String lastName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeMapper.getEmpByLastName(lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.cache.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.cache.mapper.EmployeeMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Springboot01CacheApplicationTests</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;  <span class="comment">//操作k-v都是字符串的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisTemplate redisTemplate;  <span class="comment">//k-v都是对象的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisTemplate&lt;Object, Employee&gt; empRedisTemplate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis常见的五大数据类型</span></span><br><span class="line"><span class="comment"> *  String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合）</span></span><br><span class="line"><span class="comment"> *  stringRedisTemplate.opsForValue()[String（字符串）]</span></span><br><span class="line"><span class="comment"> *  stringRedisTemplate.opsForList()[List（列表）]</span></span><br><span class="line"><span class="comment"> *  stringRedisTemplate.opsForSet()[Set（集合）]</span></span><br><span class="line"><span class="comment"> *  stringRedisTemplate.opsForHash()[Hash（散列）]</span></span><br><span class="line"><span class="comment"> *  stringRedisTemplate.opsForZSet()[ZSet（有序集合）]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//给redis中保存数据</span></span><br><span class="line">    <span class="comment">//stringRedisTemplate.opsForValue().append("msg","hello");</span></span><br><span class="line"><span class="comment">//String msg = stringRedisTemplate.opsForValue().get("msg");</span></span><br><span class="line"><span class="comment">//System.out.println(msg);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stringRedisTemplate.opsForList().leftPush("mylist","1");</span></span><br><span class="line"><span class="comment">//stringRedisTemplate.opsForList().leftPush("mylist","2");</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试保存对象</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">Employee empById = employeeMapper.getEmpById(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//默认如果保存对象，使用jdk序列化机制，序列化后的数据保存到redis中</span></span><br><span class="line"><span class="comment">//redisTemplate.opsForValue().set("emp-01",empById);</span></span><br><span class="line"><span class="comment">//1、将数据以json的方式保存</span></span><br><span class="line"> <span class="comment">//(1)自己将对象转为json</span></span><br><span class="line"> <span class="comment">//(2)redisTemplate默认的序列化规则；改变默认的序列化规则；</span></span><br><span class="line">empRedisTemplate.opsForValue().set(<span class="string">"emp-01"</span>,empById);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Employee empById = employeeMapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">System.out.println(empById);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"myKeyGenerator"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> method.getName()+<span class="string">"["</span>+ Arrays.asList(params).toString()+<span class="string">"]"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.cache.bean.Department;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.cache.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Employee&gt; <span class="title">empRedisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Employee&gt; template = <span class="keyword">new</span> RedisTemplate&lt;Object, Employee&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Employee&gt; ser = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        template.setDefaultSerializer(ser);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Department&gt; <span class="title">deptRedisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Department&gt; template = <span class="keyword">new</span> RedisTemplate&lt;Object, Department&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Department&gt; ser = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Department&gt;(Department<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        template.setDefaultSerializer(ser);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//CacheManagerCustomizers可以来定制缓存的一些规则</span></span><br><span class="line">    <span class="meta">@Primary</span>  <span class="comment">//将某个缓存管理器作为默认的</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">employeeCacheManager</span><span class="params">(RedisTemplate&lt;Object, Employee&gt; empRedisTemplate)</span></span>&#123;</span><br><span class="line">        RedisCacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(empRedisTemplate);</span><br><span class="line">        <span class="comment">//key多了一个前缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用前缀，默认会将CacheName作为key的前缀</span></span><br><span class="line">        cacheManager.setUsePrefix(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">deptCacheManager</span><span class="params">(RedisTemplate&lt;Object, Department&gt; deptRedisTemplate)</span></span>&#123;</span><br><span class="line">        RedisCacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(deptRedisTemplate);</span><br><span class="line">        <span class="comment">//key多了一个前缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用前缀，默认会将CacheName作为key的前缀</span></span><br><span class="line">        cacheManager.setUsePrefix(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.cache.bean.Department;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.cache.mapper.DepartmentMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DepartmentMapper departmentMapper;</span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"deptCacheManager"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisCacheManager deptCacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  缓存的数据能存入redis；</span></span><br><span class="line"><span class="comment">     *  第二次从缓存中查询就不能反序列化回来；</span></span><br><span class="line"><span class="comment">     *  存的是dept的json数据;CacheManager默认使用RedisTemplate&lt;Object, Employee&gt;操作Redis</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Cacheable(cacheNames = "dept",cacheManager = "deptCacheManager")</span></span><br><span class="line"><span class="comment">//    public Department getDeptById(Integer id)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("查询部门"+id);</span></span><br><span class="line"><span class="comment">//        Department department = departmentMapper.getDeptById(id);</span></span><br><span class="line"><span class="comment">//        return department;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用缓存管理器得到缓存，进行api调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询部门"</span>+id);</span><br><span class="line">        Department department = departmentMapper.getDeptById(id);</span><br><span class="line">        <span class="comment">//获取某个缓存</span></span><br><span class="line">        Cache dept = deptCacheManager.getCache(<span class="string">"dept"</span>);</span><br><span class="line">        dept.put(<span class="string">"dept:1"</span>,department);</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象泛型属性类型转换问题</title>
      <link href="/2020/02/12/2020-02-12-%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/12/2020-02-12-%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="对象泛型属性类型转换问题"><a href="#对象泛型属性类型转换问题" class="headerlink" title="对象泛型属性类型转换问题"></a>对象泛型属性类型转换问题</h1><h3 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h3><blockquote><p>jekins打包时，如下代码报类型转换异常，代码(第二行getRows方法)以及报错信息如下：</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20191205094224.png" alt=""></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incompatible types: java.util.List&lt;capture#1 of ?&gt; cannot be converted to java.util.List&lt;com.fwd.saturn.navigator.tasktodo.bo.TaskTodoCaseBO&gt;</span><br></pre></td></tr></table></figure><p>Page对象属性：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20191205094341.png" alt=""></p><p>因为Page类泛型的缘故，jekins编译由于某些设置而报错，本地运行、编译、打包都是正常的，最后用fastjson(别的方式也可以)先将getRows()方法返回的list转成json字符串，再将字符串转lis对象，最终代码如下图：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20191205094653.png" alt=""></p><blockquote><p> <u><strong><em>此篇文章仅记录此次问题</em></strong></u></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> bug </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 中涉及的设计模式总结</title>
      <link href="/2020/01/15/2020-01-15-Spring%20%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/15/2020-01-15-Spring%20%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原创iCoding91 最后发布于2018-04-22 16:00:21 阅读数 12558  收藏</p><p>原文版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p><p>原文链接：<a href="https://blog.csdn.net/caoxiaohong1005/article/details/80039656" target="_blank" rel="noopener">https://blog.csdn.net/caoxiaohong1005/article/details/80039656</a></p></blockquote><h1 id="Spring-中涉及的设计模式总结"><a href="#Spring-中涉及的设计模式总结" class="headerlink" title="Spring 中涉及的设计模式总结"></a>Spring 中涉及的设计模式总结</h1><h4 id="1-简单工厂-非-23-种设计模式中的一种"><a href="#1-简单工厂-非-23-种设计模式中的一种" class="headerlink" title="1. 简单工厂 (非 23 种设计模式中的一种)"></a>1. 简单工厂 (非 23 种设计模式中的一种)</h4><ul><li>实现方式：<strong>BeanFactory</strong>。 Spring 中的 BeanFactory 就是简单工厂模式的体现，根据传入一个唯一的标识来获得 Bean 对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</li><li>实质：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</li><li>实现原理：  <ul><li>bean 容器的启动阶段：  <ul><li>读取 bean 的 xml 配置文件, 将 bean 元素分别转换成一个 BeanDefinition 对象。</li><li>然后通过 BeanDefinitionRegistry 将这些 bean 注册到 beanFactory 中，保存在它的一个 ConcurrentHashMap 中。</li><li>将 BeanDefinition 注册到了 beanFactory 之后，在这里 Spring 为我们提供了一个扩展的切口，允许我们通过实现接口 BeanFactoryPostProcessor 在此处来插入我们定义的代码。典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的 dataSource 时使用到的占位符的值，就是它注入进去的。</li></ul></li><li>容器中 bean 的实例化阶段：<br>实例化阶段主要是通过反射或者 CGLIB 对 bean 进行实例化，在这个阶段 Spring 又给我们暴露了很多的扩展点：  <ul><li>各种的 Aware 接口，比如 BeanFactoryAware，对于实现了这些 Aware 接口的 bean，在实例化 bean 时 Spring 会帮我们注入对应的 BeanFactory 的实例。</li><li>BeanPostProcessor 接口，实现了 BeanPostProcessor 接口的 bean，在实例化 bean 时 Spring 会帮我们调用接口中的方法。</li><li>InitializingBean 接口，实现了 InitializingBean 接口的 bean，在实例化 bean 时 Spring 会帮我们调用接口中的方法。</li><li>DisposableBean 接口，实现了 BeanPostProcessor 接口的 bean，在该 bean 死亡时 Spring 会帮我们调用接口中的方法。</li></ul></li></ul></li><li>设计意义：  <ul><li><strong>松耦合</strong>。可以将原来硬编码的依赖，通过 Spring 这个 beanFactory 这个工长来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring 这个 beanFactory，由它来解决 bean 之间的依赖问题，达到了松耦合的效果.</li><li><strong>bean 的额外处理</strong>。通过 Spring 接口的暴露，在实例化 bean 的阶段我们可以进行一些额外的处理，这些额外的处理只需要让 bean 实现对应的接口即可，那么 spring 就会在 bean 的生命周期调用我们实现的接口来处理该 bean。<code>[非常重要]</code></li></ul></li></ul><h4 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h4><ul><li>实现方式：FactoryBean 接口。</li><li>实现原理：<br>实现了 FactoryBean 接口的 bean 是一类叫做 factory 的 bean。其特点是，spring 会在使用 getBean() 调用获得该 bean 时，会自动调用该 bean 的 getObject() 方法，所以<strong>返回的不是 factory 这个 bean，而是这个 bean.getOjbect() 方法的返回值。</strong></li><li>例子：  <ul><li>典型的例子有 spring 与 mybatis 的结合。</li><li>代码示例<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20200318094943.png" alt=""></li><li>说明：<br>我们看上面该 bean，因为实现了 FactoryBean 接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是她的 SqlSessionFactoryBean.getObject() 的返回值。</li></ul></li></ul><h4 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3. 单例模式"></a>3. 单例模式</h4><ul><li><p>Spring 依赖注入 Bean 实例默认是单例的。</p></li><li><p>Spring 的依赖注入（包括 lazy-init 方式）都是发生在 AbstractBeanFactory 的 getBean 里。getBean 的 doGetBean 方法调用 getSingleton 进行 bean 的创建。</p></li><li><p>分析 getSingleton() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Object getSingleton(String beanName)&#123;</span><br><span class="line">    &#x2F;&#x2F;参数true设置标识允许早期依赖</span><br><span class="line">    return getSingleton(beanName,true);</span><br><span class="line">&#125;</span><br><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">    &#x2F;&#x2F;检查缓存中是否存在实例</span><br><span class="line">    Object singletonObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">    if (singletonObject &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果为空，则锁定全局变量并进行处理。</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果此bean正在加载，则不处理</span><br><span class="line">            singletonObject &#x3D; this.earlySingletonObjects.get(beanName);</span><br><span class="line">            if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;  </span><br><span class="line">                &#x2F;&#x2F;当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory &#x3D; this.singletonFactories.get(beanName);</span><br><span class="line">                if (singletonFactory !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;调用预先设定的getObject方法</span><br><span class="line">                    singletonObject &#x3D; singletonFactory.getObject();</span><br><span class="line">                    &#x2F;&#x2F;记录在缓存中，earlysingletonObjects和singletonFactories互斥</span><br><span class="line">                    this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    this.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getSingleton() 过程图<br>ps：spring 依赖注入时，使用了 <strong>双重判断加锁</strong> 的单例模式<br><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20200318095249.png" alt=""></li><li>总结</li><li>单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li>spring 对单例的实现：spring 中的单例模式完成了后半句话，即提供了全局的访问点 BeanFactory。但没有从构造器级别去控制单例，这是因为 spring 管理的是任意的 java 对象。</li></ul></li></ul><h4 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4. 适配器模式"></a>4. 适配器模式</h4><ul><li>实现方式：SpringMVC 中的适配器 HandlerAdatper。</li><li>实现原理：HandlerAdatper 根据 Handler 规则执行不同的 Handler。</li><li>实现过程：<br>DispatcherServlet 根据 HandlerMapping 返回的 handler，向 HandlerAdatper 发起请求，处理 Handler。HandlerAdapter 根据规则找到对应的 Handler 并让其执行，执行完毕后 Handler 会向 HandlerAdapter 返回一个 ModelAndView，最后由 HandlerAdapter 向 DispatchServelet 返回一个 ModelAndView。</li><li>实现意义：<br>HandlerAdatper 使得 Handler 的扩展变得容易，只需要增加一个新的 Handler 和一个对应的 HandlerAdapter 即可。因此 Spring 定义了一个适配接口，使得每一种 Controller 有一种对应的适配器实现类，让适配器代替 controller 执行相应的方法。这样在扩展 Controller 时，只需要增加一个适配器类就完成了 SpringMVC 的扩展了。</li></ul><h4 id="5-装饰器模式"><a href="#5-装饰器模式" class="headerlink" title="5. 装饰器模式"></a>5. 装饰器模式</h4><ul><li>实现方式：<br>Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有 Decorator。</li><li>实质：  <ul><li>动态地给一个对象添加一些额外的职责。</li><li>就增加功能来说，Decorator 模式相比生成子类更为灵活。</li></ul></li></ul><h4 id="6-代理模式"><a href="#6-代理模式" class="headerlink" title="6. 代理模式"></a>6. 代理模式</h4><ul><li>实现方式： AOP 底层，就是动态代理模式的实现。  <ul><li>动态代理：在内存中构建的，不需要手动编写代理类</li><li>静态代理：需要手工编写代理类，代理类引用被代理对象。</li></ul></li><li>实现原理：<br>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象创建动态的创建一个代理对象。SpringAOP 就是以这种方式织入切面的。<br><code>织入：把切面应用到目标对象并创建新的代理对象的过程。</code></li></ul><h4 id="7-观察者模式"><a href="#7-观察者模式" class="headerlink" title="7. 观察者模式"></a>7. 观察者模式</h4><ul><li><p>实现方式：spring 的事件驱动模型使用的是 <strong>观察者模式</strong> ，Spring 中 Observer 模式常用的地方是 listener 的实现。</p></li><li><p>具体实现：<br><code>事件机制的实现需要三个部分,事件源,事件,事件监听器</code></p><ul><li><p>ApplicationEvent 抽象类 <strong>[事件]</strong></p><ul><li><p>继承自 jdk 的 EventObject, 所有的事件都需要继承 ApplicationEvent, 并且通过构造器参数 source 得到事件源.</p></li><li><p>该类的实现类 ApplicationContextEvent 表示 ApplicaitonContext 的容器事件.</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ApplicationEvent extends EventObject &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7099057708183571937L;</span><br><span class="line">    private final long timestamp;</span><br><span class="line">    public ApplicationEvent(Object source) &#123;</span><br><span class="line">    super(source);</span><br><span class="line">    this.timestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    public final long getTimestamp() &#123;</span><br><span class="line">        return this.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ApplicationListener 接口 <strong>[事件监听器]</strong></p><ul><li><p>继承自 jdk 的 EventListener, 所有的监听器都要实现这个接口。</p></li><li><p>这个接口只有一个 onApplicationEvent() 方法, 该方法接受一个 ApplicationEvent 或其子类对象作为参数, 在方法体中, 可以通过不同对 Event 类的判断来进行相应的处理。</p></li><li><p>当事件触发时所有的监听器都会收到消息。</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends                EventListener &#123;</span><br><span class="line">                 void onApplicationEvent(E event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ApplicationContext 接口 <strong>[事件源]</strong></p><ul><li><p>ApplicationContext 是 spring 中的全局容器, 翻译过来是” 应用上下文”。</p></li><li><p>实现了 ApplicationEventPublisher 接口。</p></li><li><p>职责：负责读取 bean 的配置文档, 管理 bean 的加载, 维护 bean 之间的依赖关系, 可以说是负责 bean 的整个生命周期, 再通俗一点就是我们平时所说的 IOC 容器。</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationEventPublisher &#123;</span><br><span class="line">        void publishEvent(ApplicationEvent event);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">public void publishEvent(ApplicationEvent event) &#123;</span><br><span class="line">    Assert.notNull(event, &quot;Event must not be null&quot;);</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(&quot;Publishing event in &quot; + getDisplayName() + &quot;: &quot; + event);</span><br><span class="line">    &#125;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(event);</span><br><span class="line">    if (this.parent !&#x3D; null) &#123;</span><br><span class="line">    this.parent.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ApplicationEventMulticaster 抽象类 <strong>[事件源中 publishEvent 方法需要调用其方法 getApplicationEventMulticaster]</strong></p><ul><li><p>属于事件广播器, 它的作用是把 Applicationcontext 发布的 Event 广播给所有的监听器.</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader</span><br><span class="line">    implements ConfigurableApplicationContext, DisposableBean &#123;  </span><br><span class="line">    private ApplicationEventMulticaster applicationEventMulticaster;  </span><br><span class="line">    protected void registerListeners() &#123;  </span><br><span class="line">    &#x2F;&#x2F; Register statically specified listeners first.  </span><br><span class="line">    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;  </span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; Do not initialize FactoryBeans here: We need to leave all regular beans  </span><br><span class="line">    &#x2F;&#x2F; uninitialized to let post-processors apply to them!  </span><br><span class="line">    String[] listenerBeanNames &#x3D; getBeanNamesForType(ApplicationListener.class, true, false);  </span><br><span class="line">    for (String lisName : listenerBeanNames) &#123;  </span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(lisName);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="8-策略模式"><a href="#8-策略模式" class="headerlink" title="8. 策略模式"></a>8. 策略模式</h4><ul><li>实现方式：Spring 框架的<strong>资源访问 Resource 接口</strong> 。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</li><li>Resource 接口介绍  <ul><li>source 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。</li><li>Resource 接口主要提供了如下几个方法:  <ul><li>getInputStream()：定位并打开资源，返回资源对应的输入流。每次调用都返回新的输入流。调用者必须负责关闭输入流。</li><li>exists()：返回 Resource 所指向的资源是否存在。</li><li>isOpen()：返回资源文件是否打开，如果资源文件不能多次读取，每次读取结束应该显式关闭，以防止资源泄漏。</li><li>getDescription()：返回资源的描述信息，通常用于资源处理出错时输出该信息，通常是全限定文件名或实际 URL。</li><li>getFile：返回资源对应的 File 对象。</li><li>getURL：返回资源对应的 URL 对象。<br><code>最后两个方法通常无须使用，仅在通过简单方式访问无法实现时，Resource 提供传统的资源访问的功能。</code></li></ul></li><li>Resource 接口本身没有提供访问任何底层资源的实现逻辑，<strong>针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。</strong></li><li>Spring 为 Resource 接口提供了如下实现类：  <ul><li>UrlResource：访问网络资源的实现类。</li><li>ClassPathResource：访问类加载路径里资源的实现类。</li><li>FileSystemResource：访问文件系统里资源的实现类。</li><li>ServletContextResource：访问相对于 ServletContext 路径里的资源的实现类.</li><li>InputStreamResource：访问输入流资源的实现类。</li><li>ByteArrayResource：访问字节数组资源的实现类。<br><code>这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</code></li></ul></li></ul></li></ul><h4 id="9-模版方法模式"><a href="#9-模版方法模式" class="headerlink" title="9. 模版方法模式"></a>9. 模版方法模式</h4><ul><li><p>经典模板方法定义：  </p><ul><li>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现</li><li>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。</li><li>所以父类模板方法中有两类方法：  <ul><li>共同的方法：所有子类都会用到的代码</li><li>不同的方法：子类要覆盖的方法，分为两种：  <ul><li>抽象方法：父类中的是抽象方法，子类必须覆盖</li><li>钩子方法：父类中是一个空方法，子类继承了默认也是空的<br><code>注：为什么叫钩子，子类可以通过这个钩子（方法），控制父类，因为这个钩子实际是父类的方法（空方法）！</code></li></ul></li></ul></li></ul></li><li><p>Spring 模板方法模式实质：<br><code>是模板方法模式和回调模式的结合</code>，是 Template Method 不需要继承的另一种实现方式。Spring 几乎所有的外接扩展都采用这种模式。</p></li><li><p>具体实现：<br>JDBC 的抽象和对 Hibernate 的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的 Callback 接口相结合。</p></li><li><p>采用模板方法模式是为了以一种统一而集中的方式来处理资源的获取和释放，以 JdbcTempalte 为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class JdbcTemplate &#123;  </span><br><span class="line">     public final Object execute（String sql）&#123;  </span><br><span class="line">        Connection con&#x3D;null;  </span><br><span class="line">        Statement stmt&#x3D;null;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            con&#x3D;getConnection（）;  </span><br><span class="line">            stmt&#x3D;con.createStatement（）;  </span><br><span class="line">            Object retValue&#x3D;executeWithStatement（stmt,sql）;  </span><br><span class="line">            return retValue;  </span><br><span class="line">        &#125;catch（SQLException e）&#123;  </span><br><span class="line">             ...  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    protected abstract Object executeWithStatement（Statement   stmt, String sql）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引入回调原因：</p><ul><li><p>JdbcTemplate 是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现, 这样肯定不方便，所以就引入了回调 。</p></li><li><p>回调代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface StatementCallback&#123;  </span><br><span class="line">    Object doWithStatement（Statement stmt）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用回调方法重写 JdbcTemplate 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcTemplate &#123;  </span><br><span class="line">    public final Object execute（StatementCallback callback）&#123;  </span><br><span class="line">        Connection con&#x3D;null;  </span><br><span class="line">        Statement stmt&#x3D;null;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            con&#x3D;getConnection（）;  </span><br><span class="line">            stmt&#x3D;con.createStatement（）;  </span><br><span class="line">            Object retValue&#x3D;callback.doWithStatement（stmt）;  </span><br><span class="line">            return retValue;  </span><br><span class="line">        &#125;catch（SQLException e）&#123;  </span><br><span class="line">            ...  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ...&#x2F;&#x2F;其它方法定义  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Jdbc 使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate&#x3D;...;  </span><br><span class="line">    final String sql&#x3D;...;  </span><br><span class="line">    StatementCallback callback&#x3D;new StatementCallback()&#123;  </span><br><span class="line">    public Object&#x3D;doWithStatement(Statement stmt)&#123;  </span><br><span class="line">        return ...;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;    </span><br><span class="line">jdbcTemplate.execute(callback);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为什么 JdbcTemplate 没有使用继承？<br>因为这个类的方法太多，但是我们还是想用到 JdbcTemplate 已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入 JdbcTemplate 的方法中。但是变化的东西是一段代码，而且这段代码会用到 JdbcTemplate 中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵 JdbcTemplate 中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到 JdbcTemplate，从而完成了调用。</p><p>参考：<br><a href="https://www.cnblogs.com/digdeep/p/4518571.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4518571.html</a><br><a href="https://www.cnblogs.com/tongkey/p/7919401.html" target="_blank" rel="noopener">https://www.cnblogs.com/tongkey/p/7919401.html</a><br><a href="https://www.cnblogs.com/fingerboy/p/6393644.html" target="_blank" rel="noopener">https://www.cnblogs.com/fingerboy/p/6393644.html</a><br><a href="https://blog.csdn.net/ovoo_8/article/details/51189401" target="_blank" rel="noopener">https://blog.csdn.net/ovoo_8/article/details/51189401</a><br><a href="https://blog.csdn.net/z69183787/article/details/65628166" target="_blank" rel="noopener">https://blog.csdn.net/z69183787/article/details/65628166</a></p><p><a href="https://www.cnblogs.com/kyoner/p/10949246.html" target="_blank" rel="noopener">https://www.cnblogs.com/kyoner/p/10949246.html</a></p><p>《spring 源码深度分析》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准备刷 leetcode 了，才发现自己连时间复杂度都不懂</title>
      <link href="/2019/12/30/2019-12-30-%E5%87%86%E5%A4%87%E5%88%B7%20leetcode%20%E4%BA%86%EF%BC%8C%E6%89%8D%E5%8F%91%E7%8E%B0%E8%87%AA%E5%B7%B1%E8%BF%9E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E4%B8%8D%E6%87%82/"/>
      <url>/2019/12/30/2019-12-30-%E5%87%86%E5%A4%87%E5%88%B7%20leetcode%20%E4%BA%86%EF%BC%8C%E6%89%8D%E5%8F%91%E7%8E%B0%E8%87%AA%E5%B7%B1%E8%BF%9E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E4%B8%8D%E6%87%82/</url>
      
        <content type="html"><![CDATA[<h1 id="准备刷-leetcode-了，才发现自己连时间复杂度都不懂"><a href="#准备刷-leetcode-了，才发现自己连时间复杂度都不懂" class="headerlink" title="准备刷 leetcode 了，才发现自己连时间复杂度都不懂"></a>准备刷 leetcode 了，才发现自己连时间复杂度都不懂</h1><blockquote><p>原文地址 <a href="https://juejin.im/post/5e7c0946f265da42e879fe0c" target="_blank" rel="noopener">https://juejin.im/post/5e7c0946f265da42e879fe0c</a></p></blockquote><blockquote><p>高级工程师 title 的我，最近琢磨着好好刷刷算法题更高级一些，然鹅，当我准备回忆大学和面试时候学的数据结构之时，我发现自己对这个算法复杂度的记忆只有 OOOOOooo</p><p>文章收录在 GitHub <a href="https://github.com/Jstarfish/JavaKeeper" target="_blank" rel="noopener">JavaKeeper</a> ，N 线互联网开发必备技能兵器谱</p></blockquote><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</p><p>那么我们应该如何去衡量不同算法之间的优劣呢？</p><p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li></ul><p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或「<strong>时间频度</strong>」。记为 T(n)。</p><p>时间频度 T(n) 中，n 称为问题的规模，当 n 不断变化时，时间频度 T(n) 也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。算法的时间复杂度也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称「<strong>时间复杂度</strong>」。</p><p>这种表示方法我们称为「 <strong>大 O 符号表示法</strong> 」，又称为<strong>渐进符号</strong>，是用于描述函数渐进行为的数学符号</p><p>常见的时间复杂度量级有：</p><ul><li>常数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(1)" alt=""></li><li>线性阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n)" alt=""></li><li>平方阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n%5E2)" alt=""></li><li>立方阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n%5E3)" alt=""></li><li>对数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(logn)" alt=""></li><li>线性对数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(nlogn)" alt=""></li><li>指数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(2%5En)" alt=""></li></ul><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(1)" alt=""></h4><p><img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(1)" alt="">，表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1;</span><br><span class="line">int j &#x3D; 2;</span><br><span class="line">int k &#x3D; i + j;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(1)" alt="">来表示它的时间复杂度。</p><h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n)" alt=""></h4><p><img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n)" alt="">，表示一个算法的性能会随着输入数据的大小变化而线性变化，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line"> j &#x3D; i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n)" alt="">来表示它的时间复杂度。</p><h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n%5E2)" alt=""></h4><p><img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n%C2%B2)" alt=""> 表示一个算法的性能将会随着输入数据的增长而呈现出二次增长。最常见的就是对输入数据进行嵌套循环。如果嵌套层级不断深入的话，算法的性能将会变为立方阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n%5E3)" alt="">)，<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n%5E4)" alt="">)，<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n%5Ek)" alt="">以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(x&#x3D;1; i&lt;&#x3D;n; x++)&#123;</span><br><span class="line">   for(i&#x3D;1; i&lt;&#x3D;n; i++)&#123;</span><br><span class="line">       j &#x3D; i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="指数阶"><a href="#指数阶" class="headerlink" title="指数阶"></a>指数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(2%5En)" alt=""></h4><p><img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(2%5En)" alt="">，表示一个算法的性能会随着输入数据的每次增加而增大两倍，典型的方法就是裴波那契数列的递归计算实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Fibonacci(int number)</span><br><span class="line">&#123;</span><br><span class="line">    if (number &lt;&#x3D; 1) return number;</span><br><span class="line"></span><br><span class="line">    return Fibonacci(number - 2) + Fibonacci(number - 1);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(logn)" alt=""></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1;</span><br><span class="line">while(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i &#x3D; i * 2;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码，在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了，直到 i 不小于 n 退出。我们试着求解一下，假设循环次数为 x，也就是说 2 的 x 次方等于 n，则由 2^x=n 得出 x=log₂n。因此这个代码的时间复杂度为<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(logn)" alt=""></p><h4 id="线性对数阶"><a href="#线性对数阶" class="headerlink" title="线性对数阶"></a>线性对数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(nlogn)" alt=""></h4><p>线性对数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(nlogn)" alt="">)，就是将时间复杂度为对数阶<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(logn)" alt="">的代码循环 n 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(nlogn)" alt="">，如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(m&#x3D;1; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i &#x3D; 1;</span><br><span class="line">    while(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i &#x3D; i * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>除此之外，其实还有平均情况复杂度、最好时间复杂度、最坏时间复杂度。。。一般没有特殊说明的情况下，都是值最坏时间复杂度。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a><strong>空间复杂度</strong></h2><p>空间复杂度（Space Complexity）是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，一个算法所需的存储空间用 f(n) 表示。S(n)=O(f(n))，其中 n 为问题的规模，S(n) 表示空间复杂度。</p><p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。</p><p>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为 O(1)。当一个算法的空间复杂度与 n 成线性比例关系时，可表示为<img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=0(n)" alt="">，类比时间复杂度。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度 "></a>空间复杂度 <img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(1)" alt=""></h4><p>如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1) 举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1;</span><br><span class="line">int j &#x3D; 2;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m &#x3D; i + j;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度 "></a>空间复杂度 <img src= "/img/loading.gif" data-src="https://juejin.im/equation?tex=O(n)" alt=""></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] m &#x3D; new int[n]</span><br><span class="line">for(i&#x3D;1; i&lt;&#x3D;n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j &#x3D; i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><h2 id="复杂度速查表"><a href="#复杂度速查表" class="headerlink" title="复杂度速查表"></a>复杂度速查表</h2><p>来源：<a href="https://liam.page/2016/06/20/big-O-cheat-sheet/" target="_blank" rel="noopener">liam.page/2016/06/20/…</a> 源地址：<a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">www.bigocheatsheet.com/</a></p><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/3/26/171148436f30f2fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="大-O-复杂度曲线"><a href="#大-O-复杂度曲线" class="headerlink" title="大 - O 复杂度曲线"></a>大 - O 复杂度曲线</h4><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/3/26/171148436fd604cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="抽象数据结构的操作复杂度"><a href="#抽象数据结构的操作复杂度" class="headerlink" title="抽象数据结构的操作复杂度"></a>抽象数据结构的操作复杂度</h4><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/3/26/171148436fef7dc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/3/26/1711484370725f64?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="图操作"><a href="#图操作" class="headerlink" title="图操作"></a>图操作</h4><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/3/26/1711484370792d82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h4><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/3/26/1711484370dd4f33?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《大话数据结构》 <a href="https://zhuanlan.zhihu.com/p/50479555" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/50479555</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis全动态sql处理方式</title>
      <link href="/2019/12/17/2019-12-17-mybatis%E5%85%A8%E5%8A%A8%E6%80%81sql%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/12/17/2019-12-17-mybatis%E5%85%A8%E5%8A%A8%E6%80%81sql%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis全动态sql处理方式"><a href="#mybatis全动态sql处理方式" class="headerlink" title="mybatis全动态sql处理方式"></a>mybatis全动态sql处理方式</h1><blockquote><p>对于项目中需要用到全动态拼接sql的场景时，可以用到mybatis的statementType属性</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/1811991-20190920142529656-1591028426.png" alt=""></p><p>Demo(如果是非预编译的话，最好使用${}而不是#{})：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="query" resultType="Map" statementType="STATEMENT"&gt;  </span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> $&#123;tableName&#125; t <span class="keyword">where</span>  </span><br><span class="line">        &lt;foreach item=<span class="string">"item"</span> <span class="keyword">index</span>=<span class="string">"index"</span> collection=<span class="string">"field"</span> <span class="keyword">open</span>=<span class="string">" "</span>  </span><br><span class="line">            separator=<span class="string">"and"</span> <span class="keyword">close</span>=<span class="string">" "</span>&gt;  </span><br><span class="line">            &lt;<span class="keyword">choose</span>&gt;  </span><br><span class="line">                &lt;<span class="keyword">when</span> <span class="keyword">test</span>=<span class="string">"item.fieldType == 'DATE' and item.dateQueryFlag == 0"</span>&gt;  </span><br><span class="line">                    $&#123;item.fieldCode&#125; <span class="keyword">between</span>  </span><br><span class="line">                    <span class="keyword">to_date</span>(<span class="string">'$&#123;item.fieldValue&#125;'</span>,<span class="string">'yyyy-mm-dd  </span></span><br><span class="line"><span class="string">                    hh24:mi:ss'</span>)   </span><br><span class="line">                &lt;/<span class="keyword">when</span>&gt;  </span><br><span class="line">                &lt;<span class="keyword">when</span> <span class="keyword">test</span>=<span class="string">"item.fieldType == 'DATE' and item.dateQueryFlag == 1"</span>&gt;  </span><br><span class="line">                    <span class="keyword">to_date</span>(<span class="string">'$&#123;item.fieldValue&#125;'</span>,<span class="string">'yyyy-mm-dd  </span></span><br><span class="line"><span class="string">                    hh24:mi:ss'</span>)   </span><br><span class="line">                &lt;/<span class="keyword">when</span>&gt;  </span><br><span class="line">                &lt;<span class="keyword">when</span> <span class="keyword">test</span>=<span class="string">"item.fieldItemCode != null and item.fieldItemCode != ''"</span>&gt;  </span><br><span class="line">                    $&#123;item.fieldCode&#125; =  </span><br><span class="line">                    <span class="string">'$&#123;item.fieldItemCode&#125;'</span>  </span><br><span class="line">                &lt;/<span class="keyword">when</span>&gt;  </span><br><span class="line">                &lt;otherwise&gt;  </span><br><span class="line">                    $&#123;item.fieldCode&#125; =  </span><br><span class="line">                    <span class="string">'$&#123;item.fieldValue&#125;'</span>  </span><br><span class="line">                &lt;/otherwise&gt;  </span><br><span class="line">            &lt;/<span class="keyword">choose</span>&gt;  </span><br><span class="line">        &lt;/foreach&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中对象、json、list、map等互转专题-网络整理</title>
      <link href="/2019/12/07/2019-12-07-Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E3%80%81json%E3%80%81list%E3%80%81map%E7%AD%89%E4%BA%92%E8%BD%AC%E4%B8%93%E9%A2%98-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/"/>
      <url>/2019/12/07/2019-12-07-Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E3%80%81json%E3%80%81list%E3%80%81map%E7%AD%89%E4%BA%92%E8%BD%AC%E4%B8%93%E9%A2%98-%E7%BD%91%E7%BB%9C%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中对象、json、list、map等互转专题-网络整理"><a href="#Java中对象、json、list、map等互转专题-网络整理" class="headerlink" title="Java中对象、json、list、map等互转专题-网络整理"></a>Java中对象、json、list、map等互转专题-网络整理</h1><h2 id="fastjson方式"><a href="#fastjson方式" class="headerlink" title="fastjson方式"></a>fastjson方式</h2><h3 id="1-对象与字符串之间的互转"><a href="#1-对象与字符串之间的互转" class="headerlink" title="1.对象与字符串之间的互转"></a>1.对象与字符串之间的互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将对象转换成为字符串</span><br><span class="line">String str = JSON.toJSONString(oneObject);</span><br><span class="line">字符串转换成为对象</span><br><span class="line">OneObject oneObject = JSON.parseObject(str, OneObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-对象集合与字符串之间的互转"><a href="#2-对象集合与字符串之间的互转" class="headerlink" title="2.对象集合与字符串之间的互转"></a>2.对象集合与字符串之间的互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将对象集合转换成为字符串</span><br><span class="line">String strList = JSON.toJSONString(oneObjectList);</span><br><span class="line">将字符串转换成为对象集合</span><br><span class="line">List&lt;User&gt; oneObjectList = JSON.parseArray(strList, OneObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="3-字符串互转JSONObject"><a href="#3-字符串互转JSONObject" class="headerlink" title="3.字符串互转JSONObject"></a>3.字符串互转JSONObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String 转 Json对象</span></span><br><span class="line">JSONObject jsonObject = JSONObject.parseObject(str);</span><br><span class="line"><span class="comment">//json对象转字符串 </span></span><br><span class="line">String jsonString = jsonObject.toJSONString();</span><br></pre></td></tr></table></figure><h3 id="4-map与字符串之间互转"><a href="#4-map与字符串之间互转" class="headerlink" title="4.map与字符串之间互转"></a>4.map与字符串之间互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//map转字符串</span></span><br><span class="line"> String jsonString = JSON.toJSONString(map); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//字符串转map的几种方式   </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//第一种方式  </span></span><br><span class="line"> Map maps = (Map)JSON.parse(str);  </span><br><span class="line"> System.out.println(<span class="string">"这个是用JSON类来解析JSON字符串!!!"</span>);  </span><br><span class="line"> <span class="keyword">for</span> (Object map : maps.entrySet())&#123;  </span><br><span class="line">    System.out.println(((Map.Entry)map).getKey()+<span class="string">"-"</span> + ((Map.Entry)map).getValue());  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//第二种方式  </span></span><br><span class="line"> Map mapTypes = JSON.parseObject(str);  </span><br><span class="line"> System.out.println(<span class="string">"这个是用JSON类的parseObject来解析JSON字符串!!!"</span>);  </span><br><span class="line"> <span class="keyword">for</span> (Object obj : mapTypes.keySet())&#123;  </span><br><span class="line">     System.out.println(<span class="string">"key为："</span>+obj+<span class="string">"值为："</span>+mapTypes.get(obj));  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//第三种方式  </span></span><br><span class="line"> Map mapType = JSON.parseObject(str,Map<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line"> System.out.println(<span class="string">"这个是用JSON类,指定解析类型，来解析JSON字符串!!!"</span>);  </span><br><span class="line"> <span class="keyword">for</span> (Object obj : mapType.keySet())&#123;  </span><br><span class="line">      System.out.println(<span class="string">"key为："</span>+obj+<span class="string">"值为："</span>+mapType.get(obj));  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//第四种</span></span><br><span class="line"> Map&lt;String, Object&gt; map = JSON.parseObject(result,</span><br><span class="line">                                          <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Object&gt;&gt;()&#123;&#125;);</span><br><span class="line"> <span class="comment">//第五种方式</span></span><br><span class="line"> JSONArray listObjectSeven = JSON.parseArray(strArr);</span><br><span class="line"> System.out.println(<span class="string">"利用JSON中的parseArray方法来解析json数组字符串"</span>);</span><br><span class="line"> <span class="keyword">for</span>(Object mapList : listObjectSeven)&#123;</span><br><span class="line">     <span class="keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;</span><br><span class="line">         System.out.println(((Map.Entry)entry).getKey()  + <span class="string">"  "</span> +</span><br><span class="line">                            ((Map.Entry)entry).getValue());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//第六种方式  </span></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * JSONObject是Map接口的一个实现类 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"> Map json = (Map) JSONObject.parse(str);  </span><br><span class="line"> System.out.println(<span class="string">"这个是用JSONObject类的parse方法来解析JSON字符串!!!"</span>);  </span><br><span class="line"> <span class="keyword">for</span> (Object map : json.entrySet())&#123;  </span><br><span class="line">    System.out.println(((Map.Entry)map).getKey()+<span class="string">"  "</span>+((Map.Entry)map).getValue());  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//第七种方式  </span></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * JSONObject是Map接口的一个实现类 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"> JSONObject jsonObject = JSONObject.parseObject(str);</span><br><span class="line"> <span class="comment">//json对象转Map</span></span><br><span class="line"> <span class="comment">//Map&lt;String,Object&gt; map = (Map&lt;String,Object&gt;)jsonObject;</span></span><br><span class="line"> System.out.println(<span class="string">"这个是用JSONObject的parseObject方法来解析JSON字符串!!!"</span>);  </span><br><span class="line"> <span class="keyword">for</span> (Object map : json.entrySet())&#123;  </span><br><span class="line">     System.out.println(((Map.Entry)map).getKey()+<span class="string">"  "</span>+((Map.Entry)map).getValue());  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">//第八种方式  </span></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * JSONObject是Map接口的一个实现类 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"> Map mapObj = JSONObject.parseObject(str,Map<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line"> System.out.println(<span class="string">"这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!"</span>);  </span><br><span class="line"> <span class="keyword">for</span> (Object map: json.entrySet())&#123;  </span><br><span class="line">    System.out.println(((Map.Entry)map).getKey()+<span class="string">"  "</span>+((Map.Entry)map).getValue());  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//第九种方式</span></span><br><span class="line"> JSONArray listObjectFifth = JSONObject.parseArray(strArr);</span><br><span class="line"> System.out.println(<span class="string">"利用JSONObject中的parseArray方法来解析json数组字符串"</span>);</span><br><span class="line"> <span class="keyword">for</span>(Object mapList : listObjectFifth)&#123;</span><br><span class="line">     <span class="keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;</span><br><span class="line">         System.out.println(((Map.Entry)entry).getKey()  + <span class="string">"  "</span> +</span><br><span class="line">                            ((Map.Entry)entry).getValue());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//第十种方式</span></span><br><span class="line"> List listObjectSix = JSONObject.parseArray(strArr,Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> System.out.println(<span class="string">"利用JSONObject中的parseArray方法并指定返回类型来解析json数组字符串"</span>);</span><br><span class="line"> <span class="keyword">for</span>(Object mapList : listObjectSix)&#123;</span><br><span class="line">      <span class="keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;</span><br><span class="line">           System.out.println(((Map.Entry)entry).getKey()  + <span class="string">"  "</span> +</span><br><span class="line">                              ((Map.Entry)entry).getValue());</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第十一种方式</span></span><br><span class="line">List&lt;Map&lt;String,String&gt;&gt; listObjectFir = </span><br><span class="line">    (List&lt;Map&lt;String,String&gt;&gt;) JSONArray.parse(strArr);</span><br><span class="line">System.out.println(<span class="string">"利用JSONArray中的parse方法来解析json数组字符串"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map&lt;String,String&gt; mapList : listObjectFir)&#123;</span><br><span class="line">     <span class="keyword">for</span> (Map.Entry entry : mapList.entrySet())&#123;</span><br><span class="line">         System.out.println( entry.getKey()  + <span class="string">"  "</span> +entry.getValue());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第十二种方式</span></span><br><span class="line"> List&lt;Map&lt;String,String&gt;&gt; listObjectSec = JSONArray.parseObject(strArr,List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> System.out.println(<span class="string">"利用JSONArray中的parseObject方法并指定返回类型来解析json数组字符串"</span>);</span><br><span class="line"> <span class="keyword">for</span>(Map&lt;String,String&gt; mapList : listObjectSec)&#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry entry : mapList.entrySet())&#123;</span><br><span class="line">          System.out.println( entry.getKey()  + <span class="string">"  "</span> +entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//第十三种方式</span></span><br><span class="line"> JSONArray listObjectThir = JSONArray.parseArray(strArr);</span><br><span class="line"> System.out.println(<span class="string">"利用JSONArray中的parseArray方法来解析json数组字符串"</span>);</span><br><span class="line"> <span class="keyword">for</span>(Object mapList : listObjectThir)&#123;</span><br><span class="line">      <span class="keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;</span><br><span class="line">   System.out.println(((Map.Entry)entry).getKey()+ <span class="string">""</span>+</span><br><span class="line">                          ((Map.Entry)entry).getValue());</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//第十四种方式</span></span><br><span class="line"> List listObjectFour = JSONArray.parseArray(strArr,Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> System.out.println(<span class="string">"利用JSONArray中的parseArray方法并指定返回类型来解析json数组字符串"</span>);</span><br><span class="line"> <span class="keyword">for</span>(Object mapList : listObjectFour)&#123;</span><br><span class="line">      <span class="keyword">for</span> (Object entry : ((Map)mapList).entrySet())&#123;</span><br><span class="line">          System.out.println(((Map.Entry)entry).getKey()  + <span class="string">"  "</span> +</span><br><span class="line">                             ((Map.Entry)entry).getValue());</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-Map-转-Json对象"><a href="#5-Map-转-Json对象" class="headerlink" title="5.Map 转 Json对象"></a>5.Map 转 Json对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//map转json对象    </span></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">"column"</span>, <span class="string">"abc"</span>);</span><br><span class="line">   map.put(<span class="string">"length"</span>, <span class="string">"89"</span>);</span><br><span class="line">   JSONObject json = <span class="keyword">new</span> JSONObject(map);　　</span><br><span class="line">   <span class="comment">//json对象转Map</span></span><br><span class="line">Map&lt;String,Object&gt; map = (Map&lt;String,Object&gt;)jsonObject;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java,java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 下 shadowsocks-libev 一键安装脚本以及安装rinetd加速</title>
      <link href="/2019/11/27/2019-11-27-CentOS%20%E4%B8%8B%20shadowsocks-libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85rinetd%E5%8A%A0%E9%80%9F/"/>
      <url>/2019/11/27/2019-11-27-CentOS%20%E4%B8%8B%20shadowsocks-libev%20%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85rinetd%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="CentOS-下-shadowsocks-libev-一键安装脚本以及安装rinetd加速"><a href="#CentOS-下-shadowsocks-libev-一键安装脚本以及安装rinetd加速" class="headerlink" title="CentOS 下 shadowsocks-libev 一键安装脚本以及安装rinetd加速"></a>CentOS 下 shadowsocks-libev 一键安装脚本以及安装rinetd加速</h3><blockquote><p>原文<a href="https://github.com/Puuoi/ss-libev-for-CentoOS" target="_blank" rel="noopener">https://github.com/Puuoi/ss-libev-for-CentoOS</a></p></blockquote><p>原文链接：<a href="https://teddysun.com/357.html" target="_blank" rel="noopener">https://teddysun.com/357.html</a></p><p>本脚本适用环境：<br>系统支持：CentOS<br>内存要求：≥128M<br>日期：2018 年 06 月 01 日</p><h4 id="关于本脚本："><a href="#关于本脚本：" class="headerlink" title="关于本脚本："></a>关于本脚本：</h4><p>一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k 左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。</p><p>Shadowsocks for Windows 客户端下载：<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>默认配置：<br>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）</p><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><p>使用 root 用户登录，运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh </span><br><span class="line">chmod +x shadowsocks-libev.sh</span><br><span class="line">./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log</span><br></pre></td></tr></table></figure><p>安装完成后，脚本提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, Shadowsocks-libev server install completed!</span><br><span class="line">Your Server IP        :your_server_ip </span><br><span class="line">Your Server Port      :your_server_port </span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/357.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><h4 id="卸载方法："><a href="#卸载方法：" class="headerlink" title="卸载方法："></a>卸载方法：</h4><p>使用 root 用户登录，运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-libev.sh uninstall&lt;/br&gt;</span><br></pre></td></tr></table></figure><p>安装完成后即已后台启动 Shadowsocks-libev ，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks status</span><br></pre></td></tr></table></figure><p>可以查看进程是否启动。<br>本脚本安装完成后，会将 Shadowsocks-libev 加入开机自启动。</p><h4 id="使用命令："><a href="#使用命令：" class="headerlink" title="使用命令："></a>使用命令：</h4><p>启动：/etc/init.d/shadowsocks start<br>停止：/etc/init.d/shadowsocks stop<br>重启：/etc/init.d/shadowsocks restart<br>查看状态：/etc/init.d/shadowsocks status</p><p>特别说明：<br>1、已安装旧版本的 shadowsocks 需要升级的话，需下载本脚本的最新版，直接运行即可自动升级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-libev.sh</span><br></pre></td></tr></table></figure><p>参考链接：<br><a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-libev</a></p><h3 id="rinetd"><a href="#rinetd" class="headerlink" title="rinetd"></a>rinetd</h3><p>1、下载rintd二进制文件(原版bbr和修改版bbr二选一即可):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd</span><br><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/mixool/rinetd/master/rinetd_bbr_powered -O /root/rinetd</span><br></pre></td></tr></table></figure><p>2、修改权限:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x rinetd</span><br></pre></td></tr></table></figure><p>3、修改rinetd的配置文件rinetd.conf,添加监听地址:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> vi rinetd.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> bindadress bindport connectaddress connectport</span></span><br><span class="line">0.0.0.0 443 0.0.0.0 443</span><br><span class="line">0.0.0.0 80 0.0.0.0 80</span><br><span class="line">0.0.0.0 52800 0.0.0.0 52800</span><br></pre></td></tr></table></figure><p>4、设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/rinetd.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=rinetd</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/rinetd -f -c /root/rinetd.conf raw venet0:0</span><br><span class="line">Restart=always </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>5、最后执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rinetd.service &amp;&amp; systemctl start rinetd.service</span><br><span class="line"></span><br><span class="line">后面可以执行</span><br><span class="line">systemctl start rinetd.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vpn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
            <tag> rinetd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-简要读书笔记</title>
      <link href="/2019/08/17/2019-08-17-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3(%E7%AC%AC%E5%9B%9B%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/17/2019-08-17-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3(%E7%AC%AC%E5%9B%9B%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="第1章-对象导论-1"><a href="#第1章-对象导论-1" class="headerlink" title="第1章 对象导论 1"></a>第1章 对象导论 1</h3><blockquote><p>在第一章最前面作者就说明了一些话语，这些话语已经很明确的说出了这一章甚至这本书的某些特性：偏重与讲解Java这一面向对象编程语言与面对过程编程语言以及C++的区别，从Java其起源思想讲解Java语言特点以及用法，与市面上大部分教材以及视频直接讲解知识点不同，所以阅读这本书最重要的是要理解面向对象编程的思想。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717111115.png" alt=""></p><blockquote><p>在阅读第一章的时候，确实看的很费神，对于作者的思想能理解，但是自己却无法转为自己的语言，因此，这一章只列出下列目录，留待以后再补上，毕竟作者自己也说了，可跳过此章</p></blockquote><h4 id="1-1-抽象过程-1"><a href="#1-1-抽象过程-1" class="headerlink" title="1.1 抽象过程 1"></a>1.1 抽象过程 1</h4><h4 id="1-2-每个对象都有一个接口-2"><a href="#1-2-每个对象都有一个接口-2" class="headerlink" title="1.2 每个对象都有一个接口 2"></a>1.2 每个对象都有一个接口 2</h4><h4 id="1-3-每个对象都提供服务-4"><a href="#1-3-每个对象都提供服务-4" class="headerlink" title="1.3 每个对象都提供服务 4"></a>1.3 每个对象都提供服务 4</h4><h4 id="1-4-被隐藏的具体实现-4"><a href="#1-4-被隐藏的具体实现-4" class="headerlink" title="1.4 被隐藏的具体实现 4"></a>1.4 被隐藏的具体实现 4</h4><h4 id="1-5-复用具体实现-5"><a href="#1-5-复用具体实现-5" class="headerlink" title="1.5 复用具体实现 5"></a>1.5 复用具体实现 5</h4><h4 id="1-6-继承-6"><a href="#1-6-继承-6" class="headerlink" title="1.6 继承 6"></a>1.6 继承 6</h4><h5 id="1-6-1-“是一个”与“像是一个”关系-8"><a href="#1-6-1-“是一个”与“像是一个”关系-8" class="headerlink" title="1.6.1 “是一个”与“像是一个”关系 8"></a>1.6.1 “是一个”与“像是一个”关系 8</h5><h4 id="1-7-伴随多态的可互换对象-8"><a href="#1-7-伴随多态的可互换对象-8" class="headerlink" title="1.7 伴随多态的可互换对象 8"></a>1.7 伴随多态的可互换对象 8</h4><h4 id="1-8-单根继承结构-11"><a href="#1-8-单根继承结构-11" class="headerlink" title="1.8 单根继承结构 11"></a>1.8 单根继承结构 11</h4><h4 id="1-9-容器-11"><a href="#1-9-容器-11" class="headerlink" title="1.9 容器 11"></a>1.9 容器 11</h4><h5 id="1-9-1-参数化类型（范型）-12"><a href="#1-9-1-参数化类型（范型）-12" class="headerlink" title="1.9.1 参数化类型（范型） 12"></a>1.9.1 参数化类型（范型） 12</h5><h4 id="1-10-对象的创建和生命期-13"><a href="#1-10-对象的创建和生命期-13" class="headerlink" title="1.10 对象的创建和生命期 13"></a>1.10 对象的创建和生命期 13</h4><h4 id="1-11-异常处理：处理错误-14"><a href="#1-11-异常处理：处理错误-14" class="headerlink" title="1.11 异常处理：处理错误 14"></a>1.11 异常处理：处理错误 14</h4><h4 id="1-12-并发编程-14"><a href="#1-12-并发编程-14" class="headerlink" title="1.12 并发编程 14"></a>1.12 并发编程 14</h4><h4 id="1-13-Java与Internet-15"><a href="#1-13-Java与Internet-15" class="headerlink" title="1.13 Java与Internet 15"></a>1.13 Java与Internet 15</h4><h5 id="1-13-1-Web是什么-15"><a href="#1-13-1-Web是什么-15" class="headerlink" title="1.13.1 Web是什么 15"></a>1.13.1 Web是什么 15</h5><h5 id="1-13-2-客户端编程-16"><a href="#1-13-2-客户端编程-16" class="headerlink" title="1.13.2 客户端编程 16"></a>1.13.2 客户端编程 16</h5><h5 id="1-13-3-服务器端编程-19"><a href="#1-13-3-服务器端编程-19" class="headerlink" title="1.13.3 服务器端编程 19"></a>1.13.3 服务器端编程 19</h5><h4 id="1-14-总结-20"><a href="#1-14-总结-20" class="headerlink" title="1.14 总结 20"></a>1.14 总结 20</h4><hr><h3 id="第2章-一切都是对象-21"><a href="#第2章-一切都是对象-21" class="headerlink" title="第2章 一切都是对象 21"></a>第2章 一切都是对象 21</h3><blockquote><p>这一章将开始介绍Java程序的基本组成，但是，也会令你“欲仙欲死”。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717112848.png" alt=""></p><h4 id="2-1-用引用操纵对象-21"><a href="#2-1-用引用操纵对象-21" class="headerlink" title="2.1 用引用操纵对象 21"></a>2.1 用引用操纵对象 21</h4><blockquote><p>这里作者用遥控器与电视机作为讲解引用与对象的关系，很符合要义，我们一般是操控遥控器，在程序中我们也是一般操作对象的引用。这一节引出对象。</p></blockquote><h4 id="2-2-必须由你创建所有对象-22"><a href="#2-2-必须由你创建所有对象-22" class="headerlink" title="2.2 必须由你创建所有对象 22"></a>2.2 必须由你创建所有对象 22</h4><blockquote><p>这一节继承上一节，对对象需要初始化，new 关键字表名“给我一个新的对象”</p></blockquote><h5 id="2-2-1-存储到什么地方-22"><a href="#2-2-1-存储到什么地方-22" class="headerlink" title="2.2.1 存储到什么地方 22"></a>2.2.1 存储到什么地方 22</h5><ul><li>寄存器：处理器内部，速度最快，我们无法直接控制</li><li>堆栈：RAM中，速度仅次于寄存器；堆栈指针向上移动，释放那些内存；向下移动，分配新的内存；引用存于此处。</li><li>堆：RAM内，用于存放所有的Java对象。</li><li>常量存储：常量值通常直接存放在程序代码内部</li><li>非RAM存储：2个基本的例子——流对象以及持久化对象，即存活于程序之外的数据。</li></ul><h5 id="2-2-2-特例：基本类型-23"><a href="#2-2-2-特例：基本类型-23" class="headerlink" title="2.2.2 特例：基本类型 23"></a>2.2.2 特例：基本类型 23</h5><blockquote><p>基本数据类型存储于堆栈中</p></blockquote><p>类型分类：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717135734.png" alt=""></p><p>数据类型转换之默认转换顺序：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140126.png" alt=""></p><p>类型范围：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140241.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140514.png" alt=""></p><h5 id="2-2-3-Java中的数组-24"><a href="#2-2-3-Java中的数组-24" class="headerlink" title="2.2.3 Java中的数组 24"></a>2.2.3 Java中的数组 24</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140820.png" alt=""></p><h4 id="2-3-永远不需要销毁对象-24"><a href="#2-3-永远不需要销毁对象-24" class="headerlink" title="2.3 永远不需要销毁对象 24"></a>2.3 永远不需要销毁对象 24</h4><h5 id="2-3-1-作用域-24"><a href="#2-3-1-作用域-24" class="headerlink" title="2.3.1 作用域 24"></a>2.3.1 作用域 24</h5><blockquote><p>变量定义在哪个大括号内，它就在这个大括号内有效。并且，在同一个大括号内不能同时定义同名的变量。</p></blockquote><h5 id="2-3-2-对象的作用域-25"><a href="#2-3-2-对象的作用域-25" class="headerlink" title="2.3.2 对象的作用域 25"></a>2.3.2 对象的作用域 25</h5><blockquote><p>一般对象在定义的大括号内消失的是其引用，其对象本身继续占据内存空间。这就牵涉到了Java的垃圾回收机制。</p></blockquote><h4 id="2-4-创建新的数据类型：类-25"><a href="#2-4-创建新的数据类型：类-25" class="headerlink" title="2.4 创建新的数据类型：类 25"></a>2.4 创建新的数据类型：类 25</h4><blockquote><p>引出类class关键字</p></blockquote><h5 id="2-4-1-字段和方法-26"><a href="#2-4-1-字段和方法-26" class="headerlink" title="2.4.1 字段和方法 26"></a>2.4.1 字段和方法 26</h5><blockquote><p>字段–&gt;成员变量;方法–&gt;成员方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Java中的参数传递问题：</span><br><span class="line">基本类型：形式参数的改变对实际参数没有影响。</span><br><span class="line">引用类型：形式参数的改变直接影响实际参数。</span><br><span class="line">成员变量和局部变量的区别?</span><br><span class="line">A:在类中的位置不同</span><br><span class="line">成员变量：在类中方法外</span><br><span class="line">局部变量：在方法定义中或者方法声明上</span><br><span class="line">B:在内存中的位置不同</span><br><span class="line">成员变量：在堆内存</span><br><span class="line">局部变量：在栈内存</span><br><span class="line">C:生命周期不同</span><br><span class="line">成员变量：随着对象的创建而存在，随着对象的消失而消失</span><br><span class="line">局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</span><br><span class="line">D:初始化值不同</span><br><span class="line">成员变量：有默认初始化值</span><br><span class="line">局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。</span><br><span class="line">注意事项：</span><br><span class="line">局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</span><br><span class="line">如果你看到了一个方法的形式参数是一个类类型(引用类型)，</span><br><span class="line">这里其实需要的是该类的对象。</span><br></pre></td></tr></table></figure><h4 id="2-5-方法、参数和返回值-27"><a href="#2-5-方法、参数和返回值-27" class="headerlink" title="2.5 方法、参数和返回值 27"></a>2.5 方法、参数和返回值 27</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)方法：就是完成特定功能的代码块。</span><br><span class="line">注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。</span><br><span class="line">(<span class="number">2</span>)格式：</span><br><span class="line">修饰符 返回值类型 方法名(参数类型 参数名<span class="number">1</span>,参数类型 参数名<span class="number">2</span>...) &#123;</span><br><span class="line">方法体语句;</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修饰符：目前就用 <span class="keyword">public</span> <span class="keyword">static</span>。后面再详细讲解其他修饰符</span><br><span class="line">返回值类型：就是功能结果的数据类型</span><br><span class="line">方法名：就是起了一个名字，方便我们调用该方法。</span><br><span class="line">参数类型：就是参数的数据类型</span><br><span class="line">参数名：就是变量</span><br><span class="line">参数分类：</span><br><span class="line">实参：实际参与运算的数据</span><br><span class="line">形参：方法上定义的，用于接收实际参数的变量</span><br><span class="line">方法体语句：就是完成功能的代码块</span><br><span class="line"><span class="keyword">return</span>：结束方法</span><br><span class="line">返回值：就是功能的结果，由<span class="keyword">return</span>带给调用者。</span><br><span class="line">(<span class="number">3</span>)两个明确：</span><br><span class="line">返回值类型：结果的数据类型</span><br><span class="line">参数列表：参数的个数及对应的数据类型</span><br><span class="line">(<span class="number">4</span>)方法调用</span><br><span class="line">A:有明确返回值的方法</span><br><span class="line">a:单独调用，没有意义</span><br><span class="line">b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。</span><br><span class="line">c:赋值调用，推荐方案</span><br><span class="line">B:<span class="keyword">void</span>类型修饰的方法</span><br><span class="line">a:单独调用</span><br><span class="line">(<span class="number">6</span>)方法的注意事项</span><br><span class="line">A:方法不调用不执行</span><br><span class="line">B:方法之间是平级关系，不能嵌套定义</span><br><span class="line">C:方法定义的时候，参数是用<span class="string">','</span>隔开的</span><br><span class="line">D:方法在调用的时候，不用在传递数据类型</span><br><span class="line">E:如果方法有明确的返回值类型，就必须有<span class="keyword">return</span>语句返回。</span><br></pre></td></tr></table></figure><h5 id="2-5-1-参数列表-27"><a href="#2-5-1-参数列表-27" class="headerlink" title="2.5.1 参数列表 27"></a>2.5.1 参数列表 27</h5><h4 id="2-6-构建一个Java程序-28"><a href="#2-6-构建一个Java程序-28" class="headerlink" title="2.6 构建一个Java程序 28"></a>2.6 构建一个Java程序 28</h4><h5 id="2-6-1-名字可见性-28"><a href="#2-6-1-名字可见性-28" class="headerlink" title="2.6.1 名字可见性 28"></a>2.6.1 名字可见性 28</h5><blockquote><p>名字空间，包</p></blockquote><h5 id="2-6-2-运用其他构件-28"><a href="#2-6-2-运用其他构件-28" class="headerlink" title="2.6.2 运用其他构件 28"></a>2.6.2 运用其他构件 28</h5><blockquote><p>import关键字</p></blockquote><h5 id="2-6-3-static-关键字-29"><a href="#2-6-3-static-关键字-29" class="headerlink" title="2.6.3 static 关键字 29"></a>2.6.3 static 关键字 29</h5><blockquote><ul><li><p>(1)静态的意思。</p><ul><li>可以修饰成员变量和成员方法。</li><li>针对多个对象有共同的这样的成员变量值的时候,Java就提供了一个关键字来修饰：static。</li></ul></li><li><p>(2)静态的特点：</p><ul><li>A:随着类的加载而加载</li><li>B:优先与对象存在</li><li>C:被类的所有对象共享<br>这其实也是我们判断该不该使用静态的依据。<ul><li>举例：饮水机和水杯的问题思考</li></ul></li><li>D:可以通过类名调用<br>既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。</li></ul></li><li><p>(3)静态的内存图</p><ul><li>静态的内容在方法区的静态区</li></ul></li><li><p>(4)静态的注意事项；</p><ul><li>A:在静态方法中没有this对象</li><li>B:静态只能访问静态</li></ul></li><li><p>(5)静态变量和成员变量的区别</p><ul><li>A:所属不同<ul><li>静态变量：属于类，类变量</li><li>成员变量：属于对象，对象变量，实例变量</li></ul></li><li>B:内存位置不同<ul><li>静态变量：方法区的静态区</li><li>成员变量：堆内存</li></ul></li><li>C:生命周期不同<ul><li>静态变量：静态变量是随着类的加载而加载，随着类的消失而消失</li><li>成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失</li></ul></li><li>D:调用不同<ul><li>静态变量：可以通过对象名调用，也可以通过类名调用</li><li>成员变量：只能通过对象名调用</li></ul></li></ul></li><li><p>(6)main方法是静态的</p><ul><li><p>public:权限最大</p></li><li><p>static:不用创建对象调用</p></li><li><p>void:返回值给jvm没有意义</p></li><li><p>main:就是一个常见的名称。</p></li><li><p>String[] args:可以接收数据，提供程序的灵活性</p></li><li><p>main方法的格式讲解：</p><ul><li><p>public static void main(String[] args) {…}</p></li><li><p>public:公共的，访问权限是最大的。由于main方法是被jvm调用，所以权限要够大。</p></li><li><p>static:静态的，不需要创建对象，通过类名就可以。方便jvm的调用。</p></li><li><p>void:因为我们曾经说过，方法的返回值是返回给调用者，而main方法是被jvm调用。你返回内容给jvm没有意义。</p></li><li><p>main:是一个常见的方法入口。我见过的语言都是以main作为入口。</p></li><li><p>String[] args:这是一个字符串数组。值去哪里了?<br>这个东西到底有什么用啊?怎么给值啊?</p><p> 这个东西早期是为了接收键盘录入的数据的。<br> 格式是：</p><pre><code>java MainDemo hello world java</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MainDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;System.out.println(args); &#x2F;&#x2F;[Ljava.lang.String;@175078b</span><br><span class="line">&#x2F;&#x2F;System.out.println(args.length); &#x2F;&#x2F;0</span><br><span class="line">&#x2F;&#x2F;System.out.println(args[0]); &#x2F;&#x2F;ArrayIndexOutOfBoundsException</span><br><span class="line">&#x2F;&#x2F;接收数据后</span><br><span class="line">System.out.println(args); </span><br><span class="line">System.out.println(args.length); </span><br><span class="line">&#x2F;&#x2F;System.out.println(args[0]); </span><br><span class="line">for(int x&#x3D;0; x&lt;args.length; x++) &#123;</span><br><span class="line">System.out.println(args[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>A:在静态方法中是没有this关键字的</p><ul><li>如何理解呢?<ul><li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li><li>静态比对象先存在。</li></ul></li></ul></li><li><p>B:静态方法只能访问静态的成员变量和静态的成员方法</p><ul><li>静态方法：<ul><li>成员变量：只能访问静态变量</li><li>成员方法：只能访问静态成员方法</li></ul></li><li>非静态方法：<ul><li>成员变量：可以是静态的，也可以是非静态的</li><li>成员方法：可是是静态的成员方法，也可以是非静态的成员方法。</li></ul></li><li>简单记：<ul><li>静态只能访问静态。</li></ul></li></ul></li></ul></li></ul></blockquote><h4 id="2-7-你的第一个Java程序-30"><a href="#2-7-你的第一个Java程序-30" class="headerlink" title="2.7 你的第一个Java程序 30"></a>2.7 你的第一个Java程序 30</h4><h5 id="2-7-1-编译和运行-31"><a href="#2-7-1-编译和运行-31" class="headerlink" title="2.7.1 编译和运行 31"></a>2.7.1 编译和运行 31</h5><h4 id="2-8-注释和嵌入式文档-32"><a href="#2-8-注释和嵌入式文档-32" class="headerlink" title="2.8 注释和嵌入式文档 32"></a>2.8 注释和嵌入式文档 32</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 多行注释</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure><h5 id="2-8-1-注释文档-32"><a href="#2-8-1-注释文档-32" class="headerlink" title="2.8.1 注释文档 32"></a>2.8.1 注释文档 32</h5><blockquote><p>javadoc</p></blockquote><h5 id="2-8-2-语法-33"><a href="#2-8-2-语法-33" class="headerlink" title="2.8.2 语法 33"></a>2.8.2 语法 33</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @注释文档</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><blockquote><p>javadoc只能为public 和 protected 成员进行文档注释</p></blockquote><h5 id="2-8-3-嵌入式HTML-33"><a href="#2-8-3-嵌入式HTML-33" class="headerlink" title="2.8.3 嵌入式HTML 33"></a>2.8.3 嵌入式HTML 33</h5><blockquote><p>支持html标记</p></blockquote><h5 id="2-8-4-一些标签示例-34"><a href="#2-8-4-一些标签示例-34" class="headerlink" title="2.8.4 一些标签示例 34"></a>2.8.4 一些标签示例 34</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @see: classname 引用其他类</span></span><br><span class="line"><span class="comment"> * @link: package.class#member label 用于行内，类似see</span></span><br><span class="line"><span class="comment"> * @docRoot: 产生到文档根目录的相对路径</span></span><br><span class="line"><span class="comment"> * @inheritDoc: 从当前类的最直接基类中继承相关文档到当前注释中</span></span><br><span class="line"><span class="comment"> * @version: version-information </span></span><br><span class="line"><span class="comment"> * @since: 指定代码版本，一般是jdk版本</span></span><br><span class="line"><span class="comment"> * @param: 参数</span></span><br><span class="line"><span class="comment"> * @return: 返回值</span></span><br><span class="line"><span class="comment"> * @throws: 异常</span></span><br><span class="line"><span class="comment"> * @Deprecated: 表名已不适用</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="2-8-5-文档示例-35"><a href="#2-8-5-文档示例-35" class="headerlink" title="2.8.5 文档示例 35"></a>2.8.5 文档示例 35</h5><h4 id="2-9-编码风格-36"><a href="#2-9-编码风格-36" class="headerlink" title="2.9 编码风格 36"></a>2.9 编码风格 36</h4><blockquote><p>类首字母大写；驼峰命名法</p></blockquote><h4 id="2-10-总结-36"><a href="#2-10-总结-36" class="headerlink" title="2.10 总结 36"></a>2.10 总结 36</h4><h4 id="2-11-练习-37"><a href="#2-11-练习-37" class="headerlink" title="2.11 练习 37"></a>2.11 练习 37</h4><hr><blockquote></blockquote><h3 id="第3章-操作符-38"><a href="#第3章-操作符-38" class="headerlink" title="第3章 操作符 38"></a>第3章 操作符 38</h3><blockquote><p>正如作者所说，第三、第四章可快速浏览</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717151223.png" alt=""></p><h4 id="3-1-更简单的打印语句-38"><a href="#3-1-更简单的打印语句-38" class="headerlink" title="3.1 更简单的打印语句 38"></a>3.1 更简单的打印语句 38</h4><h4 id="3-2-使用Java操作符-39"><a href="#3-2-使用Java操作符-39" class="headerlink" title="3.2 使用Java操作符 39"></a>3.2 使用Java操作符 39</h4><h4 id="3-3-优先级-39"><a href="#3-3-优先级-39" class="headerlink" title="3.3 优先级 39"></a>3.3 优先级 39</h4><h4 id="3-4-赋值-39"><a href="#3-4-赋值-39" class="headerlink" title="3.4 赋值 39"></a>3.4 赋值 39</h4><h5 id="3-4-1-方法调用中的别名问题-40"><a href="#3-4-1-方法调用中的别名问题-40" class="headerlink" title="3.4.1 方法调用中的别名问题 40"></a>3.4.1 方法调用中的别名问题 40</h5><h4 id="3-5-算术操作符-41"><a href="#3-5-算术操作符-41" class="headerlink" title="3.5 算术操作符 41"></a>3.5 算术操作符 41</h4><h5 id="3-5-1-一元加、减操作符-43"><a href="#3-5-1-一元加、减操作符-43" class="headerlink" title="3.5.1 一元加、减操作符 43"></a>3.5.1 一元加、减操作符 43</h5><h4 id="3-6-自动递增和递减-43"><a href="#3-6-自动递增和递减-43" class="headerlink" title="3.6 自动递增和递减 43"></a>3.6 自动递增和递减 43</h4><h4 id="3-7-关系操作符-44"><a href="#3-7-关系操作符-44" class="headerlink" title="3.7 关系操作符 44"></a>3.7 关系操作符 44</h4><h5 id="3-7-1-测试对象的等价性-44"><a href="#3-7-1-测试对象的等价性-44" class="headerlink" title="3.7.1 测试对象的等价性 44"></a>3.7.1 测试对象的等价性 44</h5><h4 id="3-8-逻辑操作符-45"><a href="#3-8-逻辑操作符-45" class="headerlink" title="3.8 逻辑操作符 45"></a>3.8 逻辑操作符 45</h4><h5 id="3-8-1-短路-46"><a href="#3-8-1-短路-46" class="headerlink" title="3.8.1 短路 46"></a>3.8.1 短路 46</h5><h4 id="3-9-直接常量-47"><a href="#3-9-直接常量-47" class="headerlink" title="3.9 直接常量 47"></a>3.9 直接常量 47</h4><h5 id="3-9-1-指数记数法-48"><a href="#3-9-1-指数记数法-48" class="headerlink" title="3.9.1 指数记数法 48"></a>3.9.1 指数记数法 48</h5><h4 id="3-10-按位操作符-49"><a href="#3-10-按位操作符-49" class="headerlink" title="3.10 按位操作符 49"></a>3.10 按位操作符 49</h4><h4 id="3-11-移位操作符-49"><a href="#3-11-移位操作符-49" class="headerlink" title="3.11 移位操作符 49"></a>3.11 移位操作符 49</h4><blockquote><p>只能用于整型整数</p><p>Integer.toBinaryString() : 转为二进制字符串</p></blockquote><h4 id="3-12-三元操作符-if-else-52"><a href="#3-12-三元操作符-if-else-52" class="headerlink" title="3.12 三元操作符 if-else 52"></a>3.12 三元操作符 if-else 52</h4><h4 id="3-13-字符串操作符-和-53"><a href="#3-13-字符串操作符-和-53" class="headerlink" title="3.13 字符串操作符 + 和 += 53"></a>3.13 字符串操作符 + 和 += 53</h4><h4 id="3-14-使用操作符时常犯的错误-54"><a href="#3-14-使用操作符时常犯的错误-54" class="headerlink" title="3.14 使用操作符时常犯的错误 54"></a>3.14 使用操作符时常犯的错误 54</h4><h4 id="3-15-类型转换操作符-54"><a href="#3-15-类型转换操作符-54" class="headerlink" title="3.15 类型转换操作符 54"></a>3.15 类型转换操作符 54</h4><h5 id="3-15-1-截尾和舍入-55"><a href="#3-15-1-截尾和舍入-55" class="headerlink" title="3.15.1 截尾和舍入 55"></a>3.15.1 截尾和舍入 55</h5><h5 id="3-15-2-提升-56"><a href="#3-15-2-提升-56" class="headerlink" title="3.15.2 提升 56"></a>3.15.2 提升 56</h5><h4 id="3-16-Java没有sizeof-56"><a href="#3-16-Java没有sizeof-56" class="headerlink" title="3.16 Java没有sizeof 56"></a>3.16 Java没有sizeof 56</h4><h4 id="3-17-操作符小结-56"><a href="#3-17-操作符小结-56" class="headerlink" title="3.17 操作符小结 56"></a>3.17 操作符小结 56</h4><h4 id="3-18-总结-63"><a href="#3-18-总结-63" class="headerlink" title="3.18 总结 63"></a>3.18 总结 63</h4><hr><blockquote></blockquote><h3 id="第4章-控制执行流程-64"><a href="#第4章-控制执行流程-64" class="headerlink" title="第4章 控制执行流程 64"></a>第4章 控制执行流程 64</h3><blockquote><p>快速阅读此章</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717152841.png" alt=""></p><h4 id="4-1-true和false-64"><a href="#4-1-true和false-64" class="headerlink" title="4.1 true和false 64"></a>4.1 true和false 64</h4><h4 id="4-2-if-else-64"><a href="#4-2-if-else-64" class="headerlink" title="4.2 if-else 64"></a>4.2 if-else 64</h4><h4 id="4-3-迭代-65"><a href="#4-3-迭代-65" class="headerlink" title="4.3 迭代 65"></a>4.3 迭代 65</h4><h5 id="4-3-1-do-while-65"><a href="#4-3-1-do-while-65" class="headerlink" title="4.3.1 do-while 65"></a>4.3.1 do-while 65</h5><h5 id="4-3-2-for-66"><a href="#4-3-2-for-66" class="headerlink" title="4.3.2 for 66"></a>4.3.2 for 66</h5><h5 id="4-3-3-逗号操作符-67"><a href="#4-3-3-逗号操作符-67" class="headerlink" title="4.3.3 逗号操作符 67"></a>4.3.3 逗号操作符 67</h5><h4 id="4-4-Foreach语法-67"><a href="#4-4-Foreach语法-67" class="headerlink" title="4.4 Foreach语法 67"></a>4.4 Foreach语法 67</h4><h4 id="4-5-return-69"><a href="#4-5-return-69" class="headerlink" title="4.5 return 69"></a>4.5 return 69</h4><h4 id="4-6-break和-continue-69"><a href="#4-6-break和-continue-69" class="headerlink" title="4.6 break和 continue 69"></a>4.6 break和 continue 69</h4><h4 id="4-7-臭名昭著的goto-70"><a href="#4-7-臭名昭著的goto-70" class="headerlink" title="4.7 臭名昭著的goto 70"></a>4.7 臭名昭著的goto 70</h4><blockquote><p>java没有goto，但是有标签</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717153141.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717153327.png" alt=""></p><h4 id="4-8-switch-73"><a href="#4-8-switch-73" class="headerlink" title="4.8 switch 73"></a>4.8 switch 73</h4><h4 id="4-9-总结-75"><a href="#4-9-总结-75" class="headerlink" title="4.9 总结 75"></a>4.9 总结 75</h4><hr><blockquote></blockquote><h3 id="第5章-初始化与清理-76"><a href="#第5章-初始化与清理-76" class="headerlink" title="第5章 初始化与清理 76"></a>第5章 初始化与清理 76</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717153426.png" alt=""></p><h4 id="5-1-用构造器确保初始化-76"><a href="#5-1-用构造器确保初始化-76" class="headerlink" title="5.1 用构造器确保初始化 76"></a>5.1 用构造器确保初始化 76</h4><p>构造方法</p><ul><li>作用概述<ul><li>给对象的数据进行初始化</li></ul></li><li>构造方法格式<ul><li>方法名与类名相同</li><li>没有返回值类型，连void都没有</li><li>没有具体的返回值</li></ul></li><li>构造方法注意事项<ul><li>如果你不提供构造方法，系统会给出默认构造方法</li><li>如果你提供了构造方法，系统将不再提供</li><li>构造方法也是可以重载的</li></ul></li><li>思考题：构造方法中可不可以有return语句呢?<ul><li>可以。而是我们写成这个样子就OK了：return;</li><li>其实，在任何的void类型的方法的最后你都可以写上：return;</li></ul></li></ul><h4 id="5-2-方法重载-77"><a href="#5-2-方法重载-77" class="headerlink" title="5.2 方法重载 77"></a>5.2 方法重载 77</h4><blockquote><p>方法重载:<br>    在同一个类中，方法名相同，参数列表不同。与返回值无关。（同类同名不同参）<br>    参数列表不同：<br>        参数的个数不同。<br>        参数的对应的数据类型不同。<br>方法重载案例<br>    不同的类型的多个同名方法的比较。</p></blockquote><h5 id="5-2-1-区分重载方法-79"><a href="#5-2-1-区分重载方法-79" class="headerlink" title="5.2.1 区分重载方法 79"></a>5.2.1 区分重载方法 79</h5><h5 id="5-2-2-涉及基本类型的重载-79"><a href="#5-2-2-涉及基本类型的重载-79" class="headerlink" title="5.2.2 涉及基本类型的重载 79"></a>5.2.2 涉及基本类型的重载 79</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717154616.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717154656.png" alt=""></p><h5 id="5-2-3-以返回值区分重载方法-82"><a href="#5-2-3-以返回值区分重载方法-82" class="headerlink" title="5.2.3 以返回值区分重载方法 82"></a>5.2.3 以返回值区分重载方法 82</h5><blockquote><p>这是行不通的</p></blockquote><h4 id="5-3-默认构造器-83"><a href="#5-3-默认构造器-83" class="headerlink" title="5.3 默认构造器 83"></a>5.3 默认构造器 83</h4><h4 id="5-4-this关键字-84"><a href="#5-4-this关键字-84" class="headerlink" title="5.4 this关键字 84"></a>5.4 this关键字 84</h4><blockquote><p>this : 是当前类的对象引用。简单的记，它就代表当前类的一个对象。</p><ul><li>注意：谁调用这个方法，在该方法内部的this就代表谁。</li><li>this:哪个对象调用那个方法，this就代表那个对象</li><li>this的场景：<br>解决局部变量隐藏成员变量</li></ul></blockquote><h5 id="5-4-1-在构造器中调用构造器-85"><a href="#5-4-1-在构造器中调用构造器-85" class="headerlink" title="5.4.1 在构造器中调用构造器 85"></a>5.4.1 在构造器中调用构造器 85</h5><h5 id="5-4-2-static的含义-86"><a href="#5-4-2-static的含义-86" class="headerlink" title="5.4.2 static的含义 86"></a>5.4.2 static的含义 86</h5><h4 id="5-5-清理：终结处理和垃圾回收-87"><a href="#5-5-清理：终结处理和垃圾回收-87" class="headerlink" title="5.5 清理：终结处理和垃圾回收 87"></a>5.5 清理：终结处理和垃圾回收 87</h4><h5 id="5-5-1-finalize-的用途何在-87"><a href="#5-5-1-finalize-的用途何在-87" class="headerlink" title="5.5.1 finalize()的用途何在 87"></a>5.5.1 finalize()的用途何在 87</h5><h5 id="5-5-2-你必须实施清理-88"><a href="#5-5-2-你必须实施清理-88" class="headerlink" title="5.5.2 你必须实施清理 88"></a>5.5.2 你必须实施清理 88</h5><h5 id="5-5-3-终结条件-88"><a href="#5-5-3-终结条件-88" class="headerlink" title="5.5.3 终结条件 88"></a>5.5.3 终结条件 88</h5><h5 id="5-5-4-垃圾回收器如何工作-89"><a href="#5-5-4-垃圾回收器如何工作-89" class="headerlink" title="5.5.4 垃圾回收器如何工作 89"></a>5.5.4 垃圾回收器如何工作 89</h5><h4 id="5-6-成员初始化-91"><a href="#5-6-成员初始化-91" class="headerlink" title="5.6 成员初始化 91"></a>5.6 成员初始化 91</h4><h5 id="5-6-1-指定初始化-93"><a href="#5-6-1-指定初始化-93" class="headerlink" title="5.6.1 指定初始化 93"></a>5.6.1 指定初始化 93</h5><h4 id="5-7-构造器初始化-94"><a href="#5-7-构造器初始化-94" class="headerlink" title="5.7 构造器初始化 94"></a>5.7 构造器初始化 94</h4><h5 id="5-7-1-初始化顺序-94"><a href="#5-7-1-初始化顺序-94" class="headerlink" title="5.7.1 初始化顺序 94"></a>5.7.1 初始化顺序 94</h5><h5 id="5-7-2-静态数据的初始化-95"><a href="#5-7-2-静态数据的初始化-95" class="headerlink" title="5.7.2 静态数据的初始化 95"></a>5.7.2 静态数据的初始化 95</h5><h5 id="5-7-3-显式的静态初始化-96"><a href="#5-7-3-显式的静态初始化-96" class="headerlink" title="5.7.3 显式的静态初始化 96"></a>5.7.3 显式的静态初始化 96</h5><h5 id="5-7-4-非静态实例初始化-97"><a href="#5-7-4-非静态实例初始化-97" class="headerlink" title="5.7.4 非静态实例初始化 97"></a>5.7.4 非静态实例初始化 97</h5><h4 id="5-8-数组初始化-98"><a href="#5-8-数组初始化-98" class="headerlink" title="5.8 数组初始化 98"></a>5.8 数组初始化 98</h4><h5 id="5-8-1-可变参数列表-102"><a href="#5-8-1-可变参数列表-102" class="headerlink" title="5.8.1 可变参数列表 102"></a>5.8.1 可变参数列表 102</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(Object... args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//args说明可变参数，0至多个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-9-枚举类型-105"><a href="#5-9-枚举类型-105" class="headerlink" title="5.9 枚举类型 105"></a>5.9 枚举类型 105</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717162907.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717162939.png" alt=""></p><h4 id="5-10-总结-107"><a href="#5-10-总结-107" class="headerlink" title="5.10 总结 107"></a>5.10 总结 107</h4><hr><blockquote></blockquote><h3 id="第6章-访问权限控制-109"><a href="#第6章-访问权限控制-109" class="headerlink" title="第6章 访问权限控制 109"></a>第6章 访问权限控制 109</h3><h4 id="6-1-包：库单元-110"><a href="#6-1-包：库单元-110" class="headerlink" title="6.1 包：库单元 110"></a>6.1 包：库单元 110</h4><h5 id="6-1-1-代码组织-110"><a href="#6-1-1-代码组织-110" class="headerlink" title="6.1.1 代码组织 110"></a>6.1.1 代码组织 110</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">包(理解)</span><br><span class="line">(<span class="number">1</span>)其实就是文件夹</span><br><span class="line">(<span class="number">2</span>)作用：</span><br><span class="line">A:区分同名的类</span><br><span class="line">B:对类进行分类管理</span><br><span class="line">a:按照功能分</span><br><span class="line">b:按照模块分</span><br><span class="line">(<span class="number">3</span>)包的定义(掌握)</span><br><span class="line"><span class="keyword">package</span> 包名;</span><br><span class="line">多级包用.分开。</span><br><span class="line">(<span class="number">4</span>)注意事项：(掌握)</span><br><span class="line">A:<span class="keyword">package</span>语句必须在文件中的第一条有效语句</span><br><span class="line">B:在一个java文件中，只能有一个<span class="keyword">package</span></span><br><span class="line">C:如果没有<span class="keyword">package</span>，默认就是无包名</span><br><span class="line">(<span class="number">5</span>)带包的编译和运行</span><br><span class="line">A:手动式</span><br><span class="line">B:自动式(掌握)</span><br><span class="line">javac -d . HelloWorld.java</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:导包(掌握)</span><br><span class="line">(<span class="number">1</span>)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字<span class="keyword">import</span>。</span><br><span class="line">(<span class="number">2</span>)格式：</span><br><span class="line"><span class="keyword">import</span> 包名...类名;</span><br><span class="line">另一种：</span><br><span class="line"><span class="keyword">import</span> 包名...*;(不建议)</span><br><span class="line">(<span class="number">3</span>)<span class="keyword">package</span>,<span class="keyword">import</span>,<span class="class"><span class="keyword">class</span>的顺序</span></span><br><span class="line"><span class="class"><span class="title">package</span> &gt; <span class="title">import</span> &gt; <span class="title">class</span></span></span><br></pre></td></tr></table></figure><h5 id="6-1-2-创建独一无二的包名-111"><a href="#6-1-2-创建独一无二的包名-111" class="headerlink" title="6.1.2 创建独一无二的包名 111"></a>6.1.2 创建独一无二的包名 111</h5><h5 id="6-1-3-定制工具库-114"><a href="#6-1-3-定制工具库-114" class="headerlink" title="6.1.3 定制工具库 114"></a>6.1.3 定制工具库 114</h5><h5 id="6-1-4-用-import改变行为-115"><a href="#6-1-4-用-import改变行为-115" class="headerlink" title="6.1.4 用 import改变行为 115"></a>6.1.4 用 import改变行为 115</h5><h5 id="6-1-5-对使用包的忠告-115"><a href="#6-1-5-对使用包的忠告-115" class="headerlink" title="6.1.5 对使用包的忠告 115"></a>6.1.5 对使用包的忠告 115</h5><h4 id="6-2-Java访问权限修饰词-116"><a href="#6-2-Java访问权限修饰词-116" class="headerlink" title="6.2 Java访问权限修饰词 116"></a>6.2 Java访问权限修饰词 116</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)权限修饰符</span><br><span class="line">本类同一个包下不同包下的子类不同包下的无关类</span><br><span class="line"><span class="keyword">private</span>Y</span><br><span class="line">默认   Y  Y</span><br><span class="line"><span class="keyword">protected</span>YYY</span><br><span class="line"><span class="keyword">public</span>YYYY</span><br><span class="line">(<span class="number">2</span>)这四种权限修饰符在任意时刻只能出现一种。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;&#125;</span><br><span class="line">常见的修饰符</span><br><span class="line">(<span class="number">1</span>)分类：</span><br><span class="line">权限修饰符：<span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span></span><br><span class="line">状态修饰符：<span class="keyword">static</span>,<span class="keyword">final</span></span><br><span class="line">抽象修饰符：<span class="keyword">abstract</span></span><br><span class="line">(<span class="number">2</span>)常见的类及其组成的修饰</span><br><span class="line">类：</span><br><span class="line">默认,<span class="keyword">public</span>,<span class="keyword">final</span>,<span class="keyword">abstract</span></span><br><span class="line">常用的：<span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">成员变量：</span><br><span class="line"><span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span>,<span class="keyword">static</span>,<span class="keyword">final</span></span><br><span class="line">常用的：<span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">构造方法：</span><br><span class="line"><span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span></span><br><span class="line">常用的：<span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">成员方法：</span><br><span class="line"><span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span>,<span class="keyword">static</span>,<span class="keyword">final</span>,<span class="keyword">abstract</span></span><br><span class="line">常用的：<span class="keyword">public</span></span><br><span class="line">(<span class="number">3</span>)另外比较常见的：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> X = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="6-2-1-包访问权限-116"><a href="#6-2-1-包访问权限-116" class="headerlink" title="6.2.1 包访问权限 116"></a>6.2.1 包访问权限 116</h5><h5 id="6-2-2-public-接口访问权限-116"><a href="#6-2-2-public-接口访问权限-116" class="headerlink" title="6.2.2 public:接口访问权限 116"></a>6.2.2 public:接口访问权限 116</h5><h5 id="6-2-3-private-你无法访问-118"><a href="#6-2-3-private-你无法访问-118" class="headerlink" title="6.2.3 private: 你无法访问 118"></a>6.2.3 private: 你无法访问 118</h5><h5 id="6-2-4-protected：继承访问权限-118"><a href="#6-2-4-protected：继承访问权限-118" class="headerlink" title="6.2.4 protected：继承访问权限 118"></a>6.2.4 protected：继承访问权限 118</h5><h4 id="6-3-接口和实现-120"><a href="#6-3-接口和实现-120" class="headerlink" title="6.3 接口和实现 120"></a>6.3 接口和实现 120</h4><h4 id="6-4-类的访问权限-121"><a href="#6-4-类的访问权限-121" class="headerlink" title="6.4 类的访问权限 121"></a>6.4 类的访问权限 121</h4><h4 id="6-5-总结-123"><a href="#6-5-总结-123" class="headerlink" title="6.5 总结 123"></a>6.5 总结 123</h4><hr><blockquote></blockquote><h3 id="第7章-复用类-125"><a href="#第7章-复用类-125" class="headerlink" title="第7章 复用类 125"></a>第7章 复用类 125</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717164314.png" alt=""></p><h4 id="7-1-组合语法-125"><a href="#7-1-组合语法-125" class="headerlink" title="7.1 组合语法 125"></a>7.1 组合语法 125</h4><h4 id="7-2-继承语法-127"><a href="#7-2-继承语法-127" class="headerlink" title="7.2 继承语法 127"></a>7.2 继承语法 127</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，</span><br><span class="line">   这多个类就具备了这些内容。这个关系叫继承。</span><br><span class="line">   单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。</span><br><span class="line">(<span class="number">2</span>)Java中如何表示继承呢?格式是什么呢?</span><br><span class="line">A:用关键字extends表示</span><br><span class="line">B:格式：</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名 </span>&#123;&#125;</span><br><span class="line">(<span class="number">3</span>)继承的好处：</span><br><span class="line">A.提高了代码的复用性</span><br><span class="line">     多个类相同的成员可以放到同一个类中</span><br><span class="line">B.提高了代码的维护性</span><br><span class="line">     如果功能的代码需要修改，修改一处即可</span><br><span class="line">C.让类与类之间产生了关系，是多态的前提</span><br><span class="line">     其实这也是继承的一个弊端：类的耦合性很强</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)继承的弊端：</span><br><span class="line">A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。</span><br><span class="line">原则：低耦合，高内聚。</span><br><span class="line">耦合：类与类的关系</span><br><span class="line">内聚：自己完成某件事情的能力</span><br><span class="line">B:打破了封装性</span><br><span class="line">(<span class="number">5</span>)Java中继承的特点</span><br><span class="line">A:Java中类只支持单继承</span><br><span class="line">一个类只能有一个父类，不可以有多个父类。</span><br><span class="line">B:Java中可以多层(重)继承(继承体系)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line">(<span class="number">6</span>)继承的注意事项：</span><br><span class="line">A:子类不能继承父类的私有成员</span><br><span class="line">B:子类不能继承父类的构造方法，但是可以通过<span class="keyword">super</span>去访问</span><br><span class="line">C:不要为了部分功能而去继承</span><br><span class="line">(<span class="number">7</span>)什么时候使用继承呢?</span><br><span class="line">A:继承体现的是：is a的关系。</span><br><span class="line">B:采用假设法</span><br><span class="line">(<span class="number">8</span>)Java继承中的成员关系</span><br><span class="line">A:成员变量</span><br><span class="line">a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单</span><br><span class="line">b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?</span><br><span class="line">子类的方法访问变量的查找顺序：</span><br><span class="line">在子类方法的局部范围找，有就使用。</span><br><span class="line">在子类的成员范围找，有就使用。</span><br><span class="line">在父类的成员范围找，有就使用。</span><br><span class="line">找不到，就报错。</span><br><span class="line">B:构造方法</span><br><span class="line">a:子类的构造方法默认会去访问父类的无参构造方法</span><br><span class="line">是为了子类访问父类数据的初始化</span><br><span class="line">注意：子类每一个构造方法的第一条语句默认都是：<span class="keyword">super</span>();</span><br><span class="line">b:父类中如果没有无参构造方法，怎么办?</span><br><span class="line">子类通过<span class="keyword">super</span>去明确调用带参构造</span><br><span class="line">子类通过<span class="keyword">this</span>调用本身的其他构造，但是一定会有一个去访问了父类的构造</span><br><span class="line">让父类提供无参构造</span><br><span class="line">C:成员方法</span><br><span class="line">a:子类的成员方法和父类中的成员方法名称不一样，这个太简单</span><br><span class="line">b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?</span><br><span class="line">通过子类对象访问一个方法的查找顺序：</span><br><span class="line">在子类中找，有就使用</span><br><span class="line">在父类中找，有就使用</span><br><span class="line">找不到，就报错</span><br><span class="line">(<span class="number">9</span>)两个面试题：</span><br><span class="line">A:Override和Overload的区别?Overload是否可以改变返回值类型?</span><br><span class="line">方法重写：</span><br><span class="line">在子类中，出现和父类中一模一样的方法声明的现象。</span><br><span class="line">方法重载：</span><br><span class="line">同一个类中，出现的方法名相同，参数列表不同的现象。（同类同名不同参）</span><br><span class="line">方法重载能改变返回值类型，因为它和返回值类型无关。</span><br><span class="line"></span><br><span class="line">方法重载：同名同类不同参</span><br><span class="line">同名：方法名相同</span><br><span class="line">同类：同一作用域</span><br><span class="line">不同参（参数列表）：个数、类型、顺序</span><br><span class="line">构造方法的重载</span><br><span class="line">方法重写（覆盖）：</span><br><span class="line">前提条件：必须有继承</span><br><span class="line">必要条件：子类方法和父类中的方法同原型（方法名、</span><br><span class="line">返回值类型、形参列表完全相同)</span><br><span class="line">注意：<span class="number">1</span>、子类方法的访问权限不得低于父类方法的访问权限</span><br><span class="line"> <span class="number">2</span>、子类中抛出的异常不得多于父类方法抛出的异常</span><br><span class="line"> </span><br><span class="line">返回值类型方法名形参列表</span><br><span class="line">方法重写：必须相同相同相同</span><br><span class="line">方法重载：无关相同必须不同</span><br><span class="line"></span><br><span class="line">B:<span class="keyword">this</span>关键字和<span class="keyword">super</span>关键字分别代表什么?以及他们各自的使用场景和作用。</span><br><span class="line"><span class="keyword">this</span>:代表当前类的对象引用</span><br><span class="line"><span class="keyword">super</span>:代表父类存储空间的标识。(可以理解为父类的引用，通过这个东西可以访问父类的成员)</span><br><span class="line">场景和作用：</span><br><span class="line">A:调用成员变量</span><br><span class="line"><span class="keyword">this</span>.成员变量 调用本类的成员变量</span><br><span class="line"><span class="keyword">super</span>.成员变量 调用父类的成员变量</span><br><span class="line">B:调用构造方法</span><br><span class="line"><span class="keyword">this</span>(...)调用本类的构造方法</span><br><span class="line"><span class="keyword">super</span>(...)调用父类的构造方法</span><br><span class="line">注意事项：</span><br><span class="line"><span class="keyword">this</span>(...)或者<span class="keyword">super</span>(...)必须出现在第一条语句上。</span><br><span class="line">如果不是放在第一条语句上，就可能对父类的数据进行了多次初始化，</span><br><span class="line">所以必须放在第一条语句上。</span><br><span class="line">C:调用成员方法</span><br><span class="line"><span class="keyword">this</span>.成员方法 调用本类的成员方法</span><br><span class="line"><span class="keyword">super</span>.成员方法 调用父类的成员方法</span><br><span class="line">(<span class="number">10</span>)数据初始化的面试题</span><br><span class="line">A:一个类的初始化过程</span><br><span class="line">      成员变量进行初始化</span><br><span class="line">     默认初始化</span><br><span class="line">     显示初始化</span><br><span class="line">     构造方法初始化</span><br><span class="line">B:子父类的构造执行过程</span><br><span class="line">    先进行父类初始化，然后进行子类初始化。</span><br><span class="line">C:分层初始化</span><br><span class="line">(<span class="number">11</span>)方法重写：子类中出现了和父类中方法声明一模一样的方法。</span><br><span class="line">方法重写的注意事项:</span><br><span class="line">A:父类中私有方法不能被重写</span><br><span class="line">因为父类私有方法子类根本就无法继承</span><br><span class="line">B:子类重写父类方法时，访问权限不能更低</span><br><span class="line">最好就一致</span><br><span class="line">C:父类静态方法，子类也必须通过静态方法进行重写</span><br><span class="line">其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解</span><br><span class="line">D:子类重写父类方法的时候，最好声明一模一样</span><br><span class="line">方法重写的应用：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。</span><br><span class="line">这样，即沿袭了父类的功能，又定义了子类特有的内容。</span><br><span class="line"></span><br><span class="line">方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值无关。</span><br></pre></td></tr></table></figure><h5 id="7-2-1-初始化基类-129"><a href="#7-2-1-初始化基类-129" class="headerlink" title="7.2.1 初始化基类 129"></a>7.2.1 初始化基类 129</h5><h4 id="7-3-代理-130"><a href="#7-3-代理-130" class="headerlink" title="7.3 代理 130"></a>7.3 代理 130</h4><h4 id="7-4-结合使用组合和继承-132"><a href="#7-4-结合使用组合和继承-132" class="headerlink" title="7.4 结合使用组合和继承 132"></a>7.4 结合使用组合和继承 132</h4><h5 id="7-4-1-确保正确清理-133"><a href="#7-4-1-确保正确清理-133" class="headerlink" title="7.4.1 确保正确清理 133"></a>7.4.1 确保正确清理 133</h5><h5 id="7-4-2-名称屏蔽-135"><a href="#7-4-2-名称屏蔽-135" class="headerlink" title="7.4.2 名称屏蔽 135"></a>7.4.2 名称屏蔽 135</h5><h4 id="7-5-在组合与继承之间选择-137"><a href="#7-5-在组合与继承之间选择-137" class="headerlink" title="7.5 在组合与继承之间选择 137"></a>7.5 在组合与继承之间选择 137</h4><h4 id="7-6-protected关键字-138"><a href="#7-6-protected关键字-138" class="headerlink" title="7.6 protected关键字 138"></a>7.6 protected关键字 138</h4><h4 id="7-7-向上转型-139"><a href="#7-7-向上转型-139" class="headerlink" title="7.7 向上转型 139"></a>7.7 向上转型 139</h4><h5 id="7-7-1-为什么称为向上转型-139"><a href="#7-7-1-为什么称为向上转型-139" class="headerlink" title="7.7.1 为什么称为向上转型 139"></a>7.7.1 为什么称为向上转型 139</h5><h5 id="7-7-2-再论组合与继承-140"><a href="#7-7-2-再论组合与继承-140" class="headerlink" title="7.7.2 再论组合与继承 140"></a>7.7.2 再论组合与继承 140</h5><h4 id="7-8-final关键字-140"><a href="#7-8-final关键字-140" class="headerlink" title="7.8 final关键字 140"></a>7.8 final关键字 140</h4><h5 id="7-8-1-final-数据-140"><a href="#7-8-1-final-数据-140" class="headerlink" title="7.8.1 final 数据 140"></a>7.8.1 final 数据 140</h5><h5 id="7-8-2-final-方法-143"><a href="#7-8-2-final-方法-143" class="headerlink" title="7.8.2 final 方法 143"></a>7.8.2 final 方法 143</h5><h5 id="7-8-3-final-类-144"><a href="#7-8-3-final-类-144" class="headerlink" title="7.8.3 final 类 144"></a>7.8.3 final 类 144</h5><h5 id="7-8-4-有关final的忠告-145"><a href="#7-8-4-有关final的忠告-145" class="headerlink" title="7.8.4 有关final的忠告 145"></a>7.8.4 有关final的忠告 145</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>是最终的意思，可以修饰类，方法，变量</span><br><span class="line">面试题：特点：</span><br><span class="line"><span class="keyword">final</span>可以修饰类，该类不能被继承。</span><br><span class="line"><span class="keyword">final</span>可以修饰方法，该方法不能被重写。(覆盖，复写)</span><br><span class="line"><span class="keyword">final</span>可以修饰变量，该变量不能被重新赋值。因为<span class="keyword">final</span>修饰的变量是常量。</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>修饰变量的初始化时机</span><br><span class="line">A:被<span class="keyword">final</span>修饰的变量只能赋值一次。</span><br><span class="line">B:在构造方法完毕前。(非静态的常量)</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>:最终的(<span class="keyword">finally</span>,finalize)</span><br><span class="line"><span class="number">1</span>、<span class="keyword">final</span>修饰变量：常量，只能访问，不能改变值</span><br><span class="line">定义常量时必须初始化(常量名全大写)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">20</span>;</span><br><span class="line"><span class="number">2</span>、修饰方法：该方法不能被重写</span><br><span class="line"><span class="number">3</span>、修饰类：不允许有子类</span><br><span class="line"></span><br><span class="line">面试题：<span class="keyword">final</span>修饰局部变量的问题</span><br><span class="line">基本类型：基本类型的值不能发生改变。</span><br><span class="line">引用类型：引用类型的地址值不能发生改变，但是，该对象的堆内存的值是可以改变的。</span><br></pre></td></tr></table></figure><h4 id="7-9-初始化及类的加载-145"><a href="#7-9-初始化及类的加载-145" class="headerlink" title="7.9 初始化及类的加载 145"></a>7.9 初始化及类的加载 145</h4><h5 id="7-9-1-继承与初始化-146"><a href="#7-9-1-继承与初始化-146" class="headerlink" title="7.9.1 继承与初始化 146"></a>7.9.1 继承与初始化 146</h5><h4 id="7-10-总结-147"><a href="#7-10-总结-147" class="headerlink" title="7.10 总结 147"></a>7.10 总结 147</h4><hr><blockquote></blockquote><h3 id="第8章-多态-148"><a href="#第8章-多态-148" class="headerlink" title="第8章 多态 148"></a>第8章 多态 148</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717165946.png" alt=""></p><h4 id="8-1-再论向上转型-148"><a href="#8-1-再论向上转型-148" class="headerlink" title="8.1 再论向上转型 148"></a>8.1 再论向上转型 148</h4><h5 id="8-1-1-忘记对象类型-149"><a href="#8-1-1-忘记对象类型-149" class="headerlink" title="8.1.1 忘记对象类型 149"></a>8.1.1 忘记对象类型 149</h5><h4 id="8-2-转机-150"><a href="#8-2-转机-150" class="headerlink" title="8.2 转机 150"></a>8.2 转机 150</h4><h5 id="8-2-1-方法调用绑定-150"><a href="#8-2-1-方法调用绑定-150" class="headerlink" title="8.2.1 方法调用绑定 150"></a>8.2.1 方法调用绑定 150</h5><h5 id="8-2-2-产生正确的行为-151"><a href="#8-2-2-产生正确的行为-151" class="headerlink" title="8.2.2 产生正确的行为 151"></a>8.2.2 产生正确的行为 151</h5><h5 id="8-2-3-可扩展性-153"><a href="#8-2-3-可扩展性-153" class="headerlink" title="8.2.3 可扩展性 153"></a>8.2.3 可扩展性 153</h5><h5 id="8-2-4-缺陷：“覆盖”私有方法-156"><a href="#8-2-4-缺陷：“覆盖”私有方法-156" class="headerlink" title="8.2.4 缺陷：“覆盖”私有方法 156"></a>8.2.4 缺陷：“覆盖”私有方法 156</h5><h5 id="8-2-5-缺陷：域与静态方法-156"><a href="#8-2-5-缺陷：域与静态方法-156" class="headerlink" title="8.2.5 缺陷：域与静态方法 156"></a>8.2.5 缺陷：域与静态方法 156</h5><h4 id="8-3-构造器和多态-157"><a href="#8-3-构造器和多态-157" class="headerlink" title="8.3 构造器和多态 157"></a>8.3 构造器和多态 157</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">多态：同一个对象(事物)，在不同时刻体现出来的不同状态。</span><br><span class="line">多态的前提：</span><br><span class="line">A:要有继承关系。</span><br><span class="line">B:要有方法重写。</span><br><span class="line">C:要有父类引用指向子类对象。</span><br><span class="line"></span><br><span class="line">多态的分类：</span><br><span class="line">a:具体类多态</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">b:抽象类多态</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">c:接口多态</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line"></span><br><span class="line">多态中的成员访问特点：</span><br><span class="line">A:成员变量</span><br><span class="line">编译看左边，运行看左边。</span><br><span class="line">B:构造方法</span><br><span class="line">创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化。</span><br><span class="line">C:成员方法</span><br><span class="line">编译看左边，运行看右边。</span><br><span class="line">    由于成员方法存在方法重写，所以它运行看右边。</span><br><span class="line">D:静态方法</span><br><span class="line">编译看左边，运行看左边。</span><br><span class="line">(静态和类相关，算不上重写，所以，访问还是左边的)</span><br><span class="line">多态的好处：</span><br><span class="line">A:提高了代码的维护性(继承保证（体现）)</span><br><span class="line">B:提高了代码的扩展性(由多态保证（体现）)</span><br><span class="line">多态的弊端：</span><br><span class="line">不能使用子类的特有功能。</span><br><span class="line"></span><br><span class="line">    我就想使用子类的特有功能?行不行?</span><br><span class="line">行。怎么用呢?</span><br><span class="line">A:创建子类对象调用方法即可。(可以，但是很多时候不合理。而且，太占内存了)</span><br><span class="line">B:把父类的引用强制转换为子类的引用。(向下转型)</span><br><span class="line">对象间的转型问题：</span><br><span class="line">向上转型：</span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">向下转型：</span><br><span class="line">Zi z = (Zi)f; <span class="comment">//要求该f必须是能够转换为Zi的。</span></span><br><span class="line"></span><br><span class="line">多态：多种形态（同一函数，不同形态)</span><br><span class="line"><span class="number">1</span>、静态多态：程序在编译的时候就知道调用哪个方法</span><br><span class="line">方法重载(Overrload)</span><br><span class="line"><span class="number">2</span>、动态多态：程序在运行时才确定调用哪个方法</span><br><span class="line">方法重写(Override)</span><br></pre></td></tr></table></figure><h5 id="8-3-1-构造器的调用顺序-157"><a href="#8-3-1-构造器的调用顺序-157" class="headerlink" title="8.3.1 构造器的调用顺序 157"></a>8.3.1 构造器的调用顺序 157</h5><h5 id="8-3-2-继承与清理-159"><a href="#8-3-2-继承与清理-159" class="headerlink" title="8.3.2 继承与清理 159"></a>8.3.2 继承与清理 159</h5><h5 id="8-3-3-构造器内部的多态方法的行为-162"><a href="#8-3-3-构造器内部的多态方法的行为-162" class="headerlink" title="8.3.3 构造器内部的多态方法的行为 162"></a>8.3.3 构造器内部的多态方法的行为 162</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();做了哪些事情?(理解)</span><br><span class="line">- (<span class="number">1</span>)把Student<span class="class">.<span class="keyword">class</span>文件加载到内存</span></span><br><span class="line"><span class="class">- (2)在栈内存为<span class="title">s</span>开辟空间</span></span><br><span class="line"><span class="class">- (3)在堆内存为学生对象申请空间</span></span><br><span class="line"><span class="class">- (4)给学生的成员变量进行默认初始化。</span></span><br><span class="line"><span class="class">- (5)给学生的成员变量进行显示初始化。</span></span><br><span class="line"><span class="class">- (6)通过构造方法给成员变量进行初始化。</span></span><br><span class="line"><span class="class">- (7)对象构造完毕，把地址赋值给<span class="title">s</span>变量</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170556.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170624.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170657.png" alt=""></p><h4 id="8-4-协变返回类型-164"><a href="#8-4-协变返回类型-164" class="headerlink" title="8.4 协变返回类型 164"></a>8.4 协变返回类型 164</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170951.png" alt=""></p><h4 id="8-5-用继承进行设计-165"><a href="#8-5-用继承进行设计-165" class="headerlink" title="8.5 用继承进行设计 165"></a>8.5 用继承进行设计 165</h4><h5 id="8-5-1-纯继承与扩展-166"><a href="#8-5-1-纯继承与扩展-166" class="headerlink" title="8.5.1 纯继承与扩展 166"></a>8.5.1 纯继承与扩展 166</h5><h5 id="8-5-2-向下转型与运行时类型识别-167"><a href="#8-5-2-向下转型与运行时类型识别-167" class="headerlink" title="8.5.2 向下转型与运行时类型识别 167"></a>8.5.2 向下转型与运行时类型识别 167</h5><h4 id="8-6-总结-168"><a href="#8-6-总结-168" class="headerlink" title="8.6 总结 168"></a>8.6 总结 168</h4><hr><blockquote></blockquote><blockquote><p>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote><h3 id="第9章-接口-169"><a href="#第9章-接口-169" class="headerlink" title="第9章 接口 169"></a>第9章 接口 169</h3><blockquote><p>需要细看</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190718095331.png" alt=""></p><h4 id="9-1-抽象类和抽象方法-169"><a href="#9-1-抽象类和抽象方法-169" class="headerlink" title="9.1 抽象类和抽象方法 169"></a>9.1 抽象类和抽象方法 169</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">一个没有具体的方法体的方法是抽象的方法。在一个类中如果有抽象方法，该类必须定义为抽象类。</span><br><span class="line">(<span class="number">1</span>)抽象类的特点</span><br><span class="line">A:抽象类和抽象方法必须用关键字<span class="keyword">abstract</span>修饰</span><br><span class="line">B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类</span><br><span class="line">C:抽象类不能实例化</span><br><span class="line">D:抽象类的子类</span><br><span class="line">a:是一个抽象类。</span><br><span class="line">b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。</span><br><span class="line">(<span class="number">2</span>)抽象类的成员特点：</span><br><span class="line">A:成员变量</span><br><span class="line">有变量，有常量</span><br><span class="line">B:构造方法</span><br><span class="line">有构造方法，用于子类访问父类数据的初始化。</span><br><span class="line">C:成员方法</span><br><span class="line">有抽象，有非抽象</span><br><span class="line">(<span class="number">3</span>)抽象类的几个小问题</span><br><span class="line">A:抽象类有构造方法，不能实例化，那么构造方法有什么用?</span><br><span class="line">用于子类访问父类数据的初始化</span><br><span class="line">B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?</span><br><span class="line">为了不让创建对象</span><br><span class="line">C:<span class="keyword">abstract</span>不能和哪些关键字共存</span><br><span class="line">a:<span class="keyword">final</span>冲突</span><br><span class="line">b:<span class="keyword">private</span> 冲突</span><br><span class="line">c:<span class="keyword">static</span> 无意义</span><br></pre></td></tr></table></figure><h4 id="9-2-接口-172"><a href="#9-2-接口-172" class="headerlink" title="9.2 接口 172"></a>9.2 接口 172</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)接口的特点：</span><br><span class="line">A:接口用关键字<span class="class"><span class="keyword">interface</span>修饰</span></span><br><span class="line"><span class="class"><span class="title">interface</span> 接口名 </span>&#123;&#125;</span><br><span class="line">B:类实现接口用implements修饰</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;&#125;</span><br><span class="line">C:接口不能实例化</span><br><span class="line"> 那么，接口如何实例化呢?</span><br><span class="line"> 按照多态的方式来实例化。</span><br><span class="line">D:接口的实现类（子类）</span><br><span class="line">a:是一个抽象类。</span><br><span class="line">b:是一个具体类，这个类必须重写接口中的所有抽象方法。</span><br><span class="line">由此可见：</span><br><span class="line">A:具体类多态(几乎没有)</span><br><span class="line">B:抽象类多态(常用)</span><br><span class="line">C:接口多态(最常用)</span><br><span class="line">(<span class="number">2</span>)接口的成员特点：</span><br><span class="line">A:成员变量</span><br><span class="line">只能是常量</span><br><span class="line">默认修饰符：<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">B:构造方法</span><br><span class="line">没有构造方法</span><br><span class="line">C:成员方法</span><br><span class="line">只能是抽象的</span><br><span class="line">默认修饰符：<span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line">所有的类都默认继承自一个类：Object。</span><br><span class="line">类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。</span><br><span class="line">(<span class="number">3</span>)类与类,类与接口,接口与接口</span><br><span class="line">A:类与类</span><br><span class="line">继承关系，只能单继承，可以多层继承</span><br><span class="line">B:类与接口</span><br><span class="line">实现关系，可以单实现，也可以多实现。</span><br><span class="line">还可以在继承一个类的同时，实现多个接口</span><br><span class="line">C:接口与接口</span><br><span class="line">继承关系，可以单继承，也可以多继承</span><br><span class="line">(<span class="number">4</span>)面试题：抽象类和接口的区别：</span><br><span class="line">A:成员区别</span><br><span class="line">抽象类：</span><br><span class="line">成员变量：可以变量，也可以常量</span><br><span class="line">构造方法：有</span><br><span class="line">成员方法：可以抽象，也可以非抽象</span><br><span class="line">接口：</span><br><span class="line">成员变量：只可以常量</span><br><span class="line">成员方法：只可以抽象</span><br><span class="line">B:关系区别</span><br><span class="line">类与类</span><br><span class="line">继承，单继承</span><br><span class="line">类与接口</span><br><span class="line">实现，单实现，多实现</span><br><span class="line">接口与接口</span><br><span class="line">继承，单继承，多继承</span><br><span class="line">C:设计理念区别</span><br><span class="line">抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。</span><br><span class="line">接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。</span><br><span class="line">抽象类:</span><br><span class="line"><span class="number">1</span>、如果一个类中只要有一个方法是抽象方法，该类变成抽象类</span><br><span class="line"><span class="number">2</span>、抽象类不能被实例化，只用来被继承</span><br><span class="line"><span class="number">3</span>、如果一个类继承一个抽象类，必须实现抽象类中所有的抽象方法</span><br><span class="line">否则，该类也会变成一个抽象类</span><br><span class="line"><span class="number">4</span>、抽象类的引用可以指向子类的实例，达到多态的效果</span><br><span class="line"><span class="number">5</span>、构造方法和静态方法不能定义成抽象方法</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"><span class="number">1</span>、如果一个类中所有的方法都是抽象方法，可以定义成接口</span><br><span class="line">用<span class="class"><span class="keyword">interface</span></span></span><br><span class="line"><span class="class">2、接口中所有的方法都是抽象方法，不能包含非抽象方法,</span></span><br><span class="line"><span class="class">在方法中可以省略<span class="title">abstract</span>关键字</span></span><br><span class="line"><span class="class">3、接口不能被实例化，只用来被实现（<span class="keyword">implements</span>)</span></span><br><span class="line"><span class="class">4、如果一个类实现一个接口，必须实现接口中所有的抽象方法，</span></span><br><span class="line"><span class="class">否则该类也会变成抽象类</span></span><br><span class="line"><span class="class">5、接口的引用指向实现类的实例</span></span><br><span class="line"><span class="class">6、接口中所有的量都是常量，没有变量</span></span><br><span class="line"><span class="class">7、接口中没有构造方法</span></span><br><span class="line"><span class="class">8、为了弥补继承的单一性，接口提供了多实现（一个类可以实现</span></span><br><span class="line"><span class="class">多个接口），必须要实现多个接口中提供的抽象方法</span></span><br><span class="line"><span class="class">9、一个类在继承一个类的同时可以去实现接口</span></span><br><span class="line"><span class="class">10、接口可以继承接口</span></span><br></pre></td></tr></table></figure><h4 id="9-3-完全解耦-174"><a href="#9-3-完全解耦-174" class="headerlink" title="9.3 完全解耦 174"></a>9.3 完全解耦 174</h4><blockquote><p>适配器模式</p></blockquote><h4 id="9-4-Java中的多重继承-178"><a href="#9-4-Java中的多重继承-178" class="headerlink" title="9.4 Java中的多重继承 178"></a>9.4 Java中的多重继承 178</h4><blockquote><p>Java是伪多重继承模式，属于单继承、多实现结合而形成的；在写法上，继承要写在多实现前面</p></blockquote><h4 id="9-5-通过继承来扩展接口-180"><a href="#9-5-通过继承来扩展接口-180" class="headerlink" title="9.5 通过继承来扩展接口 180"></a>9.5 通过继承来扩展接口 180</h4><h5 id="9-5-1-组合接口时的名字冲突-181"><a href="#9-5-1-组合接口时的名字冲突-181" class="headerlink" title="9.5.1 组合接口时的名字冲突 181"></a>9.5.1 组合接口时的名字冲突 181</h5><h4 id="9-6-适配接口-181"><a href="#9-6-适配接口-181" class="headerlink" title="9.6 适配接口 181"></a>9.6 适配接口 181</h4><h4 id="9-7-接口中的域-183"><a href="#9-7-接口中的域-183" class="headerlink" title="9.7 接口中的域 183"></a>9.7 接口中的域 183</h4><h5 id="9-7-1-初始化接口中的域-184"><a href="#9-7-1-初始化接口中的域-184" class="headerlink" title="9.7.1 初始化接口中的域 184"></a>9.7.1 初始化接口中的域 184</h5><h4 id="9-8-嵌套接口-185"><a href="#9-8-嵌套接口-185" class="headerlink" title="9.8 嵌套接口 185"></a>9.8 嵌套接口 185</h4><h4 id="9-9-接口与工厂-186"><a href="#9-9-接口与工厂-186" class="headerlink" title="9.9 接口与工厂 186"></a>9.9 接口与工厂 186</h4><blockquote><p>工厂方法设计模式</p></blockquote><h4 id="9-10-总结-188"><a href="#9-10-总结-188" class="headerlink" title="9.10 总结 188"></a>9.10 总结 188</h4><hr><blockquote></blockquote><h3 id="第10章-内部类-190"><a href="#第10章-内部类-190" class="headerlink" title="第10章 内部类 190"></a>第10章 内部类 190</h3><blockquote><p>需要细看，后期需要时不时的回看</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190718112105.png" alt=""></p><h4 id="10-1-创建内部类-190"><a href="#10-1-创建内部类-190" class="headerlink" title="10.1 创建内部类 190"></a>10.1 创建内部类 190</h4><h4 id="10-2-链接到外部类-191"><a href="#10-2-链接到外部类-191" class="headerlink" title="10.2 链接到外部类 191"></a>10.2 链接到外部类 191</h4><h4 id="10-3-使用-this与-new-193"><a href="#10-3-使用-this与-new-193" class="headerlink" title="10.3 使用.this与.new 193"></a>10.3 使用.this与.new 193</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)把类定义在另一个类的内部，该类就被称为内部类。隐含着一个指向外部类的对象引用</span><br><span class="line">举例：把类B定义在类A中，类B就被称为内部类。</span><br><span class="line">(<span class="number">2</span>)内部类的访问规则</span><br><span class="line">A:可以直接访问外部类的成员，包括私有</span><br><span class="line">B:外部类要想访问内部类成员，必须创建对象</span><br><span class="line">(<span class="number">3</span>)内部类的分类</span><br><span class="line">A:成员内部类</span><br><span class="line">B:局部内部类</span><br><span class="line">成员位置:在成员位置定义的类，被称为成员内部类。</span><br><span class="line">局部位置:在局部位置定义的类，被称为局部内部类。</span><br><span class="line">(<span class="number">4</span>)成员内部类</span><br><span class="line">A:<span class="keyword">private</span> 为了数据的安全性</span><br><span class="line">B:<span class="keyword">static</span> 为了访问的方便性</span><br><span class="line">如何直接访问内部类的成员：</span><br><span class="line">外部类名.内部类名 对象名 = 外部类对象.内部类对象;</span><br><span class="line">成员内部类不是静态的：</span><br><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.<span class="keyword">new</span> 内部类名();</span><br><span class="line">成员内部类是静态的：</span><br><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名();</span><br><span class="line"></span><br><span class="line">注意：静态内部类访问的外部类数据必须用静态修饰。</span><br><span class="line">(<span class="number">5</span>)局部内部类</span><br><span class="line">局部内部类访问局部变量的注意事项?</span><br><span class="line">A:局部内部类访问局部变量必须加<span class="keyword">final</span>修饰。</span><br><span class="line">B:为什么呢?</span><br><span class="line">因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。</span><br><span class="line">所以，堆内存还是用该变量，而改变量已经没有了。</span><br><span class="line">为了让该值还存在，就加<span class="keyword">final</span>修饰。</span><br><span class="line">通过反编译工具我们看到了，加入<span class="keyword">final</span>后，堆内存直接存储的是值，而不是变量名。</span><br></pre></td></tr></table></figure><h4 id="10-4-内部类与向上转型-194"><a href="#10-4-内部类与向上转型-194" class="headerlink" title="10.4 内部类与向上转型 194"></a>10.4 内部类与向上转型 194</h4><h4 id="10-5-在方法和作用域内的内部类-195"><a href="#10-5-在方法和作用域内的内部类-195" class="headerlink" title="10.5 在方法和作用域内的内部类 195"></a>10.5 在方法和作用域内的内部类 195</h4><h4 id="10-6-匿名内部类-196"><a href="#10-6-匿名内部类-196" class="headerlink" title="10.6 匿名内部类 196"></a>10.6 匿名内部类 196</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A:是局部内部类的简化形式</span><br><span class="line">B:前提</span><br><span class="line">存在一个类或者接口</span><br><span class="line">C:格式:</span><br><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br><span class="line">D:本质：</span><br><span class="line">其实是继承该类或者实现接口的子类匿名对象</span><br><span class="line">E:匿名内部类中用到外部参数时，外部参数必须是<span class="keyword">final</span>修饰</span><br><span class="line">匿名内部类在开发中的使用</span><br><span class="line">我们在开发的时候，会看到抽象类，或者接口作为参数。</span><br><span class="line">而这个时候，我们知道实际需要的是一个子类对象。</span><br><span class="line">如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。</span><br></pre></td></tr></table></figure><h5 id="10-6-1-再访工厂方法-199"><a href="#10-6-1-再访工厂方法-199" class="headerlink" title="10.6.1 再访工厂方法 199"></a>10.6.1 再访工厂方法 199</h5><h4 id="10-7-嵌套类-201"><a href="#10-7-嵌套类-201" class="headerlink" title="10.7 嵌套类 201"></a>10.7 嵌套类 201</h4><blockquote><p>内部类声明static，即为嵌套类，这时，就不包含外围对象的引用了，也只能访问外部的static成员</p></blockquote><h5 id="10-7-1-接口内部的类-202"><a href="#10-7-1-接口内部的类-202" class="headerlink" title="10.7.1 接口内部的类 202"></a>10.7.1 接口内部的类 202</h5><blockquote><p>接口可以有内部类</p></blockquote><h5 id="10-7-2-从多层嵌套类中访问外部类的成员-203"><a href="#10-7-2-从多层嵌套类中访问外部类的成员-203" class="headerlink" title="10.7.2 从多层嵌套类中访问外部类的成员 203"></a>10.7.2 从多层嵌套类中访问外部类的成员 203</h5><h4 id="10-8-为什么需要内部类-204"><a href="#10-8-为什么需要内部类-204" class="headerlink" title="10.8 为什么需要内部类 204"></a>10.8 为什么需要内部类 204</h4><h5 id="10-8-1-闭包与回调-205"><a href="#10-8-1-闭包与回调-205" class="headerlink" title="10.8.1 闭包与回调 205"></a>10.8.1 闭包与回调 205</h5><h5 id="10-8-2-内部类与控制框架-207"><a href="#10-8-2-内部类与控制框架-207" class="headerlink" title="10.8.2 内部类与控制框架 207"></a>10.8.2 内部类与控制框架 207</h5><h4 id="10-9-内部类的继承-212"><a href="#10-9-内部类的继承-212" class="headerlink" title="10.9 内部类的继承 212"></a>10.9 内部类的继承 212</h4><h4 id="10-10-内部类可以被覆盖吗-212"><a href="#10-10-内部类可以被覆盖吗-212" class="headerlink" title="10.10 内部类可以被覆盖吗 212"></a>10.10 内部类可以被覆盖吗 212</h4><h4 id="10-11-局部内部类-214"><a href="#10-11-局部内部类-214" class="headerlink" title="10.11 局部内部类 214"></a>10.11 局部内部类 214</h4><h4 id="10-12-内部类标识符-215"><a href="#10-12-内部类标识符-215" class="headerlink" title="10.12 内部类标识符 215"></a>10.12 内部类标识符 215</h4><h4 id="10-13-总结-215"><a href="#10-13-总结-215" class="headerlink" title="10.13 总结 215"></a>10.13 总结 215</h4><hr><blockquote></blockquote><h3 id="第11章-持有对象-216"><a href="#第11章-持有对象-216" class="headerlink" title="第11章 持有对象 216"></a>第11章 持有对象 216</h3><blockquote><p>这一章是初步介绍容器也就是集合的知识点：List、Set、Map、Queue</p></blockquote><h4 id="11-1-泛型和类型安全的容器-216"><a href="#11-1-泛型和类型安全的容器-216" class="headerlink" title="11.1 泛型和类型安全的容器 216"></a>11.1 泛型和类型安全的容器 216</h4><h4 id="11-2-基本概念-219"><a href="#11-2-基本概念-219" class="headerlink" title="11.2 基本概念 219"></a>11.2 基本概念 219</h4><h4 id="11-3-添加一组元素-220"><a href="#11-3-添加一组元素-220" class="headerlink" title="11.3 添加一组元素 220"></a>11.3 添加一组元素 220</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList()</span><br><span class="line">Collections.addAll()</span><br><span class="line">collection.addAll()</span><br></pre></td></tr></table></figure><h4 id="11-4-容器的打印-221"><a href="#11-4-容器的打印-221" class="headerlink" title="11.4 容器的打印 221"></a>11.4 容器的打印 221</h4><h4 id="11-5-List-223"><a href="#11-5-List-223" class="headerlink" title="11.5 List 223"></a>11.5 List 223</h4><blockquote><p>ArrayList LinkedList</p></blockquote><h4 id="11-6-迭代器-226"><a href="#11-6-迭代器-226" class="headerlink" title="11.6 迭代器 226"></a>11.6 迭代器 226</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190719110519.png" alt=""></p><h5 id="11-6-1-ListIterator-227"><a href="#11-6-1-ListIterator-227" class="headerlink" title="11.6.1 ListIterator 227"></a>11.6.1 ListIterator 227</h5><blockquote><p>ListIterator是一个功能更加强大的, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。只用于list集合</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190719111623.png" alt=""></p><p>ListIterator 与Iterator 的区别：</p><blockquote><p>（1）ListIterator有add()方法，可以向List中添加对象，而Iterator不能<br>（2）ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。<br>（3）ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。<br>（4）都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</p></blockquote><h4 id="11-7-LinkedList-228"><a href="#11-7-LinkedList-228" class="headerlink" title="11.7 LinkedList 228"></a>11.7 LinkedList 228</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190719112101.png" alt=""></p><h4 id="11-8-Stack-229"><a href="#11-8-Stack-229" class="headerlink" title="11.8 Stack 229"></a>11.8 Stack 229</h4><blockquote><p>先进后出，可以将LinkedList作为Stack使用</p></blockquote><h4 id="11-9-Set-231"><a href="#11-9-Set-231" class="headerlink" title="11.9 Set 231"></a>11.9 Set 231</h4><blockquote><p>不重复元素</p></blockquote><h4 id="11-10-Map-233"><a href="#11-10-Map-233" class="headerlink" title="11.10 Map 233"></a>11.10 Map 233</h4><h4 id="11-11-Queue-236"><a href="#11-11-Queue-236" class="headerlink" title="11.11 Queue 236"></a>11.11 Queue 236</h4><blockquote><p>先进先出，LinkedList实现了此接口</p></blockquote><h5 id="11-11-1-PriorityQueue-237"><a href="#11-11-1-PriorityQueue-237" class="headerlink" title="11.11.1 PriorityQueue 237"></a>11.11.1 PriorityQueue 237</h5><blockquote><p>优先级队列，有序队列</p></blockquote><h4 id="11-12-Collection和Iterator-238"><a href="#11-12-Collection和Iterator-238" class="headerlink" title="11.12 Collection和Iterator 238"></a>11.12 Collection和Iterator 238</h4><blockquote><p>重点在于Iterator 接口思想，与下面的Foreach一样，理解Iterator 原理</p></blockquote><h4 id="11-13-Foreach与迭代器-241"><a href="#11-13-Foreach与迭代器-241" class="headerlink" title="11.13 Foreach与迭代器 241"></a>11.13 Foreach与迭代器 241</h4><blockquote><p>实现Iterable接口的Iterator 方法皆可用于foreach</p></blockquote><h5 id="11-13-1-适配器方法惯用法-243"><a href="#11-13-1-适配器方法惯用法-243" class="headerlink" title="11.13.1 适配器方法惯用法 243"></a>11.13.1 适配器方法惯用法 243</h5><blockquote><p>适配器模式实现Iterator 方法</p></blockquote><h4 id="11-14-总结-248"><a href="#11-14-总结-248" class="headerlink" title="11.14 总结 248"></a>11.14 总结 248</h4><hr><blockquote></blockquote><h3 id="第12章-通过异常处理错误-248"><a href="#第12章-通过异常处理错误-248" class="headerlink" title="第12章 通过异常处理错误 248"></a>第12章 通过异常处理错误 248</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190722151802.png" alt=""></p><h4 id="12-1-概念-249"><a href="#12-1-概念-249" class="headerlink" title="12.1 概念 249"></a>12.1 概念 249</h4><h4 id="12-2-基本异常-249"><a href="#12-2-基本异常-249" class="headerlink" title="12.2 基本异常 249"></a>12.2 基本异常 249</h4><h5 id="12-2-1-异常参数-250"><a href="#12-2-1-异常参数-250" class="headerlink" title="12.2.1 异常参数 250"></a>12.2.1 异常参数 250</h5><h4 id="12-3-捕获异常-250"><a href="#12-3-捕获异常-250" class="headerlink" title="12.3 捕获异常 250"></a>12.3 捕获异常 250</h4><h5 id="12-3-1-try块-250"><a href="#12-3-1-try块-250" class="headerlink" title="12.3.1 try块 250"></a>12.3.1 try块 250</h5><h5 id="12-3-2-异常处理程序-250"><a href="#12-3-2-异常处理程序-250" class="headerlink" title="12.3.2 异常处理程序 250"></a>12.3.2 异常处理程序 250</h5><h4 id="12-4-创建自定义异常-251"><a href="#12-4-创建自定义异常-251" class="headerlink" title="12.4 创建自定义异常 251"></a>12.4 创建自定义异常 251</h4><h5 id="12-4-1-异常与记录日志-253"><a href="#12-4-1-异常与记录日志-253" class="headerlink" title="12.4.1 异常与记录日志 253"></a>12.4.1 异常与记录日志 253</h5><h4 id="12-5-异常说明-256"><a href="#12-5-异常说明-256" class="headerlink" title="12.5 异常说明 256"></a>12.5 异常说明 256</h4><h4 id="12-6-捕获所有异常-256"><a href="#12-6-捕获所有异常-256" class="headerlink" title="12.6 捕获所有异常 256"></a>12.6 捕获所有异常 256</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723112853.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723112924.png" alt=""></p><h5 id="12-6-1-栈轨迹-257"><a href="#12-6-1-栈轨迹-257" class="headerlink" title="12.6.1 栈轨迹 257"></a>12.6.1 栈轨迹 257</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113224.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113257.png" alt=""></p><h5 id="12-6-2-重新抛出异常-258"><a href="#12-6-2-重新抛出异常-258" class="headerlink" title="12.6.2 重新抛出异常 258"></a>12.6.2 重新抛出异常 258</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113543.png" alt=""></p><h5 id="12-6-3-异常链-260"><a href="#12-6-3-异常链-260" class="headerlink" title="12.6.3 异常链 260"></a>12.6.3 异常链 260</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113925.png" alt=""></p><h4 id="12-7-Java标准异常-263"><a href="#12-7-Java标准异常-263" class="headerlink" title="12.7 Java标准异常 263"></a>12.7 Java标准异常 263</h4><blockquote><p>Throwable</p><p>​            —Error</p><p>​            —Exception</p><p>​                        ——RuntimeException</p><p>​                        ——非RuntimeException</p></blockquote><h5 id="12-7-1-特例：RuntimeException-263"><a href="#12-7-1-特例：RuntimeException-263" class="headerlink" title="12.7.1 特例：RuntimeException 263"></a>12.7.1 特例：RuntimeException 263</h5><h4 id="12-8-使用finally进行清理-264"><a href="#12-8-使用finally进行清理-264" class="headerlink" title="12.8 使用finally进行清理 264"></a>12.8 使用finally进行清理 264</h4><h5 id="12-8-1-finally用来做什么-265"><a href="#12-8-1-finally用来做什么-265" class="headerlink" title="12.8.1 finally用来做什么 265"></a>12.8.1 finally用来做什么 265</h5><h5 id="12-8-2-在return中使用finally-267"><a href="#12-8-2-在return中使用finally-267" class="headerlink" title="12.8.2 在return中使用finally 267"></a>12.8.2 在return中使用finally 267</h5><h5 id="12-8-3-缺憾：异常丢失-268"><a href="#12-8-3-缺憾：异常丢失-268" class="headerlink" title="12.8.3 缺憾：异常丢失 268"></a>12.8.3 缺憾：异常丢失 268</h5><blockquote><p>某些情况下，使用finally会使异常丢失：前一个异常还没处理就抛出另一个异常</p></blockquote><h4 id="12-9-异常的限制-269"><a href="#12-9-异常的限制-269" class="headerlink" title="12.9 异常的限制 269"></a>12.9 异常的限制 269</h4><blockquote><p>继承上的限制</p></blockquote><h4 id="12-10-构造器-271"><a href="#12-10-构造器-271" class="headerlink" title="12.10 构造器 271"></a>12.10 构造器 271</h4><blockquote><p>在创建需要清理的对象之后，立即进入一个try—finally块</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723153106.png" alt=""></p><h4 id="12-11-异常匹配-275"><a href="#12-11-异常匹配-275" class="headerlink" title="12.11 异常匹配 275"></a>12.11 异常匹配 275</h4><blockquote><p>子类异常可匹配父类异常</p></blockquote><h4 id="12-12-其他可选方式-276"><a href="#12-12-其他可选方式-276" class="headerlink" title="12.12 其他可选方式 276"></a>12.12 其他可选方式 276</h4><blockquote><p>源于异常的来源以及其他处理方式，重点在于理解</p></blockquote><h5 id="12-12-1-历史-277"><a href="#12-12-1-历史-277" class="headerlink" title="12.12.1 历史 277"></a>12.12.1 历史 277</h5><h5 id="12-12-2-观点-278"><a href="#12-12-2-观点-278" class="headerlink" title="12.12.2 观点 278"></a>12.12.2 观点 278</h5><h5 id="12-12-3-把异常传递给控制台-279"><a href="#12-12-3-把异常传递给控制台-279" class="headerlink" title="12.12.3 把异常传递给控制台 279"></a>12.12.3 把异常传递给控制台 279</h5><h5 id="12-12-4-把“被检查的异常”转换为“不受检查的异常”-279"><a href="#12-12-4-把“被检查的异常”转换为“不受检查的异常”-279" class="headerlink" title="12.12.4 把“被检查的异常”转换为“不受检查的异常” 279"></a>12.12.4 把“被检查的异常”转换为“不受检查的异常” 279</h5><h4 id="12-13-异常使用指南-281"><a href="#12-13-异常使用指南-281" class="headerlink" title="12.13 异常使用指南 281"></a>12.13 异常使用指南 281</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723161941.png" alt=""></p><h4 id="12-14-总结-281"><a href="#12-14-总结-281" class="headerlink" title="12.14 总结 281"></a>12.14 总结 281</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)程序出现的不正常的情况。</span><br><span class="line"><span class="number">1</span>、编译时异常：语法错误</span><br><span class="line"><span class="number">2</span>、运行时异常：逻辑错误（数组下标越界）</span><br><span class="line">(<span class="number">2</span>)异常的体系</span><br><span class="line">Throwable</span><br><span class="line">|--Error严重问题，我们不处理，比如说内存溢出。</span><br><span class="line">|--Exception</span><br><span class="line">|--RuntimeException运行期异常，这种问题我们也不处理，因为是你的问题，而且这个问题出现肯定是我们的代码不够严谨，需要修正代码的。</span><br><span class="line">|--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过</span><br><span class="line">(<span class="number">3</span>)异常的处理：</span><br><span class="line">A:JVM的默认处理</span><br><span class="line">把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。</span><br><span class="line">B:自己处理</span><br><span class="line">a:<span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line">自己编写处理代码,后面的程序可以继续执行</span><br><span class="line">b:<span class="keyword">throws</span></span><br><span class="line">把自己处理不了的，在方法上声明，告诉调用者，这里有问题,这个格式必须跟在方法的括号后面。</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span>的处理格式：</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">可能出现问题的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常名 变量) &#123;</span><br><span class="line"> 针对问题的处理;</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  释放资源;</span><br><span class="line">  &#125;</span><br><span class="line">(<span class="number">4</span>)面试题</span><br><span class="line">A:编译期异常和运行期异常的区别?</span><br><span class="line">编译期异常 必须要处理的，否则编译不通过</span><br><span class="line">运行期异常 可以不处理，也可以处理</span><br><span class="line">B:<span class="keyword">throw</span>和<span class="keyword">throws</span>是的区别</span><br><span class="line"><span class="keyword">throws</span></span><br><span class="line">              用在方法声明后面，跟的是异常类名</span><br><span class="line">              可以跟多个异常类名，用逗号隔开</span><br><span class="line">              表示抛出异常，由该方法的调用者来处理</span><br><span class="line">              <span class="keyword">throws</span>表示出现异常的一种可能性，并不一定会发生这些异常</span><br><span class="line">          <span class="keyword">throw</span></span><br><span class="line">              用在方法体内，跟的是异常对象名</span><br><span class="line">              只能抛出一个异常对象名</span><br><span class="line">              表示抛出异常，由方法体内的语句处理</span><br><span class="line">              <span class="keyword">throw</span>则是抛出了异常，执行<span class="keyword">throw</span>则一定抛出了某种异常</span><br><span class="line">(<span class="number">5</span>)<span class="keyword">finally</span>关键字及其面试题</span><br><span class="line">A:<span class="keyword">finally</span>用于释放资源，它的代码永远会执行。特殊情况：在执行到<span class="keyword">finally</span>之前jvm退出了</span><br><span class="line">B:面试题</span><br><span class="line">a:<span class="keyword">final</span>,<span class="keyword">finally</span>,finalize的区别?</span><br><span class="line"><span class="keyword">final</span>：最终的意思，可以修饰类，成员变量，成员方法</span><br><span class="line"> 修饰类，类不能被继承</span><br><span class="line">  修饰变量，变量是常量</span><br><span class="line">  修饰方法，方法不能被重写</span><br><span class="line">  <span class="keyword">finally</span>：是异常处理的一部分，用于释放资源。</span><br><span class="line">  一般来说，代码肯定会执行，特殊情况：在执行到<span class="keyword">finally</span>之前jvm退出了</span><br><span class="line"> finalize：是Object类的一个方法，用于垃圾回收</span><br><span class="line"></span><br><span class="line">b:如果在<span class="keyword">catch</span>里面有<span class="keyword">return</span>,请问<span class="keyword">finally</span>还执行吗?如果执行,在<span class="keyword">return</span>前还是后？</span><br><span class="line"></span><br><span class="line">会，前。实际上在中间。</span><br><span class="line"></span><br><span class="line">C:异常处理的变形</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">catch</span>...</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">catch</span>...fianlly</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">finally</span> 这种做法的目前是为了释放资源。</span><br><span class="line"></span><br><span class="line">注意： </span><br><span class="line">A:<span class="keyword">try</span>里面的代码越少越好</span><br><span class="line">B:<span class="keyword">catch</span>里面必须有内容，哪怕是给出一个简单的提示</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"><span class="number">1</span>:能明确的尽量明确，不要用大的来处理。</span><br><span class="line">  <span class="number">2</span>:平级关系的异常谁前谁后无所谓，如果出现了子父关系，父必须在后面。</span><br><span class="line">  </span><br><span class="line"> 注意：</span><br><span class="line">  一旦<span class="keyword">try</span>里面出了问题，就会在这里把问题给抛出去，然后和<span class="keyword">catch</span>里面的问题进行匹配，</span><br><span class="line">一旦有匹配的，就执行<span class="keyword">catch</span>里面的处理，然后结束了<span class="keyword">try</span>...<span class="keyword">catch</span>继续执行后面的语句。</span><br><span class="line">  </span><br><span class="line">     d.JDK7出现了一个新的异常处理方案：</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"> </span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常名<span class="number">1</span> | 异常名<span class="number">2</span> | ...  变量 ) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  注意：这个方法虽然简洁，但是也不够好。</span><br><span class="line">  A:处理方式是一致的。(实际开发中，好多时候可能就是针对同类型的问题，给出同一个处理)</span><br><span class="line"> B:多个异常间必须是平级关系。</span><br><span class="line">(<span class="number">6</span>)自定义异常</span><br><span class="line">继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可</span><br><span class="line"></span><br><span class="line">   自定义异常：</span><br><span class="line"><span class="number">1</span>、定义一个类继承Exception类</span><br><span class="line"><span class="number">2</span>、定义一个带参数的构造方法</span><br><span class="line"><span class="number">3</span>、调用父类带参数的构造方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>(message);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>)异常的注意实现</span><br><span class="line">A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 </span><br><span class="line">B:父的方法没有异常抛出,子的重写方法不能有异常抛出</span><br><span class="line">C:父的方法抛出多个异常,子的重写方法必须比父少或者小</span><br><span class="line"></span><br><span class="line">异常注意事项:</span><br><span class="line"> A:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</span><br><span class="line"> B:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</span><br><span class="line"> C:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只</span><br><span class="line">   能<span class="keyword">try</span>,不能<span class="keyword">throws</span></span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）异常中要了解的几个方法：</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span>:异常的消息字符串</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>:返回异常的简单信息描述此对象的类的 <span class="title">name</span><span class="params">(全路径名)</span></span></span><br><span class="line"><span class="function"> ": "（冒号和一个空格） 调用此对象<span class="title">getLocalizedMessage</span><span class="params">()</span>方法的结果 </span></span><br><span class="line"><span class="function"><span class="params">(默认返回的是getMessage()</span>的内容)</span></span><br><span class="line"><span class="function">  <span class="title">printStackTrace</span><span class="params">()</span> 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值<span class="keyword">void</span>。</span></span><br><span class="line"><span class="function">把信息输出在控制台。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Exception类中的方法：</span></span><br><span class="line"><span class="function"> <span class="title">getMessage</span><span class="params">()</span>:获得异常相关的描述信息<span class="params">(获得异常产生的原因）</span></span></span><br><span class="line"><span class="function"><span class="params"> printStackTrace()</span>:获得异常相关的描述信息<span class="params">(包括异常产生的</span></span></span><br><span class="line"><span class="function"><span class="params"> 原因以及异常产生的位置)</span></span></span><br></pre></td></tr></table></figure><hr><blockquote></blockquote><h3 id="第13章-字符串-283"><a href="#第13章-字符串-283" class="headerlink" title="第13章 字符串 283"></a>第13章 字符串 283</h3><h4 id="13-1-不可变String-283"><a href="#13-1-不可变String-283" class="headerlink" title="13.1 不可变String 283"></a>13.1 不可变String 283</h4><h4 id="13-2-重载“-”与StringBuilder-283"><a href="#13-2-重载“-”与StringBuilder-283" class="headerlink" title="13.2 重载“+”与StringBuilder 283"></a>13.2 重载“+”与StringBuilder 283</h4><blockquote><p>每一个+号，意味着new了一个StringBuilder 对象</p></blockquote><h4 id="13-3-无意识的递归-287"><a href="#13-3-无意识的递归-287" class="headerlink" title="13.3 无意识的递归 287"></a>13.3 无意识的递归 287</h4><h4 id="13-4-String上的操作-288"><a href="#13-4-String上的操作-288" class="headerlink" title="13.4 String上的操作 288"></a>13.4 String上的操作 288</h4><h4 id="13-5-格式化输出-289"><a href="#13-5-格式化输出-289" class="headerlink" title="13.5 格式化输出 289"></a>13.5 格式化输出 289</h4><h5 id="13-5-1-printf-289"><a href="#13-5-1-printf-289" class="headerlink" title="13.5.1 printf() 289"></a>13.5.1 printf() 289</h5><blockquote><p>%d 整数；%f 浮点型；%s字符串</p></blockquote><h5 id="13-5-2-System-out-format-289"><a href="#13-5-2-System-out-format-289" class="headerlink" title="13.5.2 System.out.format() 289"></a>13.5.2 System.out.format() 289</h5><blockquote><p>等价于printf()，此方法适用于PrintStream或者PrintWriter对象</p></blockquote><h5 id="13-5-3-Formatter类-290"><a href="#13-5-3-Formatter类-290" class="headerlink" title="13.5.3 Formatter类 290"></a>13.5.3 Formatter类 290</h5><blockquote><p>格式化输出</p></blockquote><h5 id="13-5-4-格式化说明符-291"><a href="#13-5-4-格式化说明符-291" class="headerlink" title="13.5.4 格式化说明符 291"></a>13.5.4 格式化说明符 291</h5><blockquote><p>空格对齐</p></blockquote><h5 id="13-5-5-Formatter转换-292"><a href="#13-5-5-Formatter转换-292" class="headerlink" title="13.5.5 Formatter转换 292"></a>13.5.5 Formatter转换 292</h5><blockquote><p>Formatter.formatter()</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190724141203.png" alt=""></p><h5 id="13-5-6-String-format-294"><a href="#13-5-6-String-format-294" class="headerlink" title="13.5.6 String.format() 294"></a>13.5.6 String.format() 294</h5><blockquote><p>String.format()内部还是调用Formatter.formatter()</p></blockquote><h4 id="13-6-正则表达式-295"><a href="#13-6-正则表达式-295" class="headerlink" title="13.6 正则表达式 295"></a>13.6 正则表达式 295</h4><h5 id="13-6-1-基础-295"><a href="#13-6-1-基础-295" class="headerlink" title="13.6.1 基础 295"></a>13.6.1 基础 295</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 可能有一个负号在最前：-?   即?号表示可能存在</span><br><span class="line"><span class="number">2</span>. 在正则表达式中，\d表示一位数字，在Java中，反斜杠需要转义，即\\d表示一位数字</span><br><span class="line"><span class="number">3</span>. \\\\普通的反斜杠</span><br><span class="line"><span class="number">4</span>. 换行和制表符之类的只需要单个反斜杠：\n\t</span><br><span class="line"><span class="number">5</span>. 一个或多个之前的表达式：+</span><br><span class="line">    -?\\d+  :表示可能有一个负号，后面跟着一位或多位数字</span><br><span class="line"><span class="number">6</span>. | 表示或者，(-|\\+)?\\d+  表示以一个加号或减号开头（可能都没有，因为后面有个问号）的数字，由于字符+在正则表达式中有特殊含义，需要\\转义</span><br><span class="line"><span class="number">7</span>. \W(Java中需要写成\\W):非单词字符</span><br><span class="line"><span class="number">8</span>. \w(Java中需要写成\\w):一个单词字符</span><br></pre></td></tr></table></figure><h5 id="13-6-2-创建正则表达式-297"><a href="#13-6-2-创建正则表达式-297" class="headerlink" title="13.6.2 创建正则表达式 297"></a>13.6.2 创建正则表达式 297</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190725103949.png" alt=""></p><p>jdk1.6的正则表达式：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190725jdk1.6regex.png" alt=""></p><h5 id="13-6-3-量词-299"><a href="#13-6-3-量词-299" class="headerlink" title="13.6.3 量词 299"></a>13.6.3 量词 299</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190725105754.png" alt=""></p><blockquote><p>CharSequence接口，正则表达式能接受此接口类型的参数</p></blockquote><h5 id="13-6-4-Pattern和Matcher-300"><a href="#13-6-4-Pattern和Matcher-300" class="headerlink" title="13.6.4 Pattern和Matcher 300"></a>13.6.4 Pattern和Matcher 300</h5><blockquote><p>相关方法的用法</p></blockquote><h5 id="13-6-5-split-305"><a href="#13-6-5-split-305" class="headerlink" title="13.6.5 split() 305"></a>13.6.5 split() 305</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split(CharSequence input)</span><br><span class="line">split(CharSequence input, <span class="keyword">int</span> limit)</span><br><span class="line">    limit表示分割后数组的大小，限制分割</span><br></pre></td></tr></table></figure><h5 id="13-6-6-替换操作-306"><a href="#13-6-6-替换操作-306" class="headerlink" title="13.6.6 替换操作 306"></a>13.6.6 替换操作 306</h5><blockquote><p>replace相关操作</p></blockquote><h5 id="13-6-7-reset-307"><a href="#13-6-7-reset-307" class="headerlink" title="13.6.7 reset() 307"></a>13.6.7 reset() 307</h5><h5 id="13-6-8-正则表达式与Java-I-O-307"><a href="#13-6-8-正则表达式与Java-I-O-307" class="headerlink" title="13.6.8 正则表达式与Java I/O 307"></a>13.6.8 正则表达式与Java I/O 307</h5><h4 id="13-7-扫描输入-309"><a href="#13-7-扫描输入-309" class="headerlink" title="13.7 扫描输入 309"></a>13.7 扫描输入 309</h4><blockquote><p>Scanner 类是jdk1.5新加入的</p></blockquote><h5 id="13-7-1-Scanner定界符-310"><a href="#13-7-1-Scanner定界符-310" class="headerlink" title="13.7.1 Scanner定界符 310"></a>13.7.1 Scanner定界符 310</h5><blockquote><p>默认空白字符分割，可以使用正则表达式指定</p><p>scanner.useDelimiter(pattern)</p></blockquote><h5 id="13-7-2-用正则表达式扫描-311"><a href="#13-7-2-用正则表达式扫描-311" class="headerlink" title="13.7.2 用正则表达式扫描 311"></a>13.7.2 用正则表达式扫描 311</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scanner.next(pattern);</span><br><span class="line">MatchResult match = scanner.match();</span><br><span class="line">match.group(<span class="number">1</span>);</span><br><span class="line">match.group(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="13-8-StringTokenizer-312"><a href="#13-8-StringTokenizer-312" class="headerlink" title="13.8 StringTokenizer 312"></a>13.8 StringTokenizer 312</h4><blockquote><p>作者说基本上可以放弃了，使用正则表达式或者Scanner就可以了</p></blockquote><h4 id="13-9-总结-312"><a href="#13-9-总结-312" class="headerlink" title="13.9 总结 312"></a>13.9 总结 312</h4><hr><blockquote></blockquote><blockquote><p>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote><h3 id="第14章-类型信息-313"><a href="#第14章-类型信息-313" class="headerlink" title="第14章 类型信息 313"></a>第14章 类型信息 313</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190731163133.png" alt=""></p><h4 id="14-1-为什么需要RTTI-313"><a href="#14-1-为什么需要RTTI-313" class="headerlink" title="14.1 为什么需要RTTI 313"></a>14.1 为什么需要RTTI 313</h4><blockquote><p>RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用<a href="https://baike.baidu.com/item/基类/9589663" target="_blank" rel="noopener">基类</a>的<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>或引用来检查这些指针或引用所指的对象的实际<a href="https://baike.baidu.com/item/派生类" target="_blank" rel="noopener">派生类</a>型。—-百度百科</p></blockquote><h4 id="14-2-Class对象-314"><a href="#14-2-Class对象-314" class="headerlink" title="14.2 Class对象 314"></a>14.2 Class对象 314</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190731163938.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190731164104.png" alt=""></p><h5 id="14-2-1-类字面常量-318"><a href="#14-2-1-类字面常量-318" class="headerlink" title="14.2.1 类字面常量 318"></a>14.2.1 类字面常量 318</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190802095921.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190802100200.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190802101954.png" alt=""></p><h5 id="14-2-2-泛化的Class引用-320"><a href="#14-2-2-泛化的Class引用-320" class="headerlink" title="14.2.2 泛化的Class引用 320"></a>14.2.2 泛化的Class引用 320</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Number</span>&gt; <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">Class</span>&lt;? <span class="title">super</span> <span class="title">Number</span>&gt; <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">Class</span>对象的<span class="title">newInstance</span>()方法将返回该对象的确切类型（排除为不确定的超类）</span></span><br></pre></td></tr></table></figure><h5 id="14-2-3-新的转型语法-322"><a href="#14-2-3-新的转型语法-322" class="headerlink" title="14.2.3 新的转型语法 322"></a>14.2.3 新的转型语法 322</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在强制转型报错的情况下仍需要转型，可以用Class类的cast()方法</span><br></pre></td></tr></table></figure><h4 id="14-3-类型转换前先做检查-322"><a href="#14-3-类型转换前先做检查-322" class="headerlink" title="14.3 类型转换前先做检查 322"></a>14.3 类型转换前先做检查 322</h4><blockquote><p>cat instanceof  Cat   判断某个对象是否属于某个类，返回布尔值</p></blockquote><h5 id="14-3-1-使用类字面常量-327"><a href="#14-3-1-使用类字面常量-327" class="headerlink" title="14.3.1 使用类字面常量 327"></a>14.3.1 使用类字面常量 327</h5><h5 id="14-3-2-动态的instanceof-329"><a href="#14-3-2-动态的instanceof-329" class="headerlink" title="14.3.2 动态的instanceof 329"></a>14.3.2 动态的instanceof 329</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class类的isInstance()方法：判断对象类型</span><br></pre></td></tr></table></figure><h5 id="14-3-3-递归计数-330"><a href="#14-3-3-递归计数-330" class="headerlink" title="14.3.3 递归计数 330"></a>14.3.3 递归计数 330</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class的isAssignableFeom()方法判断是否来自某个继承体系</span><br></pre></td></tr></table></figure><h4 id="14-4-注册工厂-331"><a href="#14-4-注册工厂-331" class="headerlink" title="14.4 注册工厂 331"></a>14.4 注册工厂 331</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190815102032.png" alt=""></p><h4 id="14-5-instanceof-与-Class的等价性-333"><a href="#14-5-instanceof-与-Class的等价性-333" class="headerlink" title="14.5 instanceof 与 Class的等价性 333"></a>14.5 instanceof 与 Class的等价性 333</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190815103039.png" alt=""></p><h4 id="14-6-反射：运行时的类信息-334"><a href="#14-6-反射：运行时的类信息-334" class="headerlink" title="14.6 反射：运行时的类信息 334"></a>14.6 反射：运行时的类信息 334</h4><blockquote><p>反射包含Field|Method|Constructor类</p></blockquote><h5 id="14-6-1-类方法提取器-335"><a href="#14-6-1-类方法提取器-335" class="headerlink" title="14.6.1 类方法提取器 335"></a>14.6.1 类方法提取器 335</h5><blockquote><p>其对应的getMethod()、getConstructor()、getField()方法获取相应数组</p></blockquote><h4 id="14-7-动态代理-337"><a href="#14-7-动态代理-337" class="headerlink" title="14.7 动态代理 337"></a>14.7 动态代理 337</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance()方法可以创建动态代理</span><br></pre></td></tr></table></figure><h4 id="14-8-空对象-341"><a href="#14-8-空对象-341" class="headerlink" title="14.8 空对象 341"></a>14.8 空对象 341</h4><blockquote><p>不太理解</p></blockquote><h5 id="14-8-1-模拟对象与桩-346"><a href="#14-8-1-模拟对象与桩-346" class="headerlink" title="14.8.1 模拟对象与桩 346"></a>14.8.1 模拟对象与桩 346</h5><h4 id="14-9-接口与类型信息-346"><a href="#14-9-接口与类型信息-346" class="headerlink" title="14.9 接口与类型信息 346"></a>14.9 接口与类型信息 346</h4><blockquote><p>通过反射技术，在提供对象、方法名时，可以实现调用任何修饰权限的方法</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190815142541.png" alt=""></p><h4 id="14-10-总结-350"><a href="#14-10-总结-350" class="headerlink" title="14.10 总结 350"></a>14.10 总结 350</h4><hr><blockquote></blockquote><h3 id="第15章-泛型-352"><a href="#第15章-泛型-352" class="headerlink" title="第15章 泛型 352"></a>第15章 泛型 352</h3><blockquote><p>需重读</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190816143241.png" alt=""></p><h4 id="15-1-与C-的比较-352"><a href="#15-1-与C-的比较-352" class="headerlink" title="15.1 与C++的比较 352"></a>15.1 与C++的比较 352</h4><h4 id="15-2-简单泛型-353"><a href="#15-2-简单泛型-353" class="headerlink" title="15.2 简单泛型 353"></a>15.2 简单泛型 353</h4><h5 id="15-2-1-一个元组类库-354"><a href="#15-2-1-一个元组类库-354" class="headerlink" title="15.2.1 一个元组类库 354"></a>15.2.1 一个元组类库 354</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写法为：</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line">A，B两个成员变量</span><br><span class="line">构造函数中传入AB，赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="15-2-2-一个堆栈类-356"><a href="#15-2-2-一个堆栈类-356" class="headerlink" title="15.2.2 一个堆栈类 356"></a>15.2.2 一个堆栈类 356</h5><h5 id="15-2-3-RandomList-357"><a href="#15-2-3-RandomList-357" class="headerlink" title="15.2.3 RandomList 357"></a>15.2.3 RandomList 357</h5><h4 id="15-3-泛型接口-358"><a href="#15-3-泛型接口-358" class="headerlink" title="15.3 泛型接口 358"></a>15.3 泛型接口 358</h4><ul><li>例子代码：</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828141305.png" alt=""></p><blockquote><p>基本类型无法作为参数类型，但可以自动装箱</p></blockquote><h4 id="15-4-泛型方法-361"><a href="#15-4-泛型方法-361" class="headerlink" title="15.4 泛型方法 361"></a>15.4 泛型方法 361</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828110047.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">泛型参数列表置于返回值前：</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828111112.png" alt=""></p><h5 id="15-4-1-杠杆利用类型参数推断-362"><a href="#15-4-1-杠杆利用类型参数推断-362" class="headerlink" title="15.4.1 杠杆利用类型参数推断 362"></a>15.4.1 杠杆利用类型参数推断 362</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828111319.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828111607.png" alt=""></p><h5 id="15-4-2-可变参数与泛型方法-363"><a href="#15-4-2-可变参数与泛型方法-363" class="headerlink" title="15.4.2 可变参数与泛型方法 363"></a>15.4.2 可变参数与泛型方法 363</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T... args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="15-4-3-用于Generator的泛型方法-364"><a href="#15-4-3-用于Generator的泛型方法-364" class="headerlink" title="15.4.3 用于Generator的泛型方法 364"></a>15.4.3 用于Generator的泛型方法 364</h5><blockquote><p>在生成器中用泛型是十分合适的</p></blockquote><h5 id="15-4-4-一个通用的Generator-364"><a href="#15-4-4-一个通用的Generator-364" class="headerlink" title="15.4.4 一个通用的Generator 364"></a>15.4.4 一个通用的Generator 364</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828140642.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828140718.png" alt=""></p><h5 id="15-4-5-简化元组的使用-366"><a href="#15-4-5-简化元组的使用-366" class="headerlink" title="15.4.5 简化元组的使用 366"></a>15.4.5 简化元组的使用 366</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190828142023.png" alt=""></p><h5 id="15-4-6-一个Set实用工具-367"><a href="#15-4-6-一个Set实用工具-367" class="headerlink" title="15.4.6 一个Set实用工具 367"></a>15.4.6 一个Set实用工具 367</h5><h4 id="15-5-匿名内部类-369"><a href="#15-5-匿名内部类-369" class="headerlink" title="15.5 匿名内部类 369"></a>15.5 匿名内部类 369</h4><blockquote><p>内部类、匿名内部类也可用于泛型中</p></blockquote><h4 id="15-6-构建复杂模型-371"><a href="#15-6-构建复杂模型-371" class="headerlink" title="15.6 构建复杂模型 371"></a>15.6 构建复杂模型 371</h4><h4 id="15-7-擦除的神秘之处-372"><a href="#15-7-擦除的神秘之处-372" class="headerlink" title="15.7 擦除的神秘之处 372"></a>15.7 擦除的神秘之处 372</h4><blockquote><p>擦除：在泛型代码内部，无法获得任何有关泛型参数类型的信息</p></blockquote><blockquote><p>可用  &lt;? extend Circle&gt; 方式控制边界</p></blockquote><h5 id="15-7-1-C-的方式-373"><a href="#15-7-1-C-的方式-373" class="headerlink" title="15.7.1 C++的方式 373"></a>15.7.1 C++的方式 373</h5><h5 id="15-7-2-迁移兼容性-375"><a href="#15-7-2-迁移兼容性-375" class="headerlink" title="15.7.2 迁移兼容性 375"></a>15.7.2 迁移兼容性 375</h5><h5 id="15-7-3-擦除的问题-376"><a href="#15-7-3-擦除的问题-376" class="headerlink" title="15.7.3 擦除的问题 376"></a>15.7.3 擦除的问题 376</h5><h5 id="15-7-4-边界处的动作-377"><a href="#15-7-4-边界处的动作-377" class="headerlink" title="15.7.4 边界处的动作 377"></a>15.7.4 边界处的动作 377</h5><h4 id="15-8-擦除的补偿-380"><a href="#15-8-擦除的补偿-380" class="headerlink" title="15.8 擦除的补偿 380"></a>15.8 擦除的补偿 380</h4><h5 id="15-8-1-创建类型实例-381"><a href="#15-8-1-创建类型实例-381" class="headerlink" title="15.8.1 创建类型实例 381"></a>15.8.1 创建类型实例 381</h5><h5 id="15-8-2-泛型数组-383"><a href="#15-8-2-泛型数组-383" class="headerlink" title="15.8.2 泛型数组 383"></a>15.8.2 泛型数组 383</h5><h4 id="15-9-边界-386"><a href="#15-9-边界-386" class="headerlink" title="15.9 边界 386"></a>15.9 边界 386</h4><h4 id="15-10-通配符-389"><a href="#15-10-通配符-389" class="headerlink" title="15.10 通配符 389"></a>15.10 通配符 389</h4><h5 id="15-10-1-编译器有多聪明-391"><a href="#15-10-1-编译器有多聪明-391" class="headerlink" title="15.10.1 编译器有多聪明 391"></a>15.10.1 编译器有多聪明 391</h5><h5 id="15-10-2-逆变-393"><a href="#15-10-2-逆变-393" class="headerlink" title="15.10.2 逆变 393"></a>15.10.2 逆变 393</h5><h5 id="15-10-3-无界通配符-395"><a href="#15-10-3-无界通配符-395" class="headerlink" title="15.10.3 无界通配符 395"></a>15.10.3 无界通配符 395</h5><h5 id="15-10-4-捕获转换-399"><a href="#15-10-4-捕获转换-399" class="headerlink" title="15.10.4 捕获转换 399"></a>15.10.4 捕获转换 399</h5><h4 id="15-11-问题-400"><a href="#15-11-问题-400" class="headerlink" title="15.11 问题 400"></a>15.11 问题 400</h4><h5 id="15-11-1-任何基本类型都不能作为类型参数-400"><a href="#15-11-1-任何基本类型都不能作为类型参数-400" class="headerlink" title="15.11.1 任何基本类型都不能作为类型参数 400"></a>15.11.1 任何基本类型都不能作为类型参数 400</h5><h5 id="15-11-2-实现参数化接口-401"><a href="#15-11-2-实现参数化接口-401" class="headerlink" title="15.11.2 实现参数化接口 401"></a>15.11.2 实现参数化接口 401</h5><h5 id="15-11-3-转型和警告-402"><a href="#15-11-3-转型和警告-402" class="headerlink" title="15.11.3 转型和警告 402"></a>15.11.3 转型和警告 402</h5><h5 id="15-11-4-重载-403"><a href="#15-11-4-重载-403" class="headerlink" title="15.11.4 重载 403"></a>15.11.4 重载 403</h5><h5 id="15-11-5-基类劫持了接口-404"><a href="#15-11-5-基类劫持了接口-404" class="headerlink" title="15.11.5 基类劫持了接口 404"></a>15.11.5 基类劫持了接口 404</h5><h4 id="15-12-自限定的类型-404"><a href="#15-12-自限定的类型-404" class="headerlink" title="15.12 自限定的类型 404"></a>15.12 自限定的类型 404</h4><h5 id="15-12-1-古怪的循环泛型-404"><a href="#15-12-1-古怪的循环泛型-404" class="headerlink" title="15.12.1 古怪的循环泛型 404"></a>15.12.1 古怪的循环泛型 404</h5><h5 id="15-12-2-自限定-405"><a href="#15-12-2-自限定-405" class="headerlink" title="15.12.2 自限定 405"></a>15.12.2 自限定 405</h5><h5 id="15-12-3-参数协变-407"><a href="#15-12-3-参数协变-407" class="headerlink" title="15.12.3 参数协变 407"></a>15.12.3 参数协变 407</h5><h4 id="15-13-动态类型安全-409"><a href="#15-13-动态类型安全-409" class="headerlink" title="15.13 动态类型安全 409"></a>15.13 动态类型安全 409</h4><h4 id="15-14-异常-410"><a href="#15-14-异常-410" class="headerlink" title="15.14 异常 410"></a>15.14 异常 410</h4><h4 id="15-15-混型-412"><a href="#15-15-混型-412" class="headerlink" title="15.15 混型 412"></a>15.15 混型 412</h4><h5 id="15-15-1-C-中的混型-412"><a href="#15-15-1-C-中的混型-412" class="headerlink" title="15.15.1 C++中的混型 412"></a>15.15.1 C++中的混型 412</h5><h5 id="15-15-2-与接口混合-413"><a href="#15-15-2-与接口混合-413" class="headerlink" title="15.15.2 与接口混合 413"></a>15.15.2 与接口混合 413</h5><h5 id="15-15-3-使用装饰器模式-414"><a href="#15-15-3-使用装饰器模式-414" class="headerlink" title="15.15.3 使用装饰器模式 414"></a>15.15.3 使用装饰器模式 414</h5><h5 id="15-15-4-与动态代理混合-415"><a href="#15-15-4-与动态代理混合-415" class="headerlink" title="15.15.4 与动态代理混合 415"></a>15.15.4 与动态代理混合 415</h5><h4 id="15-16-潜在类型机制-416"><a href="#15-16-潜在类型机制-416" class="headerlink" title="15.16 潜在类型机制 416"></a>15.16 潜在类型机制 416</h4><h4 id="15-17-对缺乏潜在类型机制的补偿-420"><a href="#15-17-对缺乏潜在类型机制的补偿-420" class="headerlink" title="15.17 对缺乏潜在类型机制的补偿 420"></a>15.17 对缺乏潜在类型机制的补偿 420</h4><h5 id="15-17-1-反射-420"><a href="#15-17-1-反射-420" class="headerlink" title="15.17.1 反射 420"></a>15.17.1 反射 420</h5><h5 id="15-17-2-将一个方法应用于序列-421"><a href="#15-17-2-将一个方法应用于序列-421" class="headerlink" title="15.17.2 将一个方法应用于序列 421"></a>15.17.2 将一个方法应用于序列 421</h5><h5 id="15-17-3-当你并未碰巧拥有正确的接口时-423"><a href="#15-17-3-当你并未碰巧拥有正确的接口时-423" class="headerlink" title="15.17.3 当你并未碰巧拥有正确的接口时 423"></a>15.17.3 当你并未碰巧拥有正确的接口时 423</h5><h5 id="15-17-4-用适配器仿真潜在类型机制-424"><a href="#15-17-4-用适配器仿真潜在类型机制-424" class="headerlink" title="15.17.4 用适配器仿真潜在类型机制 424"></a>15.17.4 用适配器仿真潜在类型机制 424</h5><h4 id="15-18-将函数对象用作策略-426"><a href="#15-18-将函数对象用作策略-426" class="headerlink" title="15.18 将函数对象用作策略 426"></a>15.18 将函数对象用作策略 426</h4><h4 id="15-19-总结：转型真的如此之糟吗？-430"><a href="#15-19-总结：转型真的如此之糟吗？-430" class="headerlink" title="15.19 总结：转型真的如此之糟吗？ 430"></a>15.19 总结：转型真的如此之糟吗？ 430</h4><h5 id="15-19-1-进阶读物-432"><a href="#15-19-1-进阶读物-432" class="headerlink" title="15.19.1 进阶读物 432"></a>15.19.1 进阶读物 432</h5><hr><blockquote></blockquote><h3 id="第16章-数组-433"><a href="#第16章-数组-433" class="headerlink" title="第16章 数组 433"></a>第16章 数组 433</h3><h4 id="16-1-数组为什么特殊-433"><a href="#16-1-数组为什么特殊-433" class="headerlink" title="16.1 数组为什么特殊 433"></a>16.1 数组为什么特殊 433</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190909095333.png" alt=""></p><h4 id="16-2-数组是第一级对象-434"><a href="#16-2-数组是第一级对象-434" class="headerlink" title="16.2 数组是第一级对象 434"></a>16.2 数组是第一级对象 434</h4><blockquote><p>对象数组保存的是引用，基本类型数组直接保存值</p></blockquote><h4 id="16-3-返回一个数组-436"><a href="#16-3-返回一个数组-436" class="headerlink" title="16.3 返回一个数组 436"></a>16.3 返回一个数组 436</h4><h4 id="16-4-多维数组-437"><a href="#16-4-多维数组-437" class="headerlink" title="16.4 多维数组 437"></a>16.4 多维数组 437</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.deepToString()方法可以打印数组为字符串</span><br></pre></td></tr></table></figure><h4 id="16-5-数组与泛型-440"><a href="#16-5-数组与泛型-440" class="headerlink" title="16.5 数组与泛型 440"></a>16.5 数组与泛型 440</h4><h4 id="16-6-创建测试数据-442"><a href="#16-6-创建测试数据-442" class="headerlink" title="16.6 创建测试数据 442"></a>16.6 创建测试数据 442</h4><h5 id="16-6-1-Arrays-fill-442"><a href="#16-6-1-Arrays-fill-442" class="headerlink" title="16.6.1 Arrays.fill() 442"></a>16.6.1 Arrays.fill() 442</h5><blockquote><p>同一个值填充数组</p></blockquote><h5 id="16-6-2-数据生成器-443"><a href="#16-6-2-数据生成器-443" class="headerlink" title="16.6.2 数据生成器 443"></a>16.6.2 数据生成器 443</h5><h5 id="16-6-3-从Generator中创建数组-447"><a href="#16-6-3-从Generator中创建数组-447" class="headerlink" title="16.6.3 从Generator中创建数组 447"></a>16.6.3 从Generator中创建数组 447</h5><h4 id="16-7-Arrays实用功能-450"><a href="#16-7-Arrays实用功能-450" class="headerlink" title="16.7 Arrays实用功能 450"></a>16.7 Arrays实用功能 450</h4><h5 id="16-7-1-复制数组-450"><a href="#16-7-1-复制数组-450" class="headerlink" title="16.7.1 复制数组 450"></a>16.7.1 复制数组 450</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy() 复制数组  比<span class="keyword">for</span>循环要快  对于对象数组，复制属于浅复制（只复制引用）</span><br></pre></td></tr></table></figure><h5 id="16-7-2-数组的比较-451"><a href="#16-7-2-数组的比较-451" class="headerlink" title="16.7.2 数组的比较 451"></a>16.7.2 数组的比较 451</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.equals()</span><br></pre></td></tr></table></figure><h5 id="16-7-3-数组元素的比较-452"><a href="#16-7-3-数组元素的比较-452" class="headerlink" title="16.7.3 数组元素的比较 452"></a>16.7.3 数组元素的比较 452</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现java.lang.Comparable接口</span><br></pre></td></tr></table></figure><h5 id="16-7-4-数组排序-454"><a href="#16-7-4-数组排序-454" class="headerlink" title="16.7.4 数组排序 454"></a>16.7.4 数组排序 454</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort()</span><br></pre></td></tr></table></figure><h5 id="16-7-5-在已排序的数组中查找-455"><a href="#16-7-5-在已排序的数组中查找-455" class="headerlink" title="16.7.5 在已排序的数组中查找 455"></a>16.7.5 在已排序的数组中查找 455</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在已排序的数组中查找，使用Arrays.binarySearch()</span><br></pre></td></tr></table></figure><h4 id="16-8-总结-457"><a href="#16-8-总结-457" class="headerlink" title="16.8 总结 457"></a>16.8 总结 457</h4><hr><blockquote></blockquote><h3 id="第17章-容器深入研究-459"><a href="#第17章-容器深入研究-459" class="headerlink" title="第17章 容器深入研究 459"></a>第17章 容器深入研究 459</h3><h4 id="17-1-完整的容器分类法-459"><a href="#17-1-完整的容器分类法-459" class="headerlink" title="17.1 完整的容器分类法 459"></a>17.1 完整的容器分类法 459</h4><h4 id="17-2-填充容器-460"><a href="#17-2-填充容器-460" class="headerlink" title="17.2 填充容器 460"></a>17.2 填充容器 460</h4><h5 id="17-2-1-一种Generator解决方案-460"><a href="#17-2-1-一种Generator解决方案-460" class="headerlink" title="17.2.1 一种Generator解决方案 460"></a>17.2.1 一种Generator解决方案 460</h5><h5 id="17-2-2-Map生成器-462"><a href="#17-2-2-Map生成器-462" class="headerlink" title="17.2.2 Map生成器 462"></a>17.2.2 Map生成器 462</h5><h5 id="17-2-3-使用Abstract类-464"><a href="#17-2-3-使用Abstract类-464" class="headerlink" title="17.2.3 使用Abstract类 464"></a>17.2.3 使用Abstract类 464</h5><h4 id="17-3-Collection的功能方法-470"><a href="#17-3-Collection的功能方法-470" class="headerlink" title="17.3 Collection的功能方法 470"></a>17.3 Collection的功能方法 470</h4><h4 id="17-4-可选操作-472"><a href="#17-4-可选操作-472" class="headerlink" title="17.4 可选操作 472"></a>17.4 可选操作 472</h4><h5 id="17-4-1-未获支持的操作-473"><a href="#17-4-1-未获支持的操作-473" class="headerlink" title="17.4.1 未获支持的操作 473"></a>17.4.1 未获支持的操作 473</h5><h4 id="17-5-List的功能方法-474"><a href="#17-5-List的功能方法-474" class="headerlink" title="17.5 List的功能方法 474"></a>17.5 List的功能方法 474</h4><h4 id="17-6-Set和存储顺序-477"><a href="#17-6-Set和存储顺序-477" class="headerlink" title="17.6 Set和存储顺序 477"></a>17.6 Set和存储顺序 477</h4><h5 id="17-6-1-SortedSet-479"><a href="#17-6-1-SortedSet-479" class="headerlink" title="17.6.1 SortedSet 479"></a>17.6.1 SortedSet 479</h5><h4 id="17-7-队列-480"><a href="#17-7-队列-480" class="headerlink" title="17.7 队列 480"></a>17.7 队列 480</h4><h5 id="17-7-1-优先级队列-481"><a href="#17-7-1-优先级队列-481" class="headerlink" title="17.7.1 优先级队列 481"></a>17.7.1 优先级队列 481</h5><h5 id="17-7-2-双向队列-482"><a href="#17-7-2-双向队列-482" class="headerlink" title="17.7.2 双向队列 482"></a>17.7.2 双向队列 482</h5><h4 id="17-8-理解Map-483"><a href="#17-8-理解Map-483" class="headerlink" title="17.8 理解Map 483"></a>17.8 理解Map 483</h4><h5 id="17-8-1-性能-484"><a href="#17-8-1-性能-484" class="headerlink" title="17.8.1 性能 484"></a>17.8.1 性能 484</h5><h5 id="17-8-2-SortedMap-486"><a href="#17-8-2-SortedMap-486" class="headerlink" title="17.8.2 SortedMap 486"></a>17.8.2 SortedMap 486</h5><h5 id="17-8-3-LinkedHashMap-487"><a href="#17-8-3-LinkedHashMap-487" class="headerlink" title="17.8.3 LinkedHashMap 487"></a>17.8.3 LinkedHashMap 487</h5><h4 id="17-9-散列与散列码-488"><a href="#17-9-散列与散列码-488" class="headerlink" title="17.9 散列与散列码 488"></a>17.9 散列与散列码 488</h4><h5 id="17-9-1-理解hashCode-490"><a href="#17-9-1-理解hashCode-490" class="headerlink" title="17.9.1 理解hashCode() 490"></a>17.9.1 理解hashCode() 490</h5><h5 id="17-9-2-为速度而散列-492"><a href="#17-9-2-为速度而散列-492" class="headerlink" title="17.9.2 为速度而散列 492"></a>17.9.2 为速度而散列 492</h5><h5 id="17-9-3-覆盖hashCode-495"><a href="#17-9-3-覆盖hashCode-495" class="headerlink" title="17.9.3 覆盖hashCode() 495"></a>17.9.3 覆盖hashCode() 495</h5><h4 id="17-10-选择接口的不同实现-499"><a href="#17-10-选择接口的不同实现-499" class="headerlink" title="17.10 选择接口的不同实现 499"></a>17.10 选择接口的不同实现 499</h4><h5 id="17-10-1-性能测试框架-499"><a href="#17-10-1-性能测试框架-499" class="headerlink" title="17.10.1 性能测试框架 499"></a>17.10.1 性能测试框架 499</h5><h5 id="17-10-2-对List的选择-502"><a href="#17-10-2-对List的选择-502" class="headerlink" title="17.10.2 对List的选择 502"></a>17.10.2 对List的选择 502</h5><h5 id="17-10-3-微基准测试的危险-507"><a href="#17-10-3-微基准测试的危险-507" class="headerlink" title="17.10.3 微基准测试的危险 507"></a>17.10.3 微基准测试的危险 507</h5><h5 id="17-10-4-对Set的选择-508"><a href="#17-10-4-对Set的选择-508" class="headerlink" title="17.10.4 对Set的选择 508"></a>17.10.4 对Set的选择 508</h5><h5 id="17-10-5-对Map的选择-509"><a href="#17-10-5-对Map的选择-509" class="headerlink" title="17.10.5 对Map的选择 509"></a>17.10.5 对Map的选择 509</h5><h4 id="17-11-实用方法-512"><a href="#17-11-实用方法-512" class="headerlink" title="17.11 实用方法 512"></a>17.11 实用方法 512</h4><h5 id="17-11-1-List的排序和查询-514"><a href="#17-11-1-List的排序和查询-514" class="headerlink" title="17.11.1 List的排序和查询 514"></a>17.11.1 List的排序和查询 514</h5><h5 id="17-11-2-设定Collection或Map为不可修改-515"><a href="#17-11-2-设定Collection或Map为不可修改-515" class="headerlink" title="17.11.2 设定Collection或Map为不可修改 515"></a>17.11.2 设定Collection或Map为不可修改 515</h5><h5 id="17-11-3-Collection或Map的同步控制-516"><a href="#17-11-3-Collection或Map的同步控制-516" class="headerlink" title="17.11.3 Collection或Map的同步控制 516"></a>17.11.3 Collection或Map的同步控制 516</h5><h4 id="17-12-持有引用-518"><a href="#17-12-持有引用-518" class="headerlink" title="17.12 持有引用 518"></a>17.12 持有引用 518</h4><h5 id="17-12-1-WeakHashMap-519"><a href="#17-12-1-WeakHashMap-519" class="headerlink" title="17.12.1 WeakHashMap 519"></a>17.12.1 WeakHashMap 519</h5><h4 id="17-13-Java-1-0-1-1-的容器-520"><a href="#17-13-Java-1-0-1-1-的容器-520" class="headerlink" title="17.13 Java 1.0/1.1 的容器 520"></a>17.13 Java 1.0/1.1 的容器 520</h4><h5 id="17-13-1-Vector-和-Enumeration-520"><a href="#17-13-1-Vector-和-Enumeration-520" class="headerlink" title="17.13.1 Vector 和 Enumeration 520"></a>17.13.1 Vector 和 Enumeration 520</h5><h5 id="17-13-2-Hashtable-521"><a href="#17-13-2-Hashtable-521" class="headerlink" title="17.13.2 Hashtable 521"></a>17.13.2 Hashtable 521</h5><h5 id="17-13-3-Stack-521"><a href="#17-13-3-Stack-521" class="headerlink" title="17.13.3 Stack 521"></a>17.13.3 Stack 521</h5><h5 id="17-13-4-BitSet-522"><a href="#17-13-4-BitSet-522" class="headerlink" title="17.13.4 BitSet 522"></a>17.13.4 BitSet 522</h5><h4 id="17-14-总结-524"><a href="#17-14-总结-524" class="headerlink" title="17.14 总结 524"></a>17.14 总结 524</h4><hr><blockquote></blockquote><h3 id="第18章-Java-I-O系统-525"><a href="#第18章-Java-I-O系统-525" class="headerlink" title="第18章 Java I/O系统 525"></a>第18章 Java I/O系统 525</h3><h4 id="18-1-File类-525"><a href="#18-1-File类-525" class="headerlink" title="18.1 File类 525"></a>18.1 File类 525</h4><h4 id="18-1-1-目录列表器-525"><a href="#18-1-1-目录列表器-525" class="headerlink" title="18.1.1 目录列表器 525"></a>18.1.1 目录列表器 525</h4><h4 id="18-1-2-目录实用工具-528"><a href="#18-1-2-目录实用工具-528" class="headerlink" title="18.1.2 目录实用工具 528"></a>18.1.2 目录实用工具 528</h4><h4 id="18-1-3-目录的检查及创建-532"><a href="#18-1-3-目录的检查及创建-532" class="headerlink" title="18.1.3 目录的检查及创建 532"></a>18.1.3 目录的检查及创建 532</h4><h4 id="18-2-输入和输出-533"><a href="#18-2-输入和输出-533" class="headerlink" title="18.2 输入和输出 533"></a>18.2 输入和输出 533</h4><h4 id="18-2-1-InputStream类型-534"><a href="#18-2-1-InputStream类型-534" class="headerlink" title="18.2.1 InputStream类型 534"></a>18.2.1 InputStream类型 534</h4><h4 id="18-2-2-OutputStream类型-535"><a href="#18-2-2-OutputStream类型-535" class="headerlink" title="18.2.2 OutputStream类型 535"></a>18.2.2 OutputStream类型 535</h4><h4 id="18-3-添加属性和有用的接口-535"><a href="#18-3-添加属性和有用的接口-535" class="headerlink" title="18.3 添加属性和有用的接口 535"></a>18.3 添加属性和有用的接口 535</h4><h4 id="18-3-1-通过FilterInputStream从InputStream"><a href="#18-3-1-通过FilterInputStream从InputStream" class="headerlink" title="18.3.1 通过FilterInputStream从InputStream"></a>18.3.1 通过FilterInputStream从InputStream</h4><h4 id="读取数据-535"><a href="#读取数据-535" class="headerlink" title="读取数据 535"></a>读取数据 535</h4><h4 id="18-3-2-通过FilterOutPutStream向Output"><a href="#18-3-2-通过FilterOutPutStream向Output" class="headerlink" title="18.3.2 通过FilterOutPutStream向Output-"></a>18.3.2 通过FilterOutPutStream向Output-</h4><h4 id="Stream写入-536"><a href="#Stream写入-536" class="headerlink" title="Stream写入 536"></a>Stream写入 536</h4><h4 id="18-4-Reader和Writer-537"><a href="#18-4-Reader和Writer-537" class="headerlink" title="18.4 Reader和Writer 537"></a>18.4 Reader和Writer 537</h4><h4 id="18-4-1-数据的来源和去处-537"><a href="#18-4-1-数据的来源和去处-537" class="headerlink" title="18.4.1 数据的来源和去处 537"></a>18.4.1 数据的来源和去处 537</h4><h4 id="18-4-2-更改流的行为-538"><a href="#18-4-2-更改流的行为-538" class="headerlink" title="18.4.2 更改流的行为 538"></a>18.4.2 更改流的行为 538</h4><h4 id="18-4-3-未发生变化的类-539"><a href="#18-4-3-未发生变化的类-539" class="headerlink" title="18.4.3 未发生变化的类 539"></a>18.4.3 未发生变化的类 539</h4><h4 id="18-5-自我独立的类：RandomAccessFile-539"><a href="#18-5-自我独立的类：RandomAccessFile-539" class="headerlink" title="18.5 自我独立的类：RandomAccessFile 539"></a>18.5 自我独立的类：RandomAccessFile 539</h4><h4 id="18-6-I-O流的典型使用方式-539"><a href="#18-6-I-O流的典型使用方式-539" class="headerlink" title="18.6 I/O流的典型使用方式 539"></a>18.6 I/O流的典型使用方式 539</h4><h4 id="18-6-1-缓冲输入文件-540"><a href="#18-6-1-缓冲输入文件-540" class="headerlink" title="18.6.1 缓冲输入文件 540"></a>18.6.1 缓冲输入文件 540</h4><h4 id="18-6-2-从内存输入-540"><a href="#18-6-2-从内存输入-540" class="headerlink" title="18.6.2 从内存输入 540"></a>18.6.2 从内存输入 540</h4><h4 id="18-6-3-格式化的内存输入-541"><a href="#18-6-3-格式化的内存输入-541" class="headerlink" title="18.6.3 格式化的内存输入 541"></a>18.6.3 格式化的内存输入 541</h4><h4 id="18-6-4-基本的文件输出-542"><a href="#18-6-4-基本的文件输出-542" class="headerlink" title="18.6.4 基本的文件输出 542"></a>18.6.4 基本的文件输出 542</h4><h4 id="18-6-5-存储和恢复数据-543"><a href="#18-6-5-存储和恢复数据-543" class="headerlink" title="18.6.5 存储和恢复数据 543"></a>18.6.5 存储和恢复数据 543</h4><h4 id="18-6-6-读写随机访问文件-544"><a href="#18-6-6-读写随机访问文件-544" class="headerlink" title="18.6.6 读写随机访问文件 544"></a>18.6.6 读写随机访问文件 544</h4><h4 id="18-6-7-管道流-545"><a href="#18-6-7-管道流-545" class="headerlink" title="18.6.7 管道流 545"></a>18.6.7 管道流 545</h4><h4 id="18-7-文件读写的实用工具-545"><a href="#18-7-文件读写的实用工具-545" class="headerlink" title="18.7 文件读写的实用工具 545"></a>18.7 文件读写的实用工具 545</h4><h4 id="18-7-1-读取二进制文件-548"><a href="#18-7-1-读取二进制文件-548" class="headerlink" title="18.7.1 读取二进制文件 548"></a>18.7.1 读取二进制文件 548</h4><h4 id="18-8-标准I-O-548"><a href="#18-8-标准I-O-548" class="headerlink" title="18.8 标准I/O 548"></a>18.8 标准I/O 548</h4><h4 id="18-8-1-从标准输入中读取-548"><a href="#18-8-1-从标准输入中读取-548" class="headerlink" title="18.8.1 从标准输入中读取 548"></a>18.8.1 从标准输入中读取 548</h4><h4 id="18-8-2-将System-out转换成PrintWriter-549"><a href="#18-8-2-将System-out转换成PrintWriter-549" class="headerlink" title="18.8.2 将System.out转换成PrintWriter 549"></a>18.8.2 将System.out转换成PrintWriter 549</h4><h4 id="18-8-3-标准I-O重定向-549"><a href="#18-8-3-标准I-O重定向-549" class="headerlink" title="18.8.3 标准I/O重定向 549"></a>18.8.3 标准I/O重定向 549</h4><h4 id="18-9-进程控制-550"><a href="#18-9-进程控制-550" class="headerlink" title="18.9 进程控制 550"></a>18.9 进程控制 550</h4><h4 id="18-10-新I-O-551"><a href="#18-10-新I-O-551" class="headerlink" title="18.10 新I/O 551"></a>18.10 新I/O 551</h4><h4 id="18-10-1-转换数据-554"><a href="#18-10-1-转换数据-554" class="headerlink" title="18.10.1 转换数据 554"></a>18.10.1 转换数据 554</h4><h4 id="18-10-2-获取基本类型-556"><a href="#18-10-2-获取基本类型-556" class="headerlink" title="18.10.2 获取基本类型 556"></a>18.10.2 获取基本类型 556</h4><h4 id="18-10-3-视图缓冲器-557"><a href="#18-10-3-视图缓冲器-557" class="headerlink" title="18.10.3 视图缓冲器 557"></a>18.10.3 视图缓冲器 557</h4><h4 id="18-10-4-用缓冲器操纵数据-560"><a href="#18-10-4-用缓冲器操纵数据-560" class="headerlink" title="18.10.4 用缓冲器操纵数据 560"></a>18.10.4 用缓冲器操纵数据 560</h4><h4 id="18-10-5-缓冲器的细节-560"><a href="#18-10-5-缓冲器的细节-560" class="headerlink" title="18.10.5 缓冲器的细节 560"></a>18.10.5 缓冲器的细节 560</h4><h4 id="18-10-6-内存映射文件-563"><a href="#18-10-6-内存映射文件-563" class="headerlink" title="18.10.6 内存映射文件 563"></a>18.10.6 内存映射文件 563</h4><h4 id="18-10-7-文件加锁-566"><a href="#18-10-7-文件加锁-566" class="headerlink" title="18.10.7 文件加锁 566"></a>18.10.7 文件加锁 566</h4><h4 id="18-11-压缩-568"><a href="#18-11-压缩-568" class="headerlink" title="18.11 压缩 568"></a>18.11 压缩 568</h4><h4 id="18-11-1-用GZIP进行简单压缩-568"><a href="#18-11-1-用GZIP进行简单压缩-568" class="headerlink" title="18.11.1 用GZIP进行简单压缩 568"></a>18.11.1 用GZIP进行简单压缩 568</h4><h4 id="18-11-2-用Zip进行多文件保存-569"><a href="#18-11-2-用Zip进行多文件保存-569" class="headerlink" title="18.11.2 用Zip进行多文件保存 569"></a>18.11.2 用Zip进行多文件保存 569</h4><h4 id="18-11-3-Java档案文件-570"><a href="#18-11-3-Java档案文件-570" class="headerlink" title="18.11.3 Java档案文件 570"></a>18.11.3 Java档案文件 570</h4><h4 id="18-12-对象序列化-571"><a href="#18-12-对象序列化-571" class="headerlink" title="18.12 对象序列化 571"></a>18.12 对象序列化 571</h4><h4 id="18-12-1-寻找类-574"><a href="#18-12-1-寻找类-574" class="headerlink" title="18.12.1 寻找类 574"></a>18.12.1 寻找类 574</h4><h4 id="18-12-2-序列化的控制-575"><a href="#18-12-2-序列化的控制-575" class="headerlink" title="18.12.2 序列化的控制 575"></a>18.12.2 序列化的控制 575</h4><h4 id="18-12-3-使用“持久性”-581"><a href="#18-12-3-使用“持久性”-581" class="headerlink" title="18.12.3 使用“持久性” 581"></a>18.12.3 使用“持久性” 581</h4><h4 id="18-13-XML-586"><a href="#18-13-XML-586" class="headerlink" title="18.13 XML 586"></a>18.13 XML 586</h4><h4 id="18-14-Preferences-588"><a href="#18-14-Preferences-588" class="headerlink" title="18.14 Preferences 588"></a>18.14 Preferences 588</h4><h4 id="18-15-总结-589"><a href="#18-15-总结-589" class="headerlink" title="18.15 总结 589"></a>18.15 总结 589</h4><hr><blockquote></blockquote><h3 id="第19章-枚举类型-590"><a href="#第19章-枚举类型-590" class="headerlink" title="第19章 枚举类型 590"></a>第19章 枚举类型 590</h3><h4 id="19-1-基本enum特性-590"><a href="#19-1-基本enum特性-590" class="headerlink" title="19.1 基本enum特性 590"></a>19.1 基本enum特性 590</h4><h4 id="19-1-1-将静态导入用于enum-591"><a href="#19-1-1-将静态导入用于enum-591" class="headerlink" title="19.1.1 将静态导入用于enum 591"></a>19.1.1 将静态导入用于enum 591</h4><h4 id="19-2-向enum中添加新方法-591"><a href="#19-2-向enum中添加新方法-591" class="headerlink" title="19.2 向enum中添加新方法 591"></a>19.2 向enum中添加新方法 591</h4><h4 id="19-2-1-覆盖enum的方法-592"><a href="#19-2-1-覆盖enum的方法-592" class="headerlink" title="19.2.1 覆盖enum的方法 592"></a>19.2.1 覆盖enum的方法 592</h4><h4 id="19-3-switch语句中的enum-593"><a href="#19-3-switch语句中的enum-593" class="headerlink" title="19.3 switch语句中的enum 593"></a>19.3 switch语句中的enum 593</h4><h4 id="19-4-values-的神秘之处-594"><a href="#19-4-values-的神秘之处-594" class="headerlink" title="19.4 values()的神秘之处 594"></a>19.4 values()的神秘之处 594</h4><h4 id="19-5-实现，而非继承-596"><a href="#19-5-实现，而非继承-596" class="headerlink" title="19.5 实现，而非继承 596"></a>19.5 实现，而非继承 596</h4><h4 id="19-6-随机选取-596"><a href="#19-6-随机选取-596" class="headerlink" title="19.6 随机选取 596"></a>19.6 随机选取 596</h4><h4 id="19-7-使用接口组织枚举-597"><a href="#19-7-使用接口组织枚举-597" class="headerlink" title="19.7 使用接口组织枚举 597"></a>19.7 使用接口组织枚举 597</h4><h4 id="19-8-使用EnumSet替代标志-600"><a href="#19-8-使用EnumSet替代标志-600" class="headerlink" title="19.8 使用EnumSet替代标志 600"></a>19.8 使用EnumSet替代标志 600</h4><h4 id="19-9-使用EnumMap-602"><a href="#19-9-使用EnumMap-602" class="headerlink" title="19.9 使用EnumMap 602"></a>19.9 使用EnumMap 602</h4><h4 id="19-10-常量相关的方法-603"><a href="#19-10-常量相关的方法-603" class="headerlink" title="19.10 常量相关的方法 603"></a>19.10 常量相关的方法 603</h4><h4 id="19-10-1-使用enum的职责链-606"><a href="#19-10-1-使用enum的职责链-606" class="headerlink" title="19.10.1 使用enum的职责链 606"></a>19.10.1 使用enum的职责链 606</h4><h4 id="19-10-2-使用enum的状态机-609"><a href="#19-10-2-使用enum的状态机-609" class="headerlink" title="19.10.2 使用enum的状态机 609"></a>19.10.2 使用enum的状态机 609</h4><h4 id="19-11-多路分发-613"><a href="#19-11-多路分发-613" class="headerlink" title="19.11 多路分发 613"></a>19.11 多路分发 613</h4><h4 id="19-11-1-使用enum分发-615"><a href="#19-11-1-使用enum分发-615" class="headerlink" title="19.11.1 使用enum分发 615"></a>19.11.1 使用enum分发 615</h4><h4 id="19-11-2-使用常量相关的方法-616"><a href="#19-11-2-使用常量相关的方法-616" class="headerlink" title="19.11.2 使用常量相关的方法 616"></a>19.11.2 使用常量相关的方法 616</h4><h4 id="19-11-3-使用EnumMap分发-618"><a href="#19-11-3-使用EnumMap分发-618" class="headerlink" title="19.11.3 使用EnumMap分发 618"></a>19.11.3 使用EnumMap分发 618</h4><h4 id="19-11-4-使用二维数组-618"><a href="#19-11-4-使用二维数组-618" class="headerlink" title="19.11.4 使用二维数组 618"></a>19.11.4 使用二维数组 618</h4><h4 id="19-12-总结-619"><a href="#19-12-总结-619" class="headerlink" title="19.12 总结 619"></a>19.12 总结 619</h4><hr><blockquote></blockquote><h3 id="第20章-注解-620"><a href="#第20章-注解-620" class="headerlink" title="第20章 注解 620"></a>第20章 注解 620</h3><h4 id="20-1-基本语法-620"><a href="#20-1-基本语法-620" class="headerlink" title="20.1 基本语法 620"></a>20.1 基本语法 620</h4><h4 id="20-1-1-定义注解-621"><a href="#20-1-1-定义注解-621" class="headerlink" title="20.1.1 定义注解 621"></a>20.1.1 定义注解 621</h4><h4 id="20-1-2-元注解-622"><a href="#20-1-2-元注解-622" class="headerlink" title="20.1.2 元注解 622"></a>20.1.2 元注解 622</h4><h4 id="20-2-编写注解处理器-622"><a href="#20-2-编写注解处理器-622" class="headerlink" title="20.2 编写注解处理器 622"></a>20.2 编写注解处理器 622</h4><h4 id="20-2-1-注解元素-623"><a href="#20-2-1-注解元素-623" class="headerlink" title="20.2.1 注解元素 623"></a>20.2.1 注解元素 623</h4><h4 id="20-2-2-默认值限制-624"><a href="#20-2-2-默认值限制-624" class="headerlink" title="20.2.2 默认值限制 624"></a>20.2.2 默认值限制 624</h4><h4 id="20-2-3-生成外部文件-624"><a href="#20-2-3-生成外部文件-624" class="headerlink" title="20.2.3 生成外部文件 624"></a>20.2.3 生成外部文件 624</h4><h4 id="20-2-4-注解不支持继承-627"><a href="#20-2-4-注解不支持继承-627" class="headerlink" title="20.2.4 注解不支持继承 627"></a>20.2.4 注解不支持继承 627</h4><h4 id="20-2-5-实现处理器-627"><a href="#20-2-5-实现处理器-627" class="headerlink" title="20.2.5 实现处理器 627"></a>20.2.5 实现处理器 627</h4><h4 id="20-3-使用apt处理注解-629"><a href="#20-3-使用apt处理注解-629" class="headerlink" title="20.3 使用apt处理注解 629"></a>20.3 使用apt处理注解 629</h4><h4 id="20-4-将观察者模式用于apt-632"><a href="#20-4-将观察者模式用于apt-632" class="headerlink" title="20.4 将观察者模式用于apt 632"></a>20.4 将观察者模式用于apt 632</h4><h4 id="20-5-基于注解的单元测试-634"><a href="#20-5-基于注解的单元测试-634" class="headerlink" title="20.5 基于注解的单元测试 634"></a>20.5 基于注解的单元测试 634</h4><h4 id="20-5-1-将-Unit用于泛型-641"><a href="#20-5-1-将-Unit用于泛型-641" class="headerlink" title="20.5.1 将@Unit用于泛型 641"></a>20.5.1 将@Unit用于泛型 641</h4><h4 id="20-5-2-不需要任何“套件”-642"><a href="#20-5-2-不需要任何“套件”-642" class="headerlink" title="20.5.2 不需要任何“套件” 642"></a>20.5.2 不需要任何“套件” 642</h4><h4 id="20-5-3-实现-Unit-642"><a href="#20-5-3-实现-Unit-642" class="headerlink" title="20.5.3 实现@Unit 642"></a>20.5.3 实现@Unit 642</h4><h4 id="20-5-4-移除测试代码-647"><a href="#20-5-4-移除测试代码-647" class="headerlink" title="20.5.4 移除测试代码 647"></a>20.5.4 移除测试代码 647</h4><h4 id="20-6-总结-649"><a href="#20-6-总结-649" class="headerlink" title="20.6 总结 649"></a>20.6 总结 649</h4><hr><blockquote></blockquote><h3 id="第21章-并发-650"><a href="#第21章-并发-650" class="headerlink" title="第21章 并发 650"></a>第21章 并发 650</h3><h4 id="21-1-并发的多面性-651"><a href="#21-1-并发的多面性-651" class="headerlink" title="21.1 并发的多面性 651"></a>21.1 并发的多面性 651</h4><h4 id="21-1-1-更快的执行-651"><a href="#21-1-1-更快的执行-651" class="headerlink" title="21.1.1 更快的执行 651"></a>21.1.1 更快的执行 651</h4><h4 id="21-1-2-改进代码设计-653"><a href="#21-1-2-改进代码设计-653" class="headerlink" title="21.1.2 改进代码设计 653"></a>21.1.2 改进代码设计 653</h4><h4 id="21-2-基本的线程机制-653"><a href="#21-2-基本的线程机制-653" class="headerlink" title="21.2 基本的线程机制 653"></a>21.2 基本的线程机制 653</h4><h4 id="21-2-1-定义任务-654"><a href="#21-2-1-定义任务-654" class="headerlink" title="21.2.1 定义任务 654"></a>21.2.1 定义任务 654</h4><h4 id="21-2-2-Thread类-655"><a href="#21-2-2-Thread类-655" class="headerlink" title="21.2.2 Thread类 655"></a>21.2.2 Thread类 655</h4><h4 id="21-2-3-使用Executor-656"><a href="#21-2-3-使用Executor-656" class="headerlink" title="21.2.3 使用Executor 656"></a>21.2.3 使用Executor 656</h4><h4 id="21-2-4-从任务中产生返回值-658"><a href="#21-2-4-从任务中产生返回值-658" class="headerlink" title="21.2.4 从任务中产生返回值 658"></a>21.2.4 从任务中产生返回值 658</h4><h4 id="21-2-5-休眠-659"><a href="#21-2-5-休眠-659" class="headerlink" title="21.2.5 休眠 659"></a>21.2.5 休眠 659</h4><h4 id="21-2-6-优先级-660"><a href="#21-2-6-优先级-660" class="headerlink" title="21.2.6 优先级 660"></a>21.2.6 优先级 660</h4><h4 id="21-2-7-让步-661"><a href="#21-2-7-让步-661" class="headerlink" title="21.2.7 让步 661"></a>21.2.7 让步 661</h4><h4 id="21-2-8-后台线程-662"><a href="#21-2-8-后台线程-662" class="headerlink" title="21.2.8 后台线程 662"></a>21.2.8 后台线程 662</h4><h4 id="21-2-9-编码的变体-665"><a href="#21-2-9-编码的变体-665" class="headerlink" title="21.2.9 编码的变体 665"></a>21.2.9 编码的变体 665</h4><h4 id="21-2-10-术语-669"><a href="#21-2-10-术语-669" class="headerlink" title="21.2.10 术语 669"></a>21.2.10 术语 669</h4><h4 id="21-2-11-加入一个线程-669"><a href="#21-2-11-加入一个线程-669" class="headerlink" title="21.2.11 加入一个线程 669"></a>21.2.11 加入一个线程 669</h4><h4 id="21-2-12-创建有响应的用户界面-671"><a href="#21-2-12-创建有响应的用户界面-671" class="headerlink" title="21.2.12 创建有响应的用户界面 671"></a>21.2.12 创建有响应的用户界面 671</h4><h4 id="21-2-13-线程组-672"><a href="#21-2-13-线程组-672" class="headerlink" title="21.2.13 线程组 672"></a>21.2.13 线程组 672</h4><h4 id="21-2-14-捕获异常-672"><a href="#21-2-14-捕获异常-672" class="headerlink" title="21.2.14 捕获异常 672"></a>21.2.14 捕获异常 672</h4><h4 id="21-3-共享受限资源-674"><a href="#21-3-共享受限资源-674" class="headerlink" title="21.3 共享受限资源 674"></a>21.3 共享受限资源 674</h4><h4 id="21-3-1-不正确地访问资源-674"><a href="#21-3-1-不正确地访问资源-674" class="headerlink" title="21.3.1 不正确地访问资源 674"></a>21.3.1 不正确地访问资源 674</h4><h4 id="21-3-2-解决共享资源竞争-676"><a href="#21-3-2-解决共享资源竞争-676" class="headerlink" title="21.3.2 解决共享资源竞争 676"></a>21.3.2 解决共享资源竞争 676</h4><h4 id="21-3-3-原子性与易变性-680"><a href="#21-3-3-原子性与易变性-680" class="headerlink" title="21.3.3 原子性与易变性 680"></a>21.3.3 原子性与易变性 680</h4><h4 id="21-3-4-原子类-684"><a href="#21-3-4-原子类-684" class="headerlink" title="21.3.4 原子类 684"></a>21.3.4 原子类 684</h4><h4 id="21-3-5-临界区-685"><a href="#21-3-5-临界区-685" class="headerlink" title="21.3.5 临界区 685"></a>21.3.5 临界区 685</h4><h4 id="21-3-6-在其他对象上同步-689"><a href="#21-3-6-在其他对象上同步-689" class="headerlink" title="21.3.6 在其他对象上同步 689"></a>21.3.6 在其他对象上同步 689</h4><h4 id="21-3-7-线程本地存储-690"><a href="#21-3-7-线程本地存储-690" class="headerlink" title="21.3.7 线程本地存储 690"></a>21.3.7 线程本地存储 690</h4><h4 id="21-4-终结任务-691"><a href="#21-4-终结任务-691" class="headerlink" title="21.4 终结任务 691"></a>21.4 终结任务 691</h4><h4 id="21-4-1-装饰性花园-691"><a href="#21-4-1-装饰性花园-691" class="headerlink" title="21.4.1 装饰性花园 691"></a>21.4.1 装饰性花园 691</h4><h4 id="21-4-2-在阻塞时终结-694"><a href="#21-4-2-在阻塞时终结-694" class="headerlink" title="21.4.2 在阻塞时终结 694"></a>21.4.2 在阻塞时终结 694</h4><h4 id="21-4-3-中断-695"><a href="#21-4-3-中断-695" class="headerlink" title="21.4.3 中断 695"></a>21.4.3 中断 695</h4><h4 id="21-4-4-检查中断-701"><a href="#21-4-4-检查中断-701" class="headerlink" title="21.4.4 检查中断 701"></a>21.4.4 检查中断 701</h4><h4 id="21-5-线程之间的协作-702"><a href="#21-5-线程之间的协作-702" class="headerlink" title="21.5 线程之间的协作 702"></a>21.5 线程之间的协作 702</h4><h4 id="21-5-1-wait-与notifyAll-703"><a href="#21-5-1-wait-与notifyAll-703" class="headerlink" title="21.5.1 wait()与notifyAll() 703"></a>21.5.1 wait()与notifyAll() 703</h4><h4 id="21-5-2-notify-与notifyAll-707"><a href="#21-5-2-notify-与notifyAll-707" class="headerlink" title="21.5.2 notify()与notifyAll() 707"></a>21.5.2 notify()与notifyAll() 707</h4><h4 id="21-5-3-生产者与消费者-709"><a href="#21-5-3-生产者与消费者-709" class="headerlink" title="21.5.3 生产者与消费者 709"></a>21.5.3 生产者与消费者 709</h4><h4 id="21-5-4-生产者-消费者与队列-713"><a href="#21-5-4-生产者-消费者与队列-713" class="headerlink" title="21.5.4 生产者-消费者与队列 713"></a>21.5.4 生产者-消费者与队列 713</h4><h4 id="21-5-5-任务间使用管道进行输入-输出-717"><a href="#21-5-5-任务间使用管道进行输入-输出-717" class="headerlink" title="21.5.5 任务间使用管道进行输入/输出 717"></a>21.5.5 任务间使用管道进行输入/输出 717</h4><h4 id="21-6-死锁-718"><a href="#21-6-死锁-718" class="headerlink" title="21.6 死锁 718"></a>21.6 死锁 718</h4><h4 id="21-7-新类库中的构件-722"><a href="#21-7-新类库中的构件-722" class="headerlink" title="21.7 新类库中的构件 722"></a>21.7 新类库中的构件 722</h4><h4 id="21-7-1-CountDownLatch-722"><a href="#21-7-1-CountDownLatch-722" class="headerlink" title="21.7.1 CountDownLatch 722"></a>21.7.1 CountDownLatch 722</h4><h4 id="21-7-2-CyclicBarrier-724"><a href="#21-7-2-CyclicBarrier-724" class="headerlink" title="21.7.2 CyclicBarrier 724"></a>21.7.2 CyclicBarrier 724</h4><h4 id="21-7-3-DelayQueue-726"><a href="#21-7-3-DelayQueue-726" class="headerlink" title="21.7.3 DelayQueue 726"></a>21.7.3 DelayQueue 726</h4><h4 id="21-7-4-PriorityBlockingQueue-728"><a href="#21-7-4-PriorityBlockingQueue-728" class="headerlink" title="21.7.4 PriorityBlockingQueue 728"></a>21.7.4 PriorityBlockingQueue 728</h4><h4 id="21-7-5-使用ScheduledExecutor的温室控"><a href="#21-7-5-使用ScheduledExecutor的温室控" class="headerlink" title="21.7.5 使用ScheduledExecutor的温室控"></a>21.7.5 使用ScheduledExecutor的温室控</h4><h4 id="制器-730"><a href="#制器-730" class="headerlink" title="制器 730"></a>制器 730</h4><h4 id="21-7-6-Semaphore-733"><a href="#21-7-6-Semaphore-733" class="headerlink" title="21.7.6 Semaphore 733"></a>21.7.6 Semaphore 733</h4><h4 id="21-7-7-Exchanger-735"><a href="#21-7-7-Exchanger-735" class="headerlink" title="21.7.7 Exchanger 735"></a>21.7.7 Exchanger 735</h4><h4 id="21-8-仿真-737"><a href="#21-8-仿真-737" class="headerlink" title="21.8 仿真 737"></a>21.8 仿真 737</h4><h4 id="21-8-1-银行出纳员仿真-737"><a href="#21-8-1-银行出纳员仿真-737" class="headerlink" title="21.8.1 银行出纳员仿真 737"></a>21.8.1 银行出纳员仿真 737</h4><h4 id="21-8-2-饭店仿真-741"><a href="#21-8-2-饭店仿真-741" class="headerlink" title="21.8.2 饭店仿真 741"></a>21.8.2 饭店仿真 741</h4><h4 id="21-8-3-分发工作-744"><a href="#21-8-3-分发工作-744" class="headerlink" title="21.8.3 分发工作 744"></a>21.8.3 分发工作 744</h4><h4 id="21-9-性能调优-748"><a href="#21-9-性能调优-748" class="headerlink" title="21.9 性能调优 748"></a>21.9 性能调优 748</h4><h4 id="21-9-1-比较各类互斥技术-748"><a href="#21-9-1-比较各类互斥技术-748" class="headerlink" title="21.9.1 比较各类互斥技术 748"></a>21.9.1 比较各类互斥技术 748</h4><h4 id="21-9-2-免锁容器-754"><a href="#21-9-2-免锁容器-754" class="headerlink" title="21.9.2 免锁容器 754"></a>21.9.2 免锁容器 754</h4><h4 id="21-9-3-乐观加锁-760"><a href="#21-9-3-乐观加锁-760" class="headerlink" title="21.9.3 乐观加锁 760"></a>21.9.3 乐观加锁 760</h4><h4 id="21-9-4-ReadWriteLock-761"><a href="#21-9-4-ReadWriteLock-761" class="headerlink" title="21.9.4 ReadWriteLock 761"></a>21.9.4 ReadWriteLock 761</h4><h4 id="21-10-活动对象-763"><a href="#21-10-活动对象-763" class="headerlink" title="21.10 活动对象 763"></a>21.10 活动对象 763</h4><h4 id="21-11-总结-766"><a href="#21-11-总结-766" class="headerlink" title="21.11 总结 766"></a>21.11 总结 766</h4><h4 id="21-12-进阶读物-767"><a href="#21-12-进阶读物-767" class="headerlink" title="21.12 进阶读物 767"></a>21.12 进阶读物 767</h4><hr><blockquote></blockquote><h3 id="第22章-图形化用户界面-768"><a href="#第22章-图形化用户界面-768" class="headerlink" title="第22章 图形化用户界面 768"></a>第22章 图形化用户界面 768</h3><h4 id="22-1-applet-769"><a href="#22-1-applet-769" class="headerlink" title="22.1 applet 769"></a>22.1 applet 769</h4><h4 id="22-2-Swing基础-769"><a href="#22-2-Swing基础-769" class="headerlink" title="22.2 Swing基础 769"></a>22.2 Swing基础 769</h4><h4 id="22-2-1-一个显示框架-771"><a href="#22-2-1-一个显示框架-771" class="headerlink" title="22.2.1 一个显示框架 771"></a>22.2.1 一个显示框架 771</h4><h4 id="22-3-创建按钮-772"><a href="#22-3-创建按钮-772" class="headerlink" title="22.3 创建按钮 772"></a>22.3 创建按钮 772</h4><h4 id="22-4-捕获事件-773"><a href="#22-4-捕获事件-773" class="headerlink" title="22.4 捕获事件 773"></a>22.4 捕获事件 773</h4><h4 id="22-5-文本区域-774"><a href="#22-5-文本区域-774" class="headerlink" title="22.5 文本区域 774"></a>22.5 文本区域 774</h4><h4 id="22-6-控制布局-776"><a href="#22-6-控制布局-776" class="headerlink" title="22.6 控制布局 776"></a>22.6 控制布局 776</h4><h4 id="22-6-1-BorderLayout-776"><a href="#22-6-1-BorderLayout-776" class="headerlink" title="22.6.1 BorderLayout 776"></a>22.6.1 BorderLayout 776</h4><h4 id="22-6-2-FlowLayout-776"><a href="#22-6-2-FlowLayout-776" class="headerlink" title="22.6.2 FlowLayout 776"></a>22.6.2 FlowLayout 776</h4><h4 id="22-6-3-GridLayout-777"><a href="#22-6-3-GridLayout-777" class="headerlink" title="22.6.3 GridLayout 777"></a>22.6.3 GridLayout 777</h4><h4 id="22-6-4-GridBagLayout-777"><a href="#22-6-4-GridBagLayout-777" class="headerlink" title="22.6.4 GridBagLayout 777"></a>22.6.4 GridBagLayout 777</h4><h4 id="22-6-5-绝对定位-778"><a href="#22-6-5-绝对定位-778" class="headerlink" title="22.6.5 绝对定位 778"></a>22.6.5 绝对定位 778</h4><h4 id="22-6-6-BoxLayout-778"><a href="#22-6-6-BoxLayout-778" class="headerlink" title="22.6.6 BoxLayout 778"></a>22.6.6 BoxLayout 778</h4><h4 id="22-6-7-最好的方式是什么-778"><a href="#22-6-7-最好的方式是什么-778" class="headerlink" title="22.6.7 最好的方式是什么 778"></a>22.6.7 最好的方式是什么 778</h4><h4 id="22-7-Swing事件模型-778"><a href="#22-7-Swing事件模型-778" class="headerlink" title="22.7 Swing事件模型 778"></a>22.7 Swing事件模型 778</h4><h4 id="22-7-1-事件与监听器的类型-779"><a href="#22-7-1-事件与监听器的类型-779" class="headerlink" title="22.7.1 事件与监听器的类型 779"></a>22.7.1 事件与监听器的类型 779</h4><h4 id="22-7-2-跟踪多个事件-783"><a href="#22-7-2-跟踪多个事件-783" class="headerlink" title="22.7.2 跟踪多个事件 783"></a>22.7.2 跟踪多个事件 783</h4><h4 id="22-8-Swing组件一览-785"><a href="#22-8-Swing组件一览-785" class="headerlink" title="22.8 Swing组件一览 785"></a>22.8 Swing组件一览 785</h4><h4 id="22-8-1-按钮-785"><a href="#22-8-1-按钮-785" class="headerlink" title="22.8.1 按钮 785"></a>22.8.1 按钮 785</h4><h4 id="22-8-2-图标-787"><a href="#22-8-2-图标-787" class="headerlink" title="22.8.2 图标 787"></a>22.8.2 图标 787</h4><h4 id="22-8-3-工具提示-788"><a href="#22-8-3-工具提示-788" class="headerlink" title="22.8.3 工具提示 788"></a>22.8.3 工具提示 788</h4><h4 id="22-8-4-文本域-789"><a href="#22-8-4-文本域-789" class="headerlink" title="22.8.4 文本域 789"></a>22.8.4 文本域 789</h4><h4 id="22-8-5-边框-790"><a href="#22-8-5-边框-790" class="headerlink" title="22.8.5 边框 790"></a>22.8.5 边框 790</h4><h4 id="22-8-6-一个迷你编辑器-791"><a href="#22-8-6-一个迷你编辑器-791" class="headerlink" title="22.8.6 一个迷你编辑器 791"></a>22.8.6 一个迷你编辑器 791</h4><h4 id="22-8-7-复选框-792"><a href="#22-8-7-复选框-792" class="headerlink" title="22.8.7 复选框 792"></a>22.8.7 复选框 792</h4><h4 id="22-8-8-单选按钮-793"><a href="#22-8-8-单选按钮-793" class="headerlink" title="22.8.8 单选按钮 793"></a>22.8.8 单选按钮 793</h4><h4 id="22-8-9-组合框-793"><a href="#22-8-9-组合框-793" class="headerlink" title="22.8.9 组合框 793"></a>22.8.9 组合框 793</h4><h4 id="22-8-10-列表框-794"><a href="#22-8-10-列表框-794" class="headerlink" title="22.8.10 列表框 794"></a>22.8.10 列表框 794</h4><h4 id="22-8-11-页签面板-796"><a href="#22-8-11-页签面板-796" class="headerlink" title="22.8.11 页签面板 796"></a>22.8.11 页签面板 796</h4><h4 id="22-8-12-消息框-796"><a href="#22-8-12-消息框-796" class="headerlink" title="22.8.12 消息框 796"></a>22.8.12 消息框 796</h4><h4 id="22-8-13-菜单-798"><a href="#22-8-13-菜单-798" class="headerlink" title="22.8.13 菜单 798"></a>22.8.13 菜单 798</h4><h4 id="22-8-14-弹出式菜单-802"><a href="#22-8-14-弹出式菜单-802" class="headerlink" title="22.8.14 弹出式菜单 802"></a>22.8.14 弹出式菜单 802</h4><h4 id="22-8-15-绘图-803"><a href="#22-8-15-绘图-803" class="headerlink" title="22.8.15 绘图 803"></a>22.8.15 绘图 803</h4><h4 id="22-8-16-对话框-805"><a href="#22-8-16-对话框-805" class="headerlink" title="22.8.16 对话框 805"></a>22.8.16 对话框 805</h4><h4 id="22-8-17-文件对话框-808"><a href="#22-8-17-文件对话框-808" class="headerlink" title="22.8.17 文件对话框 808"></a>22.8.17 文件对话框 808</h4><h4 id="22-8-18-Swing组件上的HTML-809"><a href="#22-8-18-Swing组件上的HTML-809" class="headerlink" title="22.8.18 Swing组件上的HTML 809"></a>22.8.18 Swing组件上的HTML 809</h4><h4 id="22-8-19-滑块与进度条-810"><a href="#22-8-19-滑块与进度条-810" class="headerlink" title="22.8.19 滑块与进度条 810"></a>22.8.19 滑块与进度条 810</h4><h4 id="22-8-20-选择外观-811"><a href="#22-8-20-选择外观-811" class="headerlink" title="22.8.20 选择外观 811"></a>22.8.20 选择外观 811</h4><h4 id="22-8-21-树、表格和剪贴板-812"><a href="#22-8-21-树、表格和剪贴板-812" class="headerlink" title="22.8.21 树、表格和剪贴板 812"></a>22.8.21 树、表格和剪贴板 812</h4><h4 id="22-9-JNLP与Java-Web-Start-812"><a href="#22-9-JNLP与Java-Web-Start-812" class="headerlink" title="22.9 JNLP与Java Web Start 812"></a>22.9 JNLP与Java Web Start 812</h4><h4 id="22-10-Swing与并发-816"><a href="#22-10-Swing与并发-816" class="headerlink" title="22.10 Swing与并发 816"></a>22.10 Swing与并发 816</h4><h4 id="22-10-1-长期运行的任务-816"><a href="#22-10-1-长期运行的任务-816" class="headerlink" title="22.10.1 长期运行的任务 816"></a>22.10.1 长期运行的任务 816</h4><h4 id="22-10-2-可视化线程机制-822"><a href="#22-10-2-可视化线程机制-822" class="headerlink" title="22.10.2 可视化线程机制 822"></a>22.10.2 可视化线程机制 822</h4><h4 id="22-11-可视化编程与JavaBean-823"><a href="#22-11-可视化编程与JavaBean-823" class="headerlink" title="22.11 可视化编程与JavaBean 823"></a>22.11 可视化编程与JavaBean 823</h4><h4 id="22-11-1-JavaBean是什么-824"><a href="#22-11-1-JavaBean是什么-824" class="headerlink" title="22.11.1 JavaBean是什么 824"></a>22.11.1 JavaBean是什么 824</h4><h4 id="22-11-2-使用Introspector抽取出BeanInfo-825"><a href="#22-11-2-使用Introspector抽取出BeanInfo-825" class="headerlink" title="22.11.2 使用Introspector抽取出BeanInfo 825"></a>22.11.2 使用Introspector抽取出BeanInfo 825</h4><h4 id="22-11-3-一个更复杂的Bean-829"><a href="#22-11-3-一个更复杂的Bean-829" class="headerlink" title="22.11.3 一个更复杂的Bean 829"></a>22.11.3 一个更复杂的Bean 829</h4><h4 id="22-11-4-JavaBean与同步-831"><a href="#22-11-4-JavaBean与同步-831" class="headerlink" title="22.11.4 JavaBean与同步 831"></a>22.11.4 JavaBean与同步 831</h4><h4 id="22-11-5-把Bean打包-834"><a href="#22-11-5-把Bean打包-834" class="headerlink" title="22.11.5 把Bean打包 834"></a>22.11.5 把Bean打包 834</h4><h4 id="22-11-6-对Bean更高级的支持-835"><a href="#22-11-6-对Bean更高级的支持-835" class="headerlink" title="22.11.6 对Bean更高级的支持 835"></a>22.11.6 对Bean更高级的支持 835</h4><h4 id="22-11-7-有关Bean的其他读物-836"><a href="#22-11-7-有关Bean的其他读物-836" class="headerlink" title="22.11.7 有关Bean的其他读物 836"></a>22.11.7 有关Bean的其他读物 836</h4><h4 id="22-12-Swing的可替代选择-836"><a href="#22-12-Swing的可替代选择-836" class="headerlink" title="22.12 Swing的可替代选择 836"></a>22.12 Swing的可替代选择 836</h4><h4 id="22-13-用Flex构建Flash-Web客户端-836"><a href="#22-13-用Flex构建Flash-Web客户端-836" class="headerlink" title="22.13 用Flex构建Flash Web客户端 836"></a>22.13 用Flex构建Flash Web客户端 836</h4><h4 id="22-13-1-Hello-Flex-837"><a href="#22-13-1-Hello-Flex-837" class="headerlink" title="22.13.1 Hello, Flex 837"></a>22.13.1 Hello, Flex 837</h4><h4 id="22-13-2-编译MXML-838"><a href="#22-13-2-编译MXML-838" class="headerlink" title="22.13.2 编译MXML 838"></a>22.13.2 编译MXML 838</h4><h4 id="22-13-3-MXML与ActionScript-838"><a href="#22-13-3-MXML与ActionScript-838" class="headerlink" title="22.13.3 MXML与ActionScript 838"></a>22.13.3 MXML与ActionScript 838</h4><h4 id="22-13-4-容器与控制-839"><a href="#22-13-4-容器与控制-839" class="headerlink" title="22.13.4 容器与控制 839"></a>22.13.4 容器与控制 839</h4><h4 id="22-13-5-效果与样式-840"><a href="#22-13-5-效果与样式-840" class="headerlink" title="22.13.5 效果与样式 840"></a>22.13.5 效果与样式 840</h4><h4 id="22-13-6-事件-841"><a href="#22-13-6-事件-841" class="headerlink" title="22.13.6 事件 841"></a>22.13.6 事件 841</h4><h4 id="22-13-7-连接到Java-841"><a href="#22-13-7-连接到Java-841" class="headerlink" title="22.13.7 连接到Java 841"></a>22.13.7 连接到Java 841</h4><h4 id="22-13-8-数据模型与数据绑定-843"><a href="#22-13-8-数据模型与数据绑定-843" class="headerlink" title="22.13.8 数据模型与数据绑定 843"></a>22.13.8 数据模型与数据绑定 843</h4><h4 id="22-13-9-构建和部署-843"><a href="#22-13-9-构建和部署-843" class="headerlink" title="22.13.9 构建和部署 843"></a>22.13.9 构建和部署 843</h4><h4 id="22-14-创建SWT应用-844"><a href="#22-14-创建SWT应用-844" class="headerlink" title="22.14 创建SWT应用 844"></a>22.14 创建SWT应用 844</h4><h4 id="22-14-1-安装SWT-845"><a href="#22-14-1-安装SWT-845" class="headerlink" title="22.14.1 安装SWT 845"></a>22.14.1 安装SWT 845</h4><h4 id="22-14-2-Hello-SWT-845"><a href="#22-14-2-Hello-SWT-845" class="headerlink" title="22.14.2 Hello, SWT 845"></a>22.14.2 Hello, SWT 845</h4><h4 id="22-14-3-根除冗余代码-847"><a href="#22-14-3-根除冗余代码-847" class="headerlink" title="22.14.3 根除冗余代码 847"></a>22.14.3 根除冗余代码 847</h4><h4 id="22-14-4-菜单-848"><a href="#22-14-4-菜单-848" class="headerlink" title="22.14.4 菜单 848"></a>22.14.4 菜单 848</h4><h4 id="22-14-5-页签面板、按钮和事件-849"><a href="#22-14-5-页签面板、按钮和事件-849" class="headerlink" title="22.14.5 页签面板、按钮和事件 849"></a>22.14.5 页签面板、按钮和事件 849</h4><h4 id="22-14-6-图形-852"><a href="#22-14-6-图形-852" class="headerlink" title="22.14.6 图形 852"></a>22.14.6 图形 852</h4><h4 id="22-14-7-SWT中的并发-853"><a href="#22-14-7-SWT中的并发-853" class="headerlink" title="22.14.7 SWT中的并发 853"></a>22.14.7 SWT中的并发 853</h4><h4 id="22-14-8-SWT还是Swing-855"><a href="#22-14-8-SWT还是Swing-855" class="headerlink" title="22.14.8 SWT还是Swing 855"></a>22.14.8 SWT还是Swing 855</h4><h4 id="22-15-总结-855"><a href="#22-15-总结-855" class="headerlink" title="22.15 总结 855"></a>22.15 总结 855</h4><h4 id="22-15-1-资源-855"><a href="#22-15-1-资源-855" class="headerlink" title="22.15.1 资源 855"></a>22.15.1 资源 855</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a></p></blockquote><h3 id="附录A-补充材料-856"><a href="#附录A-补充材料-856" class="headerlink" title="附录A 补充材料 856"></a>附录A 补充材料 856</h3><h3 id="附录B-资源-859"><a href="#附录B-资源-859" class="headerlink" title="附录B 资源 859"></a>附录B 资源 859</h3><h3 id="索引-863"><a href="#索引-863" class="headerlink" title="索引 863"></a>索引 863</h3>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第13章字符串</title>
      <link href="/2019/07/25/2019-07-25-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC13%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/07/25/2019-07-25-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC13%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="第13章-字符串-283"><a href="#第13章-字符串-283" class="headerlink" title="第13章 字符串 283"></a>第13章 字符串 283</h3><h4 id="13-1-不可变String-283"><a href="#13-1-不可变String-283" class="headerlink" title="13.1 不可变String 283"></a>13.1 不可变String 283</h4><h4 id="13-2-重载“-”与StringBuilder-283"><a href="#13-2-重载“-”与StringBuilder-283" class="headerlink" title="13.2 重载“+”与StringBuilder 283"></a>13.2 重载“+”与StringBuilder 283</h4><blockquote><p>每一个+号，意味着new了一个StringBuilder 对象</p></blockquote><h4 id="13-3-无意识的递归-287"><a href="#13-3-无意识的递归-287" class="headerlink" title="13.3 无意识的递归 287"></a>13.3 无意识的递归 287</h4><h4 id="13-4-String上的操作-288"><a href="#13-4-String上的操作-288" class="headerlink" title="13.4 String上的操作 288"></a>13.4 String上的操作 288</h4><h4 id="13-5-格式化输出-289"><a href="#13-5-格式化输出-289" class="headerlink" title="13.5 格式化输出 289"></a>13.5 格式化输出 289</h4><h5 id="13-5-1-printf-289"><a href="#13-5-1-printf-289" class="headerlink" title="13.5.1 printf() 289"></a>13.5.1 printf() 289</h5><blockquote><p>%d 整数；%f 浮点型；%s字符串</p></blockquote><h5 id="13-5-2-System-out-format-289"><a href="#13-5-2-System-out-format-289" class="headerlink" title="13.5.2 System.out.format() 289"></a>13.5.2 System.out.format() 289</h5><blockquote><p>等价于printf()，此方法适用于PrintStream或者PrintWriter对象</p></blockquote><h5 id="13-5-3-Formatter类-290"><a href="#13-5-3-Formatter类-290" class="headerlink" title="13.5.3 Formatter类 290"></a>13.5.3 Formatter类 290</h5><blockquote><p>格式化输出</p></blockquote><h5 id="13-5-4-格式化说明符-291"><a href="#13-5-4-格式化说明符-291" class="headerlink" title="13.5.4 格式化说明符 291"></a>13.5.4 格式化说明符 291</h5><blockquote><p>空格对齐</p></blockquote><h5 id="13-5-5-Formatter转换-292"><a href="#13-5-5-Formatter转换-292" class="headerlink" title="13.5.5 Formatter转换 292"></a>13.5.5 Formatter转换 292</h5><blockquote><p>Formatter.formatter()</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190724141203.png" alt=""></p><h5 id="13-5-6-String-format-294"><a href="#13-5-6-String-format-294" class="headerlink" title="13.5.6 String.format() 294"></a>13.5.6 String.format() 294</h5><blockquote><p>String.format()内部还是调用Formatter.formatter()</p></blockquote><h4 id="13-6-正则表达式-295"><a href="#13-6-正则表达式-295" class="headerlink" title="13.6 正则表达式 295"></a>13.6 正则表达式 295</h4><h5 id="13-6-1-基础-295"><a href="#13-6-1-基础-295" class="headerlink" title="13.6.1 基础 295"></a>13.6.1 基础 295</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 可能有一个负号在最前：-?   即?号表示可能存在</span><br><span class="line"><span class="number">2</span>. 在正则表达式中，\d表示一位数字，在Java中，反斜杠需要转义，即\\d表示一位数字</span><br><span class="line"><span class="number">3</span>. \\\\普通的反斜杠</span><br><span class="line"><span class="number">4</span>. 换行和制表符之类的只需要单个反斜杠：\n\t</span><br><span class="line"><span class="number">5</span>. 一个或多个之前的表达式：+</span><br><span class="line">    -?\\d+  :表示可能有一个负号，后面跟着一位或多位数字</span><br><span class="line"><span class="number">6</span>. | 表示或者，(-|\\+)?\\d+  表示以一个加号或减号开头（可能都没有，因为后面有个问号）的数字，由于字符+在正则表达式中有特殊含义，需要\\转义</span><br><span class="line"><span class="number">7</span>. \W(Java中需要写成\\W):非单词字符</span><br><span class="line"><span class="number">8</span>. \w(Java中需要写成\\w):一个单词字符</span><br></pre></td></tr></table></figure><h5 id="13-6-2-创建正则表达式-297"><a href="#13-6-2-创建正则表达式-297" class="headerlink" title="13.6.2 创建正则表达式 297"></a>13.6.2 创建正则表达式 297</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190725103949.png" alt=""></p><p>jdk1.6的正则表达式：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190725jdk1.6regex.png" alt=""></p><h5 id="13-6-3-量词-299"><a href="#13-6-3-量词-299" class="headerlink" title="13.6.3 量词 299"></a>13.6.3 量词 299</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190725105754.png" alt=""></p><blockquote><p>CharSequence接口，正则表达式能接受此接口类型的参数</p></blockquote><h5 id="13-6-4-Pattern和Matcher-300"><a href="#13-6-4-Pattern和Matcher-300" class="headerlink" title="13.6.4 Pattern和Matcher 300"></a>13.6.4 Pattern和Matcher 300</h5><blockquote><p>相关方法的用法</p></blockquote><h5 id="13-6-5-split-305"><a href="#13-6-5-split-305" class="headerlink" title="13.6.5 split() 305"></a>13.6.5 split() 305</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split(CharSequence input)</span><br><span class="line">split(CharSequence input, <span class="keyword">int</span> limit)</span><br><span class="line">    limit表示分割后数组的大小，限制分割</span><br></pre></td></tr></table></figure><h5 id="13-6-6-替换操作-306"><a href="#13-6-6-替换操作-306" class="headerlink" title="13.6.6 替换操作 306"></a>13.6.6 替换操作 306</h5><blockquote><p>replace相关操作</p></blockquote><h5 id="13-6-7-reset-307"><a href="#13-6-7-reset-307" class="headerlink" title="13.6.7 reset() 307"></a>13.6.7 reset() 307</h5><h5 id="13-6-8-正则表达式与Java-I-O-307"><a href="#13-6-8-正则表达式与Java-I-O-307" class="headerlink" title="13.6.8 正则表达式与Java I/O 307"></a>13.6.8 正则表达式与Java I/O 307</h5><h4 id="13-7-扫描输入-309"><a href="#13-7-扫描输入-309" class="headerlink" title="13.7 扫描输入 309"></a>13.7 扫描输入 309</h4><blockquote><p>Scanner 类是jdk1.5新加入的</p></blockquote><h5 id="13-7-1-Scanner定界符-310"><a href="#13-7-1-Scanner定界符-310" class="headerlink" title="13.7.1 Scanner定界符 310"></a>13.7.1 Scanner定界符 310</h5><blockquote><p>默认空白字符分割，可以使用正则表达式指定</p><p>scanner.useDelimiter(pattern)</p></blockquote><h5 id="13-7-2-用正则表达式扫描-311"><a href="#13-7-2-用正则表达式扫描-311" class="headerlink" title="13.7.2 用正则表达式扫描 311"></a>13.7.2 用正则表达式扫描 311</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scanner.next(pattern);</span><br><span class="line">MatchResult match = scanner.match();</span><br><span class="line">match.group(<span class="number">1</span>);</span><br><span class="line">match.group(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="13-8-StringTokenizer-312"><a href="#13-8-StringTokenizer-312" class="headerlink" title="13.8 StringTokenizer 312"></a>13.8 StringTokenizer 312</h4><blockquote><p>作者说基本上可以放弃了，使用正则表达式或者Scanner就可以了</p></blockquote><h4 id="13-9-总结-312"><a href="#13-9-总结-312" class="headerlink" title="13.9 总结 312"></a>13.9 总结 312</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第12章通过异常处理错误</title>
      <link href="/2019/07/23/2019-07-23-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC12%E7%AB%A0%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/"/>
      <url>/2019/07/23/2019-07-23-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC12%E7%AB%A0%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="第12章-通过异常处理错误-248"><a href="#第12章-通过异常处理错误-248" class="headerlink" title="第12章 通过异常处理错误 248"></a>第12章 通过异常处理错误 248</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190722151802.png" alt=""></p><h4 id="12-1-概念-249"><a href="#12-1-概念-249" class="headerlink" title="12.1 概念 249"></a>12.1 概念 249</h4><h4 id="12-2-基本异常-249"><a href="#12-2-基本异常-249" class="headerlink" title="12.2 基本异常 249"></a>12.2 基本异常 249</h4><h5 id="12-2-1-异常参数-250"><a href="#12-2-1-异常参数-250" class="headerlink" title="12.2.1 异常参数 250"></a>12.2.1 异常参数 250</h5><h4 id="12-3-捕获异常-250"><a href="#12-3-捕获异常-250" class="headerlink" title="12.3 捕获异常 250"></a>12.3 捕获异常 250</h4><h5 id="12-3-1-try块-250"><a href="#12-3-1-try块-250" class="headerlink" title="12.3.1 try块 250"></a>12.3.1 try块 250</h5><h5 id="12-3-2-异常处理程序-250"><a href="#12-3-2-异常处理程序-250" class="headerlink" title="12.3.2 异常处理程序 250"></a>12.3.2 异常处理程序 250</h5><h4 id="12-4-创建自定义异常-251"><a href="#12-4-创建自定义异常-251" class="headerlink" title="12.4 创建自定义异常 251"></a>12.4 创建自定义异常 251</h4><h5 id="12-4-1-异常与记录日志-253"><a href="#12-4-1-异常与记录日志-253" class="headerlink" title="12.4.1 异常与记录日志 253"></a>12.4.1 异常与记录日志 253</h5><h4 id="12-5-异常说明-256"><a href="#12-5-异常说明-256" class="headerlink" title="12.5 异常说明 256"></a>12.5 异常说明 256</h4><h4 id="12-6-捕获所有异常-256"><a href="#12-6-捕获所有异常-256" class="headerlink" title="12.6 捕获所有异常 256"></a>12.6 捕获所有异常 256</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723112853.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723112924.png" alt=""></p><h5 id="12-6-1-栈轨迹-257"><a href="#12-6-1-栈轨迹-257" class="headerlink" title="12.6.1 栈轨迹 257"></a>12.6.1 栈轨迹 257</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113224.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113257.png" alt=""></p><h5 id="12-6-2-重新抛出异常-258"><a href="#12-6-2-重新抛出异常-258" class="headerlink" title="12.6.2 重新抛出异常 258"></a>12.6.2 重新抛出异常 258</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113543.png" alt=""></p><h5 id="12-6-3-异常链-260"><a href="#12-6-3-异常链-260" class="headerlink" title="12.6.3 异常链 260"></a>12.6.3 异常链 260</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723113925.png" alt=""></p><h4 id="12-7-Java标准异常-263"><a href="#12-7-Java标准异常-263" class="headerlink" title="12.7 Java标准异常 263"></a>12.7 Java标准异常 263</h4><blockquote><p>Throwable</p><p>​            —Error</p><p>​            —Exception</p><p>​                        ——RuntimeException</p><p>​                        ——非RuntimeException</p></blockquote><h5 id="12-7-1-特例：RuntimeException-263"><a href="#12-7-1-特例：RuntimeException-263" class="headerlink" title="12.7.1 特例：RuntimeException 263"></a>12.7.1 特例：RuntimeException 263</h5><h4 id="12-8-使用finally进行清理-264"><a href="#12-8-使用finally进行清理-264" class="headerlink" title="12.8 使用finally进行清理 264"></a>12.8 使用finally进行清理 264</h4><h5 id="12-8-1-finally用来做什么-265"><a href="#12-8-1-finally用来做什么-265" class="headerlink" title="12.8.1 finally用来做什么 265"></a>12.8.1 finally用来做什么 265</h5><h5 id="12-8-2-在return中使用finally-267"><a href="#12-8-2-在return中使用finally-267" class="headerlink" title="12.8.2 在return中使用finally 267"></a>12.8.2 在return中使用finally 267</h5><h5 id="12-8-3-缺憾：异常丢失-268"><a href="#12-8-3-缺憾：异常丢失-268" class="headerlink" title="12.8.3 缺憾：异常丢失 268"></a>12.8.3 缺憾：异常丢失 268</h5><blockquote><p>某些情况下，使用finally会使异常丢失：前一个异常还没处理就抛出另一个异常</p></blockquote><h4 id="12-9-异常的限制-269"><a href="#12-9-异常的限制-269" class="headerlink" title="12.9 异常的限制 269"></a>12.9 异常的限制 269</h4><blockquote><p>继承上的限制</p></blockquote><h4 id="12-10-构造器-271"><a href="#12-10-构造器-271" class="headerlink" title="12.10 构造器 271"></a>12.10 构造器 271</h4><blockquote><p>在创建需要清理的对象之后，立即进入一个try—finally块</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723153106.png" alt=""></p><h4 id="12-11-异常匹配-275"><a href="#12-11-异常匹配-275" class="headerlink" title="12.11 异常匹配 275"></a>12.11 异常匹配 275</h4><blockquote><p>子类异常可匹配父类异常</p></blockquote><h4 id="12-12-其他可选方式-276"><a href="#12-12-其他可选方式-276" class="headerlink" title="12.12 其他可选方式 276"></a>12.12 其他可选方式 276</h4><blockquote><p>源于异常的来源以及其他处理方式，重点在于理解</p></blockquote><h5 id="12-12-1-历史-277"><a href="#12-12-1-历史-277" class="headerlink" title="12.12.1 历史 277"></a>12.12.1 历史 277</h5><h5 id="12-12-2-观点-278"><a href="#12-12-2-观点-278" class="headerlink" title="12.12.2 观点 278"></a>12.12.2 观点 278</h5><h5 id="12-12-3-把异常传递给控制台-279"><a href="#12-12-3-把异常传递给控制台-279" class="headerlink" title="12.12.3 把异常传递给控制台 279"></a>12.12.3 把异常传递给控制台 279</h5><h5 id="12-12-4-把“被检查的异常”转换为“不受检查的异常”-279"><a href="#12-12-4-把“被检查的异常”转换为“不受检查的异常”-279" class="headerlink" title="12.12.4 把“被检查的异常”转换为“不受检查的异常” 279"></a>12.12.4 把“被检查的异常”转换为“不受检查的异常” 279</h5><h4 id="12-13-异常使用指南-281"><a href="#12-13-异常使用指南-281" class="headerlink" title="12.13 异常使用指南 281"></a>12.13 异常使用指南 281</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190723161941.png" alt=""></p><h4 id="12-14-总结-281"><a href="#12-14-总结-281" class="headerlink" title="12.14 总结 281"></a>12.14 总结 281</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)程序出现的不正常的情况。</span><br><span class="line"><span class="number">1</span>、编译时异常：语法错误</span><br><span class="line"><span class="number">2</span>、运行时异常：逻辑错误（数组下标越界）</span><br><span class="line">(<span class="number">2</span>)异常的体系</span><br><span class="line">Throwable</span><br><span class="line">|--Error严重问题，我们不处理，比如说内存溢出。</span><br><span class="line">|--Exception</span><br><span class="line">|--RuntimeException运行期异常，这种问题我们也不处理，因为是你的问题，而且这个问题出现肯定是我们的代码不够严谨，需要修正代码的。</span><br><span class="line">|--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过</span><br><span class="line">(<span class="number">3</span>)异常的处理：</span><br><span class="line">A:JVM的默认处理</span><br><span class="line">把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。</span><br><span class="line">B:自己处理</span><br><span class="line">a:<span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line">自己编写处理代码,后面的程序可以继续执行</span><br><span class="line">b:<span class="keyword">throws</span></span><br><span class="line">把自己处理不了的，在方法上声明，告诉调用者，这里有问题,这个格式必须跟在方法的括号后面。</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span>的处理格式：</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">可能出现问题的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常名 变量) &#123;</span><br><span class="line"> 针对问题的处理;</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  释放资源;</span><br><span class="line">  &#125;</span><br><span class="line">(<span class="number">4</span>)面试题</span><br><span class="line">A:编译期异常和运行期异常的区别?</span><br><span class="line">编译期异常 必须要处理的，否则编译不通过</span><br><span class="line">运行期异常 可以不处理，也可以处理</span><br><span class="line">B:<span class="keyword">throw</span>和<span class="keyword">throws</span>是的区别</span><br><span class="line"><span class="keyword">throws</span></span><br><span class="line">              用在方法声明后面，跟的是异常类名</span><br><span class="line">              可以跟多个异常类名，用逗号隔开</span><br><span class="line">              表示抛出异常，由该方法的调用者来处理</span><br><span class="line">              <span class="keyword">throws</span>表示出现异常的一种可能性，并不一定会发生这些异常</span><br><span class="line">          <span class="keyword">throw</span></span><br><span class="line">              用在方法体内，跟的是异常对象名</span><br><span class="line">              只能抛出一个异常对象名</span><br><span class="line">              表示抛出异常，由方法体内的语句处理</span><br><span class="line">              <span class="keyword">throw</span>则是抛出了异常，执行<span class="keyword">throw</span>则一定抛出了某种异常</span><br><span class="line">(<span class="number">5</span>)<span class="keyword">finally</span>关键字及其面试题</span><br><span class="line">A:<span class="keyword">finally</span>用于释放资源，它的代码永远会执行。特殊情况：在执行到<span class="keyword">finally</span>之前jvm退出了</span><br><span class="line">B:面试题</span><br><span class="line">a:<span class="keyword">final</span>,<span class="keyword">finally</span>,finalize的区别?</span><br><span class="line"><span class="keyword">final</span>：最终的意思，可以修饰类，成员变量，成员方法</span><br><span class="line"> 修饰类，类不能被继承</span><br><span class="line">  修饰变量，变量是常量</span><br><span class="line">  修饰方法，方法不能被重写</span><br><span class="line">  <span class="keyword">finally</span>：是异常处理的一部分，用于释放资源。</span><br><span class="line">  一般来说，代码肯定会执行，特殊情况：在执行到<span class="keyword">finally</span>之前jvm退出了</span><br><span class="line"> finalize：是Object类的一个方法，用于垃圾回收</span><br><span class="line"></span><br><span class="line">b:如果在<span class="keyword">catch</span>里面有<span class="keyword">return</span>,请问<span class="keyword">finally</span>还执行吗?如果执行,在<span class="keyword">return</span>前还是后？</span><br><span class="line"></span><br><span class="line">会，前。实际上在中间。</span><br><span class="line"></span><br><span class="line">C:异常处理的变形</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">catch</span>...</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">catch</span>...fianlly</span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">finally</span> 这种做法的目前是为了释放资源。</span><br><span class="line"></span><br><span class="line">注意： </span><br><span class="line">A:<span class="keyword">try</span>里面的代码越少越好</span><br><span class="line">B:<span class="keyword">catch</span>里面必须有内容，哪怕是给出一个简单的提示</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"><span class="number">1</span>:能明确的尽量明确，不要用大的来处理。</span><br><span class="line">  <span class="number">2</span>:平级关系的异常谁前谁后无所谓，如果出现了子父关系，父必须在后面。</span><br><span class="line">  </span><br><span class="line"> 注意：</span><br><span class="line">  一旦<span class="keyword">try</span>里面出了问题，就会在这里把问题给抛出去，然后和<span class="keyword">catch</span>里面的问题进行匹配，</span><br><span class="line">一旦有匹配的，就执行<span class="keyword">catch</span>里面的处理，然后结束了<span class="keyword">try</span>...<span class="keyword">catch</span>继续执行后面的语句。</span><br><span class="line">  </span><br><span class="line">     d.JDK7出现了一个新的异常处理方案：</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"> </span><br><span class="line">  &#125;<span class="keyword">catch</span>(异常名<span class="number">1</span> | 异常名<span class="number">2</span> | ...  变量 ) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  注意：这个方法虽然简洁，但是也不够好。</span><br><span class="line">  A:处理方式是一致的。(实际开发中，好多时候可能就是针对同类型的问题，给出同一个处理)</span><br><span class="line"> B:多个异常间必须是平级关系。</span><br><span class="line">(<span class="number">6</span>)自定义异常</span><br><span class="line">继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可</span><br><span class="line"></span><br><span class="line">   自定义异常：</span><br><span class="line"><span class="number">1</span>、定义一个类继承Exception类</span><br><span class="line"><span class="number">2</span>、定义一个带参数的构造方法</span><br><span class="line"><span class="number">3</span>、调用父类带参数的构造方法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">super</span>(message);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>)异常的注意实现</span><br><span class="line">A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 </span><br><span class="line">B:父的方法没有异常抛出,子的重写方法不能有异常抛出</span><br><span class="line">C:父的方法抛出多个异常,子的重写方法必须比父少或者小</span><br><span class="line"></span><br><span class="line">异常注意事项:</span><br><span class="line"> A:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</span><br><span class="line"> B:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</span><br><span class="line"> C:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只</span><br><span class="line">   能<span class="keyword">try</span>,不能<span class="keyword">throws</span></span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）异常中要了解的几个方法：</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span>:异常的消息字符串</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>:返回异常的简单信息描述此对象的类的 <span class="title">name</span><span class="params">(全路径名)</span></span></span><br><span class="line"><span class="function"> ": "（冒号和一个空格） 调用此对象<span class="title">getLocalizedMessage</span><span class="params">()</span>方法的结果 </span></span><br><span class="line"><span class="function"><span class="params">(默认返回的是getMessage()</span>的内容)</span></span><br><span class="line"><span class="function">  <span class="title">printStackTrace</span><span class="params">()</span> 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值<span class="keyword">void</span>。</span></span><br><span class="line"><span class="function">把信息输出在控制台。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Exception类中的方法：</span></span><br><span class="line"><span class="function"> <span class="title">getMessage</span><span class="params">()</span>:获得异常相关的描述信息<span class="params">(获得异常产生的原因）</span></span></span><br><span class="line"><span class="function"><span class="params"> printStackTrace()</span>:获得异常相关的描述信息<span class="params">(包括异常产生的</span></span></span><br><span class="line"><span class="function"><span class="params"> 原因以及异常产生的位置)</span></span></span><br></pre></td></tr></table></figure><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第11章持有对象</title>
      <link href="/2019/07/21/2019-07-21-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC11%E7%AB%A0%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/07/21/2019-07-21-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC11%E7%AB%A0%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="第11章-持有对象-216"><a href="#第11章-持有对象-216" class="headerlink" title="第11章 持有对象 216"></a>第11章 持有对象 216</h3><blockquote><p>这一章是初步介绍容器也就是集合的知识点：List、Set、Map、Queue</p></blockquote><h4 id="11-1-泛型和类型安全的容器-216"><a href="#11-1-泛型和类型安全的容器-216" class="headerlink" title="11.1 泛型和类型安全的容器 216"></a>11.1 泛型和类型安全的容器 216</h4><h4 id="11-2-基本概念-219"><a href="#11-2-基本概念-219" class="headerlink" title="11.2 基本概念 219"></a>11.2 基本概念 219</h4><h4 id="11-3-添加一组元素-220"><a href="#11-3-添加一组元素-220" class="headerlink" title="11.3 添加一组元素 220"></a>11.3 添加一组元素 220</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList()</span><br><span class="line">Collections.addAll()</span><br><span class="line">collection.addAll()</span><br></pre></td></tr></table></figure><h4 id="11-4-容器的打印-221"><a href="#11-4-容器的打印-221" class="headerlink" title="11.4 容器的打印 221"></a>11.4 容器的打印 221</h4><h4 id="11-5-List-223"><a href="#11-5-List-223" class="headerlink" title="11.5 List 223"></a>11.5 List 223</h4><blockquote><p>ArrayList LinkedList</p></blockquote><h4 id="11-6-迭代器-226"><a href="#11-6-迭代器-226" class="headerlink" title="11.6 迭代器 226"></a>11.6 迭代器 226</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190719110519.png" alt=""></p><h5 id="11-6-1-ListIterator-227"><a href="#11-6-1-ListIterator-227" class="headerlink" title="11.6.1 ListIterator 227"></a>11.6.1 ListIterator 227</h5><blockquote><p>ListIterator是一个功能更加强大的, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。只用于list集合</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190719111623.png" alt=""></p><p>ListIterator 与Iterator 的区别：</p><blockquote><p>（1）ListIterator有add()方法，可以向List中添加对象，而Iterator不能<br>（2）ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。<br>（3）ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。<br>（4）都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</p></blockquote><h4 id="11-7-LinkedList-228"><a href="#11-7-LinkedList-228" class="headerlink" title="11.7 LinkedList 228"></a>11.7 LinkedList 228</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190719112101.png" alt=""></p><h4 id="11-8-Stack-229"><a href="#11-8-Stack-229" class="headerlink" title="11.8 Stack 229"></a>11.8 Stack 229</h4><blockquote><p>先进后出，可以将LinkedList作为Stack使用</p></blockquote><h4 id="11-9-Set-231"><a href="#11-9-Set-231" class="headerlink" title="11.9 Set 231"></a>11.9 Set 231</h4><blockquote><p>不重复元素</p></blockquote><h4 id="11-10-Map-233"><a href="#11-10-Map-233" class="headerlink" title="11.10 Map 233"></a>11.10 Map 233</h4><h4 id="11-11-Queue-236"><a href="#11-11-Queue-236" class="headerlink" title="11.11 Queue 236"></a>11.11 Queue 236</h4><blockquote><p>先进先出，LinkedList实现了此接口</p></blockquote><h5 id="11-11-1-PriorityQueue-237"><a href="#11-11-1-PriorityQueue-237" class="headerlink" title="11.11.1 PriorityQueue 237"></a>11.11.1 PriorityQueue 237</h5><blockquote><p>优先级队列，有序队列</p></blockquote><h4 id="11-12-Collection和Iterator-238"><a href="#11-12-Collection和Iterator-238" class="headerlink" title="11.12 Collection和Iterator 238"></a>11.12 Collection和Iterator 238</h4><blockquote><p>重点在于Iterator 接口思想，与下面的Foreach一样，理解Iterator 原理</p></blockquote><h4 id="11-13-Foreach与迭代器-241"><a href="#11-13-Foreach与迭代器-241" class="headerlink" title="11.13 Foreach与迭代器 241"></a>11.13 Foreach与迭代器 241</h4><blockquote><p>实现Iterable接口的Iterator 方法皆可用于foreach</p></blockquote><h5 id="11-13-1-适配器方法惯用法-243"><a href="#11-13-1-适配器方法惯用法-243" class="headerlink" title="11.13.1 适配器方法惯用法 243"></a>11.13.1 适配器方法惯用法 243</h5><blockquote><p>适配器模式实现Iterator 方法</p></blockquote><h4 id="11-14-总结-248"><a href="#11-14-总结-248" class="headerlink" title="11.14 总结 248"></a>11.14 总结 248</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第10章内部类</title>
      <link href="/2019/07/19/2019-07-19-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC10%E7%AB%A0%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2019/07/19/2019-07-19-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC10%E7%AB%A0%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="第10章-内部类-190"><a href="#第10章-内部类-190" class="headerlink" title="第10章 内部类 190"></a>第10章 内部类 190</h3><blockquote><p>需要细看，后期需要时不时的回看</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190718112105.png" alt=""></p><h4 id="10-1-创建内部类-190"><a href="#10-1-创建内部类-190" class="headerlink" title="10.1 创建内部类 190"></a>10.1 创建内部类 190</h4><h4 id="10-2-链接到外部类-191"><a href="#10-2-链接到外部类-191" class="headerlink" title="10.2 链接到外部类 191"></a>10.2 链接到外部类 191</h4><h4 id="10-3-使用-this与-new-193"><a href="#10-3-使用-this与-new-193" class="headerlink" title="10.3 使用.this与.new 193"></a>10.3 使用.this与.new 193</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)把类定义在另一个类的内部，该类就被称为内部类。隐含着一个指向外部类的对象引用</span><br><span class="line">举例：把类B定义在类A中，类B就被称为内部类。</span><br><span class="line">(<span class="number">2</span>)内部类的访问规则</span><br><span class="line">A:可以直接访问外部类的成员，包括私有</span><br><span class="line">B:外部类要想访问内部类成员，必须创建对象</span><br><span class="line">(<span class="number">3</span>)内部类的分类</span><br><span class="line">A:成员内部类</span><br><span class="line">B:局部内部类</span><br><span class="line">成员位置:在成员位置定义的类，被称为成员内部类。</span><br><span class="line">局部位置:在局部位置定义的类，被称为局部内部类。</span><br><span class="line">(<span class="number">4</span>)成员内部类</span><br><span class="line">A:<span class="keyword">private</span> 为了数据的安全性</span><br><span class="line">B:<span class="keyword">static</span> 为了访问的方便性</span><br><span class="line">如何直接访问内部类的成员：</span><br><span class="line">外部类名.内部类名 对象名 = 外部类对象.内部类对象;</span><br><span class="line">成员内部类不是静态的：</span><br><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.<span class="keyword">new</span> 内部类名();</span><br><span class="line">成员内部类是静态的：</span><br><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名();</span><br><span class="line"></span><br><span class="line">注意：静态内部类访问的外部类数据必须用静态修饰。</span><br><span class="line">(<span class="number">5</span>)局部内部类</span><br><span class="line">局部内部类访问局部变量的注意事项?</span><br><span class="line">A:局部内部类访问局部变量必须加<span class="keyword">final</span>修饰。</span><br><span class="line">B:为什么呢?</span><br><span class="line">因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。</span><br><span class="line">所以，堆内存还是用该变量，而改变量已经没有了。</span><br><span class="line">为了让该值还存在，就加<span class="keyword">final</span>修饰。</span><br><span class="line">通过反编译工具我们看到了，加入<span class="keyword">final</span>后，堆内存直接存储的是值，而不是变量名。</span><br></pre></td></tr></table></figure><h4 id="10-4-内部类与向上转型-194"><a href="#10-4-内部类与向上转型-194" class="headerlink" title="10.4 内部类与向上转型 194"></a>10.4 内部类与向上转型 194</h4><h4 id="10-5-在方法和作用域内的内部类-195"><a href="#10-5-在方法和作用域内的内部类-195" class="headerlink" title="10.5 在方法和作用域内的内部类 195"></a>10.5 在方法和作用域内的内部类 195</h4><h4 id="10-6-匿名内部类-196"><a href="#10-6-匿名内部类-196" class="headerlink" title="10.6 匿名内部类 196"></a>10.6 匿名内部类 196</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A:是局部内部类的简化形式</span><br><span class="line">B:前提</span><br><span class="line">存在一个类或者接口</span><br><span class="line">C:格式:</span><br><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br><span class="line">D:本质：</span><br><span class="line">其实是继承该类或者实现接口的子类匿名对象</span><br><span class="line">E:匿名内部类中用到外部参数时，外部参数必须是<span class="keyword">final</span>修饰</span><br><span class="line">匿名内部类在开发中的使用</span><br><span class="line">我们在开发的时候，会看到抽象类，或者接口作为参数。</span><br><span class="line">而这个时候，我们知道实际需要的是一个子类对象。</span><br><span class="line">如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。</span><br></pre></td></tr></table></figure><h5 id="10-6-1-再访工厂方法-199"><a href="#10-6-1-再访工厂方法-199" class="headerlink" title="10.6.1 再访工厂方法 199"></a>10.6.1 再访工厂方法 199</h5><h4 id="10-7-嵌套类-201"><a href="#10-7-嵌套类-201" class="headerlink" title="10.7 嵌套类 201"></a>10.7 嵌套类 201</h4><blockquote><p>内部类声明static，即为嵌套类，这时，就不包含外围对象的引用了，也只能访问外部的static成员</p></blockquote><h5 id="10-7-1-接口内部的类-202"><a href="#10-7-1-接口内部的类-202" class="headerlink" title="10.7.1 接口内部的类 202"></a>10.7.1 接口内部的类 202</h5><blockquote><p>接口可以有内部类</p></blockquote><h5 id="10-7-2-从多层嵌套类中访问外部类的成员-203"><a href="#10-7-2-从多层嵌套类中访问外部类的成员-203" class="headerlink" title="10.7.2 从多层嵌套类中访问外部类的成员 203"></a>10.7.2 从多层嵌套类中访问外部类的成员 203</h5><h4 id="10-8-为什么需要内部类-204"><a href="#10-8-为什么需要内部类-204" class="headerlink" title="10.8 为什么需要内部类 204"></a>10.8 为什么需要内部类 204</h4><h5 id="10-8-1-闭包与回调-205"><a href="#10-8-1-闭包与回调-205" class="headerlink" title="10.8.1 闭包与回调 205"></a>10.8.1 闭包与回调 205</h5><h5 id="10-8-2-内部类与控制框架-207"><a href="#10-8-2-内部类与控制框架-207" class="headerlink" title="10.8.2 内部类与控制框架 207"></a>10.8.2 内部类与控制框架 207</h5><h4 id="10-9-内部类的继承-212"><a href="#10-9-内部类的继承-212" class="headerlink" title="10.9 内部类的继承 212"></a>10.9 内部类的继承 212</h4><h4 id="10-10-内部类可以被覆盖吗-212"><a href="#10-10-内部类可以被覆盖吗-212" class="headerlink" title="10.10 内部类可以被覆盖吗 212"></a>10.10 内部类可以被覆盖吗 212</h4><h4 id="10-11-局部内部类-214"><a href="#10-11-局部内部类-214" class="headerlink" title="10.11 局部内部类 214"></a>10.11 局部内部类 214</h4><h4 id="10-12-内部类标识符-215"><a href="#10-12-内部类标识符-215" class="headerlink" title="10.12 内部类标识符 215"></a>10.12 内部类标识符 215</h4><h4 id="10-13-总结-215"><a href="#10-13-总结-215" class="headerlink" title="10.13 总结 215"></a>10.13 总结 215</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第9章接口</title>
      <link href="/2019/07/17/2019-07-17-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC9%E7%AB%A0%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/07/17/2019-07-17-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC9%E7%AB%A0%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="第9章-接口-169"><a href="#第9章-接口-169" class="headerlink" title="第9章 接口 169"></a>第9章 接口 169</h3><blockquote><p>需要细看</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190718095331.png" alt=""></p><h4 id="9-1-抽象类和抽象方法-169"><a href="#9-1-抽象类和抽象方法-169" class="headerlink" title="9.1 抽象类和抽象方法 169"></a>9.1 抽象类和抽象方法 169</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">一个没有具体的方法体的方法是抽象的方法。在一个类中如果有抽象方法，该类必须定义为抽象类。</span><br><span class="line">(<span class="number">1</span>)抽象类的特点</span><br><span class="line">A:抽象类和抽象方法必须用关键字<span class="keyword">abstract</span>修饰</span><br><span class="line">B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类</span><br><span class="line">C:抽象类不能实例化</span><br><span class="line">D:抽象类的子类</span><br><span class="line">a:是一个抽象类。</span><br><span class="line">b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。</span><br><span class="line">(<span class="number">2</span>)抽象类的成员特点：</span><br><span class="line">A:成员变量</span><br><span class="line">有变量，有常量</span><br><span class="line">B:构造方法</span><br><span class="line">有构造方法，用于子类访问父类数据的初始化。</span><br><span class="line">C:成员方法</span><br><span class="line">有抽象，有非抽象</span><br><span class="line">(<span class="number">3</span>)抽象类的几个小问题</span><br><span class="line">A:抽象类有构造方法，不能实例化，那么构造方法有什么用?</span><br><span class="line">用于子类访问父类数据的初始化</span><br><span class="line">B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?</span><br><span class="line">为了不让创建对象</span><br><span class="line">C:<span class="keyword">abstract</span>不能和哪些关键字共存</span><br><span class="line">a:<span class="keyword">final</span>冲突</span><br><span class="line">b:<span class="keyword">private</span> 冲突</span><br><span class="line">c:<span class="keyword">static</span> 无意义</span><br></pre></td></tr></table></figure><h4 id="9-2-接口-172"><a href="#9-2-接口-172" class="headerlink" title="9.2 接口 172"></a>9.2 接口 172</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)接口的特点：</span><br><span class="line">A:接口用关键字<span class="class"><span class="keyword">interface</span>修饰</span></span><br><span class="line"><span class="class"><span class="title">interface</span> 接口名 </span>&#123;&#125;</span><br><span class="line">B:类实现接口用implements修饰</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;&#125;</span><br><span class="line">C:接口不能实例化</span><br><span class="line"> 那么，接口如何实例化呢?</span><br><span class="line"> 按照多态的方式来实例化。</span><br><span class="line">D:接口的实现类（子类）</span><br><span class="line">a:是一个抽象类。</span><br><span class="line">b:是一个具体类，这个类必须重写接口中的所有抽象方法。</span><br><span class="line">由此可见：</span><br><span class="line">A:具体类多态(几乎没有)</span><br><span class="line">B:抽象类多态(常用)</span><br><span class="line">C:接口多态(最常用)</span><br><span class="line">(<span class="number">2</span>)接口的成员特点：</span><br><span class="line">A:成员变量</span><br><span class="line">只能是常量</span><br><span class="line">默认修饰符：<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">B:构造方法</span><br><span class="line">没有构造方法</span><br><span class="line">C:成员方法</span><br><span class="line">只能是抽象的</span><br><span class="line">默认修饰符：<span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line">所有的类都默认继承自一个类：Object。</span><br><span class="line">类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。</span><br><span class="line">(<span class="number">3</span>)类与类,类与接口,接口与接口</span><br><span class="line">A:类与类</span><br><span class="line">继承关系，只能单继承，可以多层继承</span><br><span class="line">B:类与接口</span><br><span class="line">实现关系，可以单实现，也可以多实现。</span><br><span class="line">还可以在继承一个类的同时，实现多个接口</span><br><span class="line">C:接口与接口</span><br><span class="line">继承关系，可以单继承，也可以多继承</span><br><span class="line">(<span class="number">4</span>)面试题：抽象类和接口的区别：</span><br><span class="line">A:成员区别</span><br><span class="line">抽象类：</span><br><span class="line">成员变量：可以变量，也可以常量</span><br><span class="line">构造方法：有</span><br><span class="line">成员方法：可以抽象，也可以非抽象</span><br><span class="line">接口：</span><br><span class="line">成员变量：只可以常量</span><br><span class="line">成员方法：只可以抽象</span><br><span class="line">B:关系区别</span><br><span class="line">类与类</span><br><span class="line">继承，单继承</span><br><span class="line">类与接口</span><br><span class="line">实现，单实现，多实现</span><br><span class="line">接口与接口</span><br><span class="line">继承，单继承，多继承</span><br><span class="line">C:设计理念区别</span><br><span class="line">抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。</span><br><span class="line">接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。</span><br><span class="line">抽象类:</span><br><span class="line"><span class="number">1</span>、如果一个类中只要有一个方法是抽象方法，该类变成抽象类</span><br><span class="line"><span class="number">2</span>、抽象类不能被实例化，只用来被继承</span><br><span class="line"><span class="number">3</span>、如果一个类继承一个抽象类，必须实现抽象类中所有的抽象方法</span><br><span class="line">否则，该类也会变成一个抽象类</span><br><span class="line"><span class="number">4</span>、抽象类的引用可以指向子类的实例，达到多态的效果</span><br><span class="line"><span class="number">5</span>、构造方法和静态方法不能定义成抽象方法</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"><span class="number">1</span>、如果一个类中所有的方法都是抽象方法，可以定义成接口</span><br><span class="line">用<span class="class"><span class="keyword">interface</span></span></span><br><span class="line"><span class="class">2、接口中所有的方法都是抽象方法，不能包含非抽象方法,</span></span><br><span class="line"><span class="class">在方法中可以省略<span class="title">abstract</span>关键字</span></span><br><span class="line"><span class="class">3、接口不能被实例化，只用来被实现（<span class="keyword">implements</span>)</span></span><br><span class="line"><span class="class">4、如果一个类实现一个接口，必须实现接口中所有的抽象方法，</span></span><br><span class="line"><span class="class">否则该类也会变成抽象类</span></span><br><span class="line"><span class="class">5、接口的引用指向实现类的实例</span></span><br><span class="line"><span class="class">6、接口中所有的量都是常量，没有变量</span></span><br><span class="line"><span class="class">7、接口中没有构造方法</span></span><br><span class="line"><span class="class">8、为了弥补继承的单一性，接口提供了多实现（一个类可以实现</span></span><br><span class="line"><span class="class">多个接口），必须要实现多个接口中提供的抽象方法</span></span><br><span class="line"><span class="class">9、一个类在继承一个类的同时可以去实现接口</span></span><br><span class="line"><span class="class">10、接口可以继承接口</span></span><br></pre></td></tr></table></figure><h4 id="9-3-完全解耦-174"><a href="#9-3-完全解耦-174" class="headerlink" title="9.3 完全解耦 174"></a>9.3 完全解耦 174</h4><blockquote><p>适配器模式</p></blockquote><h4 id="9-4-Java中的多重继承-178"><a href="#9-4-Java中的多重继承-178" class="headerlink" title="9.4 Java中的多重继承 178"></a>9.4 Java中的多重继承 178</h4><blockquote><p>Java是伪多重继承模式，属于单继承、多实现结合而形成的；在写法上，继承要写在多实现前面</p></blockquote><h4 id="9-5-通过继承来扩展接口-180"><a href="#9-5-通过继承来扩展接口-180" class="headerlink" title="9.5 通过继承来扩展接口 180"></a>9.5 通过继承来扩展接口 180</h4><h5 id="9-5-1-组合接口时的名字冲突-181"><a href="#9-5-1-组合接口时的名字冲突-181" class="headerlink" title="9.5.1 组合接口时的名字冲突 181"></a>9.5.1 组合接口时的名字冲突 181</h5><h4 id="9-6-适配接口-181"><a href="#9-6-适配接口-181" class="headerlink" title="9.6 适配接口 181"></a>9.6 适配接口 181</h4><h4 id="9-7-接口中的域-183"><a href="#9-7-接口中的域-183" class="headerlink" title="9.7 接口中的域 183"></a>9.7 接口中的域 183</h4><h5 id="9-7-1-初始化接口中的域-184"><a href="#9-7-1-初始化接口中的域-184" class="headerlink" title="9.7.1 初始化接口中的域 184"></a>9.7.1 初始化接口中的域 184</h5><h4 id="9-8-嵌套接口-185"><a href="#9-8-嵌套接口-185" class="headerlink" title="9.8 嵌套接口 185"></a>9.8 嵌套接口 185</h4><h4 id="9-9-接口与工厂-186"><a href="#9-9-接口与工厂-186" class="headerlink" title="9.9 接口与工厂 186"></a>9.9 接口与工厂 186</h4><blockquote><p>工厂方法设计模式</p></blockquote><h4 id="9-10-总结-188"><a href="#9-10-总结-188" class="headerlink" title="9.10 总结 188"></a>9.10 总结 188</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第8章多态</title>
      <link href="/2019/07/15/2019-07-15-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC8%E7%AB%A0%E5%A4%9A%E6%80%81/"/>
      <url>/2019/07/15/2019-07-15-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC8%E7%AB%A0%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="第8章-多态-148"><a href="#第8章-多态-148" class="headerlink" title="第8章 多态 148"></a>第8章 多态 148</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717165946.png" alt=""></p><h4 id="8-1-再论向上转型-148"><a href="#8-1-再论向上转型-148" class="headerlink" title="8.1 再论向上转型 148"></a>8.1 再论向上转型 148</h4><h5 id="8-1-1-忘记对象类型-149"><a href="#8-1-1-忘记对象类型-149" class="headerlink" title="8.1.1 忘记对象类型 149"></a>8.1.1 忘记对象类型 149</h5><h4 id="8-2-转机-150"><a href="#8-2-转机-150" class="headerlink" title="8.2 转机 150"></a>8.2 转机 150</h4><h5 id="8-2-1-方法调用绑定-150"><a href="#8-2-1-方法调用绑定-150" class="headerlink" title="8.2.1 方法调用绑定 150"></a>8.2.1 方法调用绑定 150</h5><h5 id="8-2-2-产生正确的行为-151"><a href="#8-2-2-产生正确的行为-151" class="headerlink" title="8.2.2 产生正确的行为 151"></a>8.2.2 产生正确的行为 151</h5><h5 id="8-2-3-可扩展性-153"><a href="#8-2-3-可扩展性-153" class="headerlink" title="8.2.3 可扩展性 153"></a>8.2.3 可扩展性 153</h5><h5 id="8-2-4-缺陷：“覆盖”私有方法-156"><a href="#8-2-4-缺陷：“覆盖”私有方法-156" class="headerlink" title="8.2.4 缺陷：“覆盖”私有方法 156"></a>8.2.4 缺陷：“覆盖”私有方法 156</h5><h5 id="8-2-5-缺陷：域与静态方法-156"><a href="#8-2-5-缺陷：域与静态方法-156" class="headerlink" title="8.2.5 缺陷：域与静态方法 156"></a>8.2.5 缺陷：域与静态方法 156</h5><h4 id="8-3-构造器和多态-157"><a href="#8-3-构造器和多态-157" class="headerlink" title="8.3 构造器和多态 157"></a>8.3 构造器和多态 157</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">多态：同一个对象(事物)，在不同时刻体现出来的不同状态。</span><br><span class="line">多态的前提：</span><br><span class="line">A:要有继承关系。</span><br><span class="line">B:要有方法重写。</span><br><span class="line">C:要有父类引用指向子类对象。</span><br><span class="line"></span><br><span class="line">多态的分类：</span><br><span class="line">a:具体类多态</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">b:抽象类多态</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">c:接口多态</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line"></span><br><span class="line">多态中的成员访问特点：</span><br><span class="line">A:成员变量</span><br><span class="line">编译看左边，运行看左边。</span><br><span class="line">B:构造方法</span><br><span class="line">创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化。</span><br><span class="line">C:成员方法</span><br><span class="line">编译看左边，运行看右边。</span><br><span class="line">    由于成员方法存在方法重写，所以它运行看右边。</span><br><span class="line">D:静态方法</span><br><span class="line">编译看左边，运行看左边。</span><br><span class="line">(静态和类相关，算不上重写，所以，访问还是左边的)</span><br><span class="line">多态的好处：</span><br><span class="line">A:提高了代码的维护性(继承保证（体现）)</span><br><span class="line">B:提高了代码的扩展性(由多态保证（体现）)</span><br><span class="line">多态的弊端：</span><br><span class="line">不能使用子类的特有功能。</span><br><span class="line"></span><br><span class="line">    我就想使用子类的特有功能?行不行?</span><br><span class="line">行。怎么用呢?</span><br><span class="line">A:创建子类对象调用方法即可。(可以，但是很多时候不合理。而且，太占内存了)</span><br><span class="line">B:把父类的引用强制转换为子类的引用。(向下转型)</span><br><span class="line">对象间的转型问题：</span><br><span class="line">向上转型：</span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">向下转型：</span><br><span class="line">Zi z = (Zi)f; <span class="comment">//要求该f必须是能够转换为Zi的。</span></span><br><span class="line"></span><br><span class="line">多态：多种形态（同一函数，不同形态)</span><br><span class="line"><span class="number">1</span>、静态多态：程序在编译的时候就知道调用哪个方法</span><br><span class="line">方法重载(Overrload)</span><br><span class="line"><span class="number">2</span>、动态多态：程序在运行时才确定调用哪个方法</span><br><span class="line">方法重写(Override)</span><br></pre></td></tr></table></figure><h5 id="8-3-1-构造器的调用顺序-157"><a href="#8-3-1-构造器的调用顺序-157" class="headerlink" title="8.3.1 构造器的调用顺序 157"></a>8.3.1 构造器的调用顺序 157</h5><h5 id="8-3-2-继承与清理-159"><a href="#8-3-2-继承与清理-159" class="headerlink" title="8.3.2 继承与清理 159"></a>8.3.2 继承与清理 159</h5><h5 id="8-3-3-构造器内部的多态方法的行为-162"><a href="#8-3-3-构造器内部的多态方法的行为-162" class="headerlink" title="8.3.3 构造器内部的多态方法的行为 162"></a>8.3.3 构造器内部的多态方法的行为 162</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();做了哪些事情?(理解)</span><br><span class="line">- (<span class="number">1</span>)把Student<span class="class">.<span class="keyword">class</span>文件加载到内存</span></span><br><span class="line"><span class="class">- (2)在栈内存为<span class="title">s</span>开辟空间</span></span><br><span class="line"><span class="class">- (3)在堆内存为学生对象申请空间</span></span><br><span class="line"><span class="class">- (4)给学生的成员变量进行默认初始化。</span></span><br><span class="line"><span class="class">- (5)给学生的成员变量进行显示初始化。</span></span><br><span class="line"><span class="class">- (6)通过构造方法给成员变量进行初始化。</span></span><br><span class="line"><span class="class">- (7)对象构造完毕，把地址赋值给<span class="title">s</span>变量</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170556.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170624.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170657.png" alt=""></p><h4 id="8-4-协变返回类型-164"><a href="#8-4-协变返回类型-164" class="headerlink" title="8.4 协变返回类型 164"></a>8.4 协变返回类型 164</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717170951.png" alt=""></p><h4 id="8-5-用继承进行设计-165"><a href="#8-5-用继承进行设计-165" class="headerlink" title="8.5 用继承进行设计 165"></a>8.5 用继承进行设计 165</h4><h5 id="8-5-1-纯继承与扩展-166"><a href="#8-5-1-纯继承与扩展-166" class="headerlink" title="8.5.1 纯继承与扩展 166"></a>8.5.1 纯继承与扩展 166</h5><h5 id="8-5-2-向下转型与运行时类型识别-167"><a href="#8-5-2-向下转型与运行时类型识别-167" class="headerlink" title="8.5.2 向下转型与运行时类型识别 167"></a>8.5.2 向下转型与运行时类型识别 167</h5><h4 id="8-6-总结-168"><a href="#8-6-总结-168" class="headerlink" title="8.6 总结 168"></a>8.6 总结 168</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第7章复用类</title>
      <link href="/2019/07/13/2019-07-13-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC7%E7%AB%A0%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
      <url>/2019/07/13/2019-07-13-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC7%E7%AB%A0%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="第7章-复用类-125"><a href="#第7章-复用类-125" class="headerlink" title="第7章 复用类 125"></a>第7章 复用类 125</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717164314.png" alt=""></p><h4 id="7-1-组合语法-125"><a href="#7-1-组合语法-125" class="headerlink" title="7.1 组合语法 125"></a>7.1 组合语法 125</h4><h4 id="7-2-继承语法-127"><a href="#7-2-继承语法-127" class="headerlink" title="7.2 继承语法 127"></a>7.2 继承语法 127</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，</span><br><span class="line">   这多个类就具备了这些内容。这个关系叫继承。</span><br><span class="line">   单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。</span><br><span class="line">(<span class="number">2</span>)Java中如何表示继承呢?格式是什么呢?</span><br><span class="line">A:用关键字extends表示</span><br><span class="line">B:格式：</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名 </span>&#123;&#125;</span><br><span class="line">(<span class="number">3</span>)继承的好处：</span><br><span class="line">A.提高了代码的复用性</span><br><span class="line">     多个类相同的成员可以放到同一个类中</span><br><span class="line">B.提高了代码的维护性</span><br><span class="line">     如果功能的代码需要修改，修改一处即可</span><br><span class="line">C.让类与类之间产生了关系，是多态的前提</span><br><span class="line">     其实这也是继承的一个弊端：类的耦合性很强</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)继承的弊端：</span><br><span class="line">A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。</span><br><span class="line">原则：低耦合，高内聚。</span><br><span class="line">耦合：类与类的关系</span><br><span class="line">内聚：自己完成某件事情的能力</span><br><span class="line">B:打破了封装性</span><br><span class="line">(<span class="number">5</span>)Java中继承的特点</span><br><span class="line">A:Java中类只支持单继承</span><br><span class="line">一个类只能有一个父类，不可以有多个父类。</span><br><span class="line">B:Java中可以多层(重)继承(继承体系)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line">(<span class="number">6</span>)继承的注意事项：</span><br><span class="line">A:子类不能继承父类的私有成员</span><br><span class="line">B:子类不能继承父类的构造方法，但是可以通过<span class="keyword">super</span>去访问</span><br><span class="line">C:不要为了部分功能而去继承</span><br><span class="line">(<span class="number">7</span>)什么时候使用继承呢?</span><br><span class="line">A:继承体现的是：is a的关系。</span><br><span class="line">B:采用假设法</span><br><span class="line">(<span class="number">8</span>)Java继承中的成员关系</span><br><span class="line">A:成员变量</span><br><span class="line">a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单</span><br><span class="line">b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?</span><br><span class="line">子类的方法访问变量的查找顺序：</span><br><span class="line">在子类方法的局部范围找，有就使用。</span><br><span class="line">在子类的成员范围找，有就使用。</span><br><span class="line">在父类的成员范围找，有就使用。</span><br><span class="line">找不到，就报错。</span><br><span class="line">B:构造方法</span><br><span class="line">a:子类的构造方法默认会去访问父类的无参构造方法</span><br><span class="line">是为了子类访问父类数据的初始化</span><br><span class="line">注意：子类每一个构造方法的第一条语句默认都是：<span class="keyword">super</span>();</span><br><span class="line">b:父类中如果没有无参构造方法，怎么办?</span><br><span class="line">子类通过<span class="keyword">super</span>去明确调用带参构造</span><br><span class="line">子类通过<span class="keyword">this</span>调用本身的其他构造，但是一定会有一个去访问了父类的构造</span><br><span class="line">让父类提供无参构造</span><br><span class="line">C:成员方法</span><br><span class="line">a:子类的成员方法和父类中的成员方法名称不一样，这个太简单</span><br><span class="line">b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?</span><br><span class="line">通过子类对象访问一个方法的查找顺序：</span><br><span class="line">在子类中找，有就使用</span><br><span class="line">在父类中找，有就使用</span><br><span class="line">找不到，就报错</span><br><span class="line">(<span class="number">9</span>)两个面试题：</span><br><span class="line">A:Override和Overload的区别?Overload是否可以改变返回值类型?</span><br><span class="line">方法重写：</span><br><span class="line">在子类中，出现和父类中一模一样的方法声明的现象。</span><br><span class="line">方法重载：</span><br><span class="line">同一个类中，出现的方法名相同，参数列表不同的现象。（同类同名不同参）</span><br><span class="line">方法重载能改变返回值类型，因为它和返回值类型无关。</span><br><span class="line"></span><br><span class="line">方法重载：同名同类不同参</span><br><span class="line">同名：方法名相同</span><br><span class="line">同类：同一作用域</span><br><span class="line">不同参（参数列表）：个数、类型、顺序</span><br><span class="line">构造方法的重载</span><br><span class="line">方法重写（覆盖）：</span><br><span class="line">前提条件：必须有继承</span><br><span class="line">必要条件：子类方法和父类中的方法同原型（方法名、</span><br><span class="line">返回值类型、形参列表完全相同)</span><br><span class="line">注意：<span class="number">1</span>、子类方法的访问权限不得低于父类方法的访问权限</span><br><span class="line"> <span class="number">2</span>、子类中抛出的异常不得多于父类方法抛出的异常</span><br><span class="line"> </span><br><span class="line">返回值类型方法名形参列表</span><br><span class="line">方法重写：必须相同相同相同</span><br><span class="line">方法重载：无关相同必须不同</span><br><span class="line"></span><br><span class="line">B:<span class="keyword">this</span>关键字和<span class="keyword">super</span>关键字分别代表什么?以及他们各自的使用场景和作用。</span><br><span class="line"><span class="keyword">this</span>:代表当前类的对象引用</span><br><span class="line"><span class="keyword">super</span>:代表父类存储空间的标识。(可以理解为父类的引用，通过这个东西可以访问父类的成员)</span><br><span class="line">场景和作用：</span><br><span class="line">A:调用成员变量</span><br><span class="line"><span class="keyword">this</span>.成员变量 调用本类的成员变量</span><br><span class="line"><span class="keyword">super</span>.成员变量 调用父类的成员变量</span><br><span class="line">B:调用构造方法</span><br><span class="line"><span class="keyword">this</span>(...)调用本类的构造方法</span><br><span class="line"><span class="keyword">super</span>(...)调用父类的构造方法</span><br><span class="line">注意事项：</span><br><span class="line"><span class="keyword">this</span>(...)或者<span class="keyword">super</span>(...)必须出现在第一条语句上。</span><br><span class="line">如果不是放在第一条语句上，就可能对父类的数据进行了多次初始化，</span><br><span class="line">所以必须放在第一条语句上。</span><br><span class="line">C:调用成员方法</span><br><span class="line"><span class="keyword">this</span>.成员方法 调用本类的成员方法</span><br><span class="line"><span class="keyword">super</span>.成员方法 调用父类的成员方法</span><br><span class="line">(<span class="number">10</span>)数据初始化的面试题</span><br><span class="line">A:一个类的初始化过程</span><br><span class="line">      成员变量进行初始化</span><br><span class="line">     默认初始化</span><br><span class="line">     显示初始化</span><br><span class="line">     构造方法初始化</span><br><span class="line">B:子父类的构造执行过程</span><br><span class="line">    先进行父类初始化，然后进行子类初始化。</span><br><span class="line">C:分层初始化</span><br><span class="line">(<span class="number">11</span>)方法重写：子类中出现了和父类中方法声明一模一样的方法。</span><br><span class="line">方法重写的注意事项:</span><br><span class="line">A:父类中私有方法不能被重写</span><br><span class="line">因为父类私有方法子类根本就无法继承</span><br><span class="line">B:子类重写父类方法时，访问权限不能更低</span><br><span class="line">最好就一致</span><br><span class="line">C:父类静态方法，子类也必须通过静态方法进行重写</span><br><span class="line">其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解</span><br><span class="line">D:子类重写父类方法的时候，最好声明一模一样</span><br><span class="line">方法重写的应用：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。</span><br><span class="line">这样，即沿袭了父类的功能，又定义了子类特有的内容。</span><br><span class="line"></span><br><span class="line">方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值无关。</span><br></pre></td></tr></table></figure><h5 id="7-2-1-初始化基类-129"><a href="#7-2-1-初始化基类-129" class="headerlink" title="7.2.1 初始化基类 129"></a>7.2.1 初始化基类 129</h5><h4 id="7-3-代理-130"><a href="#7-3-代理-130" class="headerlink" title="7.3 代理 130"></a>7.3 代理 130</h4><h4 id="7-4-结合使用组合和继承-132"><a href="#7-4-结合使用组合和继承-132" class="headerlink" title="7.4 结合使用组合和继承 132"></a>7.4 结合使用组合和继承 132</h4><h5 id="7-4-1-确保正确清理-133"><a href="#7-4-1-确保正确清理-133" class="headerlink" title="7.4.1 确保正确清理 133"></a>7.4.1 确保正确清理 133</h5><h5 id="7-4-2-名称屏蔽-135"><a href="#7-4-2-名称屏蔽-135" class="headerlink" title="7.4.2 名称屏蔽 135"></a>7.4.2 名称屏蔽 135</h5><h4 id="7-5-在组合与继承之间选择-137"><a href="#7-5-在组合与继承之间选择-137" class="headerlink" title="7.5 在组合与继承之间选择 137"></a>7.5 在组合与继承之间选择 137</h4><h4 id="7-6-protected关键字-138"><a href="#7-6-protected关键字-138" class="headerlink" title="7.6 protected关键字 138"></a>7.6 protected关键字 138</h4><h4 id="7-7-向上转型-139"><a href="#7-7-向上转型-139" class="headerlink" title="7.7 向上转型 139"></a>7.7 向上转型 139</h4><h5 id="7-7-1-为什么称为向上转型-139"><a href="#7-7-1-为什么称为向上转型-139" class="headerlink" title="7.7.1 为什么称为向上转型 139"></a>7.7.1 为什么称为向上转型 139</h5><h5 id="7-7-2-再论组合与继承-140"><a href="#7-7-2-再论组合与继承-140" class="headerlink" title="7.7.2 再论组合与继承 140"></a>7.7.2 再论组合与继承 140</h5><h4 id="7-8-final关键字-140"><a href="#7-8-final关键字-140" class="headerlink" title="7.8 final关键字 140"></a>7.8 final关键字 140</h4><h5 id="7-8-1-final-数据-140"><a href="#7-8-1-final-数据-140" class="headerlink" title="7.8.1 final 数据 140"></a>7.8.1 final 数据 140</h5><h5 id="7-8-2-final-方法-143"><a href="#7-8-2-final-方法-143" class="headerlink" title="7.8.2 final 方法 143"></a>7.8.2 final 方法 143</h5><h5 id="7-8-3-final-类-144"><a href="#7-8-3-final-类-144" class="headerlink" title="7.8.3 final 类 144"></a>7.8.3 final 类 144</h5><h5 id="7-8-4-有关final的忠告-145"><a href="#7-8-4-有关final的忠告-145" class="headerlink" title="7.8.4 有关final的忠告 145"></a>7.8.4 有关final的忠告 145</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>是最终的意思，可以修饰类，方法，变量</span><br><span class="line">面试题：特点：</span><br><span class="line"><span class="keyword">final</span>可以修饰类，该类不能被继承。</span><br><span class="line"><span class="keyword">final</span>可以修饰方法，该方法不能被重写。(覆盖，复写)</span><br><span class="line"><span class="keyword">final</span>可以修饰变量，该变量不能被重新赋值。因为<span class="keyword">final</span>修饰的变量是常量。</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>修饰变量的初始化时机</span><br><span class="line">A:被<span class="keyword">final</span>修饰的变量只能赋值一次。</span><br><span class="line">B:在构造方法完毕前。(非静态的常量)</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>:最终的(<span class="keyword">finally</span>,finalize)</span><br><span class="line"><span class="number">1</span>、<span class="keyword">final</span>修饰变量：常量，只能访问，不能改变值</span><br><span class="line">定义常量时必须初始化(常量名全大写)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">20</span>;</span><br><span class="line"><span class="number">2</span>、修饰方法：该方法不能被重写</span><br><span class="line"><span class="number">3</span>、修饰类：不允许有子类</span><br><span class="line"></span><br><span class="line">面试题：<span class="keyword">final</span>修饰局部变量的问题</span><br><span class="line">基本类型：基本类型的值不能发生改变。</span><br><span class="line">引用类型：引用类型的地址值不能发生改变，但是，该对象的堆内存的值是可以改变的。</span><br></pre></td></tr></table></figure><h4 id="7-9-初始化及类的加载-145"><a href="#7-9-初始化及类的加载-145" class="headerlink" title="7.9 初始化及类的加载 145"></a>7.9 初始化及类的加载 145</h4><h5 id="7-9-1-继承与初始化-146"><a href="#7-9-1-继承与初始化-146" class="headerlink" title="7.9.1 继承与初始化 146"></a>7.9.1 继承与初始化 146</h5><h4 id="7-10-总结-147"><a href="#7-10-总结-147" class="headerlink" title="7.10 总结 147"></a>7.10 总结 147</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第6章访问权限控制</title>
      <link href="/2019/07/11/2019-07-11-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/11/2019-07-11-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC6%E7%AB%A0%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="第6章-访问权限控制-109"><a href="#第6章-访问权限控制-109" class="headerlink" title="第6章 访问权限控制 109"></a>第6章 访问权限控制 109</h3><h4 id="6-1-包：库单元-110"><a href="#6-1-包：库单元-110" class="headerlink" title="6.1 包：库单元 110"></a>6.1 包：库单元 110</h4><h5 id="6-1-1-代码组织-110"><a href="#6-1-1-代码组织-110" class="headerlink" title="6.1.1 代码组织 110"></a>6.1.1 代码组织 110</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">包(理解)</span><br><span class="line">(<span class="number">1</span>)其实就是文件夹</span><br><span class="line">(<span class="number">2</span>)作用：</span><br><span class="line">A:区分同名的类</span><br><span class="line">B:对类进行分类管理</span><br><span class="line">a:按照功能分</span><br><span class="line">b:按照模块分</span><br><span class="line">(<span class="number">3</span>)包的定义(掌握)</span><br><span class="line"><span class="keyword">package</span> 包名;</span><br><span class="line">多级包用.分开。</span><br><span class="line">(<span class="number">4</span>)注意事项：(掌握)</span><br><span class="line">A:<span class="keyword">package</span>语句必须在文件中的第一条有效语句</span><br><span class="line">B:在一个java文件中，只能有一个<span class="keyword">package</span></span><br><span class="line">C:如果没有<span class="keyword">package</span>，默认就是无包名</span><br><span class="line">(<span class="number">5</span>)带包的编译和运行</span><br><span class="line">A:手动式</span><br><span class="line">B:自动式(掌握)</span><br><span class="line">javac -d . HelloWorld.java</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:导包(掌握)</span><br><span class="line">(<span class="number">1</span>)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字<span class="keyword">import</span>。</span><br><span class="line">(<span class="number">2</span>)格式：</span><br><span class="line"><span class="keyword">import</span> 包名...类名;</span><br><span class="line">另一种：</span><br><span class="line"><span class="keyword">import</span> 包名...*;(不建议)</span><br><span class="line">(<span class="number">3</span>)<span class="keyword">package</span>,<span class="keyword">import</span>,<span class="class"><span class="keyword">class</span>的顺序</span></span><br><span class="line"><span class="class"><span class="title">package</span> &gt; <span class="title">import</span> &gt; <span class="title">class</span></span></span><br></pre></td></tr></table></figure><h5 id="6-1-2-创建独一无二的包名-111"><a href="#6-1-2-创建独一无二的包名-111" class="headerlink" title="6.1.2 创建独一无二的包名 111"></a>6.1.2 创建独一无二的包名 111</h5><h5 id="6-1-3-定制工具库-114"><a href="#6-1-3-定制工具库-114" class="headerlink" title="6.1.3 定制工具库 114"></a>6.1.3 定制工具库 114</h5><h5 id="6-1-4-用-import改变行为-115"><a href="#6-1-4-用-import改变行为-115" class="headerlink" title="6.1.4 用 import改变行为 115"></a>6.1.4 用 import改变行为 115</h5><h5 id="6-1-5-对使用包的忠告-115"><a href="#6-1-5-对使用包的忠告-115" class="headerlink" title="6.1.5 对使用包的忠告 115"></a>6.1.5 对使用包的忠告 115</h5><h4 id="6-2-Java访问权限修饰词-116"><a href="#6-2-Java访问权限修饰词-116" class="headerlink" title="6.2 Java访问权限修饰词 116"></a>6.2 Java访问权限修饰词 116</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)权限修饰符</span><br><span class="line">本类同一个包下不同包下的子类不同包下的无关类</span><br><span class="line"><span class="keyword">private</span>Y</span><br><span class="line">默认   Y  Y</span><br><span class="line"><span class="keyword">protected</span>YYY</span><br><span class="line"><span class="keyword">public</span>YYYY</span><br><span class="line">(<span class="number">2</span>)这四种权限修饰符在任意时刻只能出现一种。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;&#125;</span><br><span class="line">常见的修饰符</span><br><span class="line">(<span class="number">1</span>)分类：</span><br><span class="line">权限修饰符：<span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span></span><br><span class="line">状态修饰符：<span class="keyword">static</span>,<span class="keyword">final</span></span><br><span class="line">抽象修饰符：<span class="keyword">abstract</span></span><br><span class="line">(<span class="number">2</span>)常见的类及其组成的修饰</span><br><span class="line">类：</span><br><span class="line">默认,<span class="keyword">public</span>,<span class="keyword">final</span>,<span class="keyword">abstract</span></span><br><span class="line">常用的：<span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">成员变量：</span><br><span class="line"><span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span>,<span class="keyword">static</span>,<span class="keyword">final</span></span><br><span class="line">常用的：<span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">构造方法：</span><br><span class="line"><span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span></span><br><span class="line">常用的：<span class="keyword">public</span></span><br><span class="line"></span><br><span class="line">成员方法：</span><br><span class="line"><span class="keyword">private</span>,默认,<span class="keyword">protected</span>,<span class="keyword">public</span>,<span class="keyword">static</span>,<span class="keyword">final</span>,<span class="keyword">abstract</span></span><br><span class="line">常用的：<span class="keyword">public</span></span><br><span class="line">(<span class="number">3</span>)另外比较常见的：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> X = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="6-2-1-包访问权限-116"><a href="#6-2-1-包访问权限-116" class="headerlink" title="6.2.1 包访问权限 116"></a>6.2.1 包访问权限 116</h5><h5 id="6-2-2-public-接口访问权限-116"><a href="#6-2-2-public-接口访问权限-116" class="headerlink" title="6.2.2 public:接口访问权限 116"></a>6.2.2 public:接口访问权限 116</h5><h5 id="6-2-3-private-你无法访问-118"><a href="#6-2-3-private-你无法访问-118" class="headerlink" title="6.2.3 private: 你无法访问 118"></a>6.2.3 private: 你无法访问 118</h5><h5 id="6-2-4-protected：继承访问权限-118"><a href="#6-2-4-protected：继承访问权限-118" class="headerlink" title="6.2.4 protected：继承访问权限 118"></a>6.2.4 protected：继承访问权限 118</h5><h4 id="6-3-接口和实现-120"><a href="#6-3-接口和实现-120" class="headerlink" title="6.3 接口和实现 120"></a>6.3 接口和实现 120</h4><h4 id="6-4-类的访问权限-121"><a href="#6-4-类的访问权限-121" class="headerlink" title="6.4 类的访问权限 121"></a>6.4 类的访问权限 121</h4><h4 id="6-5-总结-123"><a href="#6-5-总结-123" class="headerlink" title="6.5 总结 123"></a>6.5 总结 123</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第5章初始化与清理</title>
      <link href="/2019/07/08/2019-07-08-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2019/07/08/2019-07-08-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC5%E7%AB%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="第5章-初始化与清理-76"><a href="#第5章-初始化与清理-76" class="headerlink" title="第5章 初始化与清理 76"></a>第5章 初始化与清理 76</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717153426.png" alt=""></p><h4 id="5-1-用构造器确保初始化-76"><a href="#5-1-用构造器确保初始化-76" class="headerlink" title="5.1 用构造器确保初始化 76"></a>5.1 用构造器确保初始化 76</h4><p>构造方法</p><ul><li>作用概述<ul><li>给对象的数据进行初始化</li></ul></li><li>构造方法格式<ul><li>方法名与类名相同</li><li>没有返回值类型，连void都没有</li><li>没有具体的返回值</li></ul></li><li>构造方法注意事项<ul><li>如果你不提供构造方法，系统会给出默认构造方法</li><li>如果你提供了构造方法，系统将不再提供</li><li>构造方法也是可以重载的</li></ul></li><li>思考题：构造方法中可不可以有return语句呢?<ul><li>可以。而是我们写成这个样子就OK了：return;</li><li>其实，在任何的void类型的方法的最后你都可以写上：return;</li></ul></li></ul><h4 id="5-2-方法重载-77"><a href="#5-2-方法重载-77" class="headerlink" title="5.2 方法重载 77"></a>5.2 方法重载 77</h4><blockquote><p>方法重载:<br>    在同一个类中，方法名相同，参数列表不同。与返回值无关。（同类同名不同参）<br>    参数列表不同：<br>        参数的个数不同。<br>        参数的对应的数据类型不同。<br>方法重载案例<br>    不同的类型的多个同名方法的比较。</p></blockquote><h5 id="5-2-1-区分重载方法-79"><a href="#5-2-1-区分重载方法-79" class="headerlink" title="5.2.1 区分重载方法 79"></a>5.2.1 区分重载方法 79</h5><h5 id="5-2-2-涉及基本类型的重载-79"><a href="#5-2-2-涉及基本类型的重载-79" class="headerlink" title="5.2.2 涉及基本类型的重载 79"></a>5.2.2 涉及基本类型的重载 79</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717154616.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717154656.png" alt=""></p><h5 id="5-2-3-以返回值区分重载方法-82"><a href="#5-2-3-以返回值区分重载方法-82" class="headerlink" title="5.2.3 以返回值区分重载方法 82"></a>5.2.3 以返回值区分重载方法 82</h5><blockquote><p>这是行不通的</p></blockquote><h4 id="5-3-默认构造器-83"><a href="#5-3-默认构造器-83" class="headerlink" title="5.3 默认构造器 83"></a>5.3 默认构造器 83</h4><h4 id="5-4-this关键字-84"><a href="#5-4-this关键字-84" class="headerlink" title="5.4 this关键字 84"></a>5.4 this关键字 84</h4><blockquote><p>this : 是当前类的对象引用。简单的记，它就代表当前类的一个对象。</p><ul><li>注意：谁调用这个方法，在该方法内部的this就代表谁。</li><li>this:哪个对象调用那个方法，this就代表那个对象</li><li>this的场景：<br>解决局部变量隐藏成员变量</li></ul></blockquote><h5 id="5-4-1-在构造器中调用构造器-85"><a href="#5-4-1-在构造器中调用构造器-85" class="headerlink" title="5.4.1 在构造器中调用构造器 85"></a>5.4.1 在构造器中调用构造器 85</h5><h5 id="5-4-2-static的含义-86"><a href="#5-4-2-static的含义-86" class="headerlink" title="5.4.2 static的含义 86"></a>5.4.2 static的含义 86</h5><h4 id="5-5-清理：终结处理和垃圾回收-87"><a href="#5-5-清理：终结处理和垃圾回收-87" class="headerlink" title="5.5 清理：终结处理和垃圾回收 87"></a>5.5 清理：终结处理和垃圾回收 87</h4><h5 id="5-5-1-finalize-的用途何在-87"><a href="#5-5-1-finalize-的用途何在-87" class="headerlink" title="5.5.1 finalize()的用途何在 87"></a>5.5.1 finalize()的用途何在 87</h5><h5 id="5-5-2-你必须实施清理-88"><a href="#5-5-2-你必须实施清理-88" class="headerlink" title="5.5.2 你必须实施清理 88"></a>5.5.2 你必须实施清理 88</h5><h5 id="5-5-3-终结条件-88"><a href="#5-5-3-终结条件-88" class="headerlink" title="5.5.3 终结条件 88"></a>5.5.3 终结条件 88</h5><h5 id="5-5-4-垃圾回收器如何工作-89"><a href="#5-5-4-垃圾回收器如何工作-89" class="headerlink" title="5.5.4 垃圾回收器如何工作 89"></a>5.5.4 垃圾回收器如何工作 89</h5><h4 id="5-6-成员初始化-91"><a href="#5-6-成员初始化-91" class="headerlink" title="5.6 成员初始化 91"></a>5.6 成员初始化 91</h4><h5 id="5-6-1-指定初始化-93"><a href="#5-6-1-指定初始化-93" class="headerlink" title="5.6.1 指定初始化 93"></a>5.6.1 指定初始化 93</h5><h4 id="5-7-构造器初始化-94"><a href="#5-7-构造器初始化-94" class="headerlink" title="5.7 构造器初始化 94"></a>5.7 构造器初始化 94</h4><h5 id="5-7-1-初始化顺序-94"><a href="#5-7-1-初始化顺序-94" class="headerlink" title="5.7.1 初始化顺序 94"></a>5.7.1 初始化顺序 94</h5><h5 id="5-7-2-静态数据的初始化-95"><a href="#5-7-2-静态数据的初始化-95" class="headerlink" title="5.7.2 静态数据的初始化 95"></a>5.7.2 静态数据的初始化 95</h5><h5 id="5-7-3-显式的静态初始化-96"><a href="#5-7-3-显式的静态初始化-96" class="headerlink" title="5.7.3 显式的静态初始化 96"></a>5.7.3 显式的静态初始化 96</h5><h5 id="5-7-4-非静态实例初始化-97"><a href="#5-7-4-非静态实例初始化-97" class="headerlink" title="5.7.4 非静态实例初始化 97"></a>5.7.4 非静态实例初始化 97</h5><h4 id="5-8-数组初始化-98"><a href="#5-8-数组初始化-98" class="headerlink" title="5.8 数组初始化 98"></a>5.8 数组初始化 98</h4><h5 id="5-8-1-可变参数列表-102"><a href="#5-8-1-可变参数列表-102" class="headerlink" title="5.8.1 可变参数列表 102"></a>5.8.1 可变参数列表 102</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(Object... args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//args说明可变参数，0至多个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-9-枚举类型-105"><a href="#5-9-枚举类型-105" class="headerlink" title="5.9 枚举类型 105"></a>5.9 枚举类型 105</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717162907.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717162939.png" alt=""></p><h4 id="5-10-总结-107"><a href="#5-10-总结-107" class="headerlink" title="5.10 总结 107"></a>5.10 总结 107</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第4章控制执行流程</title>
      <link href="/2019/07/06/2019-07-06-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/07/06/2019-07-06-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC4%E7%AB%A0%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="第4章-控制执行流程-64"><a href="#第4章-控制执行流程-64" class="headerlink" title="第4章 控制执行流程 64"></a>第4章 控制执行流程 64</h3><blockquote><p>快速阅读此章</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717152841.png" alt=""></p><h4 id="4-1-true和false-64"><a href="#4-1-true和false-64" class="headerlink" title="4.1 true和false 64"></a>4.1 true和false 64</h4><h4 id="4-2-if-else-64"><a href="#4-2-if-else-64" class="headerlink" title="4.2 if-else 64"></a>4.2 if-else 64</h4><h4 id="4-3-迭代-65"><a href="#4-3-迭代-65" class="headerlink" title="4.3 迭代 65"></a>4.3 迭代 65</h4><h5 id="4-3-1-do-while-65"><a href="#4-3-1-do-while-65" class="headerlink" title="4.3.1 do-while 65"></a>4.3.1 do-while 65</h5><h5 id="4-3-2-for-66"><a href="#4-3-2-for-66" class="headerlink" title="4.3.2 for 66"></a>4.3.2 for 66</h5><h5 id="4-3-3-逗号操作符-67"><a href="#4-3-3-逗号操作符-67" class="headerlink" title="4.3.3 逗号操作符 67"></a>4.3.3 逗号操作符 67</h5><h4 id="4-4-Foreach语法-67"><a href="#4-4-Foreach语法-67" class="headerlink" title="4.4 Foreach语法 67"></a>4.4 Foreach语法 67</h4><h4 id="4-5-return-69"><a href="#4-5-return-69" class="headerlink" title="4.5 return 69"></a>4.5 return 69</h4><h4 id="4-6-break和-continue-69"><a href="#4-6-break和-continue-69" class="headerlink" title="4.6 break和 continue 69"></a>4.6 break和 continue 69</h4><h4 id="4-7-臭名昭著的goto-70"><a href="#4-7-臭名昭著的goto-70" class="headerlink" title="4.7 臭名昭著的goto 70"></a>4.7 臭名昭著的goto 70</h4><blockquote><p>java没有goto，但是有标签</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717153141.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717153327.png" alt=""></p><h4 id="4-8-switch-73"><a href="#4-8-switch-73" class="headerlink" title="4.8 switch 73"></a>4.8 switch 73</h4><h4 id="4-9-总结-75"><a href="#4-9-总结-75" class="headerlink" title="4.9 总结 75"></a>4.9 总结 75</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第3章操作符</title>
      <link href="/2019/07/04/2019-07-04-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC3%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2019/07/04/2019-07-04-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC3%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="第3章-操作符-38"><a href="#第3章-操作符-38" class="headerlink" title="第3章 操作符 38"></a>第3章 操作符 38</h3><blockquote><p>正如作者所说，第三、第四章可快速浏览</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717151223.png" alt=""></p><h4 id="3-1-更简单的打印语句-38"><a href="#3-1-更简单的打印语句-38" class="headerlink" title="3.1 更简单的打印语句 38"></a>3.1 更简单的打印语句 38</h4><h4 id="3-2-使用Java操作符-39"><a href="#3-2-使用Java操作符-39" class="headerlink" title="3.2 使用Java操作符 39"></a>3.2 使用Java操作符 39</h4><h4 id="3-3-优先级-39"><a href="#3-3-优先级-39" class="headerlink" title="3.3 优先级 39"></a>3.3 优先级 39</h4><h4 id="3-4-赋值-39"><a href="#3-4-赋值-39" class="headerlink" title="3.4 赋值 39"></a>3.4 赋值 39</h4><h5 id="3-4-1-方法调用中的别名问题-40"><a href="#3-4-1-方法调用中的别名问题-40" class="headerlink" title="3.4.1 方法调用中的别名问题 40"></a>3.4.1 方法调用中的别名问题 40</h5><h4 id="3-5-算术操作符-41"><a href="#3-5-算术操作符-41" class="headerlink" title="3.5 算术操作符 41"></a>3.5 算术操作符 41</h4><h5 id="3-5-1-一元加、减操作符-43"><a href="#3-5-1-一元加、减操作符-43" class="headerlink" title="3.5.1 一元加、减操作符 43"></a>3.5.1 一元加、减操作符 43</h5><h4 id="3-6-自动递增和递减-43"><a href="#3-6-自动递增和递减-43" class="headerlink" title="3.6 自动递增和递减 43"></a>3.6 自动递增和递减 43</h4><h4 id="3-7-关系操作符-44"><a href="#3-7-关系操作符-44" class="headerlink" title="3.7 关系操作符 44"></a>3.7 关系操作符 44</h4><h5 id="3-7-1-测试对象的等价性-44"><a href="#3-7-1-测试对象的等价性-44" class="headerlink" title="3.7.1 测试对象的等价性 44"></a>3.7.1 测试对象的等价性 44</h5><h4 id="3-8-逻辑操作符-45"><a href="#3-8-逻辑操作符-45" class="headerlink" title="3.8 逻辑操作符 45"></a>3.8 逻辑操作符 45</h4><h5 id="3-8-1-短路-46"><a href="#3-8-1-短路-46" class="headerlink" title="3.8.1 短路 46"></a>3.8.1 短路 46</h5><h4 id="3-9-直接常量-47"><a href="#3-9-直接常量-47" class="headerlink" title="3.9 直接常量 47"></a>3.9 直接常量 47</h4><h5 id="3-9-1-指数记数法-48"><a href="#3-9-1-指数记数法-48" class="headerlink" title="3.9.1 指数记数法 48"></a>3.9.1 指数记数法 48</h5><h4 id="3-10-按位操作符-49"><a href="#3-10-按位操作符-49" class="headerlink" title="3.10 按位操作符 49"></a>3.10 按位操作符 49</h4><h4 id="3-11-移位操作符-49"><a href="#3-11-移位操作符-49" class="headerlink" title="3.11 移位操作符 49"></a>3.11 移位操作符 49</h4><blockquote><p>只能用于整型整数</p><p>Integer.toBinaryString() : 转为二进制字符串</p></blockquote><h4 id="3-12-三元操作符-if-else-52"><a href="#3-12-三元操作符-if-else-52" class="headerlink" title="3.12 三元操作符 if-else 52"></a>3.12 三元操作符 if-else 52</h4><h4 id="3-13-字符串操作符-和-53"><a href="#3-13-字符串操作符-和-53" class="headerlink" title="3.13 字符串操作符 + 和 += 53"></a>3.13 字符串操作符 + 和 += 53</h4><h4 id="3-14-使用操作符时常犯的错误-54"><a href="#3-14-使用操作符时常犯的错误-54" class="headerlink" title="3.14 使用操作符时常犯的错误 54"></a>3.14 使用操作符时常犯的错误 54</h4><h4 id="3-15-类型转换操作符-54"><a href="#3-15-类型转换操作符-54" class="headerlink" title="3.15 类型转换操作符 54"></a>3.15 类型转换操作符 54</h4><h5 id="3-15-1-截尾和舍入-55"><a href="#3-15-1-截尾和舍入-55" class="headerlink" title="3.15.1 截尾和舍入 55"></a>3.15.1 截尾和舍入 55</h5><h5 id="3-15-2-提升-56"><a href="#3-15-2-提升-56" class="headerlink" title="3.15.2 提升 56"></a>3.15.2 提升 56</h5><h4 id="3-16-Java没有sizeof-56"><a href="#3-16-Java没有sizeof-56" class="headerlink" title="3.16 Java没有sizeof 56"></a>3.16 Java没有sizeof 56</h4><h4 id="3-17-操作符小结-56"><a href="#3-17-操作符小结-56" class="headerlink" title="3.17 操作符小结 56"></a>3.17 操作符小结 56</h4><h4 id="3-18-总结-63"><a href="#3-18-总结-63" class="headerlink" title="3.18 总结 63"></a>3.18 总结 63</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第2章一切都是对象</title>
      <link href="/2019/07/03/2019-07-03-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC2%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/07/03/2019-07-03-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC2%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="第2章-一切都是对象-21"><a href="#第2章-一切都是对象-21" class="headerlink" title="第2章 一切都是对象 21"></a>第2章 一切都是对象 21</h3><blockquote><p>这一章将开始介绍Java程序的基本组成，但是，也会令你“欲仙欲死”。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717112848.png" alt=""></p><h4 id="2-1-用引用操纵对象-21"><a href="#2-1-用引用操纵对象-21" class="headerlink" title="2.1 用引用操纵对象 21"></a>2.1 用引用操纵对象 21</h4><blockquote><p>这里作者用遥控器与电视机作为讲解引用与对象的关系，很符合要义，我们一般是操控遥控器，在程序中我们也是一般操作对象的引用。这一节引出对象。</p></blockquote><h4 id="2-2-必须由你创建所有对象-22"><a href="#2-2-必须由你创建所有对象-22" class="headerlink" title="2.2 必须由你创建所有对象 22"></a>2.2 必须由你创建所有对象 22</h4><blockquote><p>这一节继承上一节，对对象需要初始化，new 关键字表名“给我一个新的对象”</p></blockquote><h5 id="2-2-1-存储到什么地方-22"><a href="#2-2-1-存储到什么地方-22" class="headerlink" title="2.2.1 存储到什么地方 22"></a>2.2.1 存储到什么地方 22</h5><ul><li>寄存器：处理器内部，速度最快，我们无法直接控制</li><li>堆栈：RAM中，速度仅次于寄存器；堆栈指针向上移动，释放那些内存；向下移动，分配新的内存；引用存于此处。</li><li>堆：RAM内，用于存放所有的Java对象。</li><li>常量存储：常量值通常直接存放在程序代码内部</li><li>非RAM存储：2个基本的例子——流对象以及持久化对象，即存活于程序之外的数据。</li></ul><h5 id="2-2-2-特例：基本类型-23"><a href="#2-2-2-特例：基本类型-23" class="headerlink" title="2.2.2 特例：基本类型 23"></a>2.2.2 特例：基本类型 23</h5><blockquote><p>基本数据类型存储于堆栈中</p></blockquote><p>类型分类：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717135734.png" alt=""></p><p>数据类型转换之默认转换顺序：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140126.png" alt=""></p><p>类型范围：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140241.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140514.png" alt=""></p><h5 id="2-2-3-Java中的数组-24"><a href="#2-2-3-Java中的数组-24" class="headerlink" title="2.2.3 Java中的数组 24"></a>2.2.3 Java中的数组 24</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717140820.png" alt=""></p><h4 id="2-3-永远不需要销毁对象-24"><a href="#2-3-永远不需要销毁对象-24" class="headerlink" title="2.3 永远不需要销毁对象 24"></a>2.3 永远不需要销毁对象 24</h4><h5 id="2-3-1-作用域-24"><a href="#2-3-1-作用域-24" class="headerlink" title="2.3.1 作用域 24"></a>2.3.1 作用域 24</h5><blockquote><p>变量定义在哪个大括号内，它就在这个大括号内有效。并且，在同一个大括号内不能同时定义同名的变量。</p></blockquote><h5 id="2-3-2-对象的作用域-25"><a href="#2-3-2-对象的作用域-25" class="headerlink" title="2.3.2 对象的作用域 25"></a>2.3.2 对象的作用域 25</h5><blockquote><p>一般对象在定义的大括号内消失的是其引用，其对象本身继续占据内存空间。这就牵涉到了Java的垃圾回收机制。</p></blockquote><h4 id="2-4-创建新的数据类型：类-25"><a href="#2-4-创建新的数据类型：类-25" class="headerlink" title="2.4 创建新的数据类型：类 25"></a>2.4 创建新的数据类型：类 25</h4><blockquote><p>引出类class关键字</p></blockquote><h5 id="2-4-1-字段和方法-26"><a href="#2-4-1-字段和方法-26" class="headerlink" title="2.4.1 字段和方法 26"></a>2.4.1 字段和方法 26</h5><blockquote><p>字段–&gt;成员变量;方法–&gt;成员方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Java中的参数传递问题：</span><br><span class="line">基本类型：形式参数的改变对实际参数没有影响。</span><br><span class="line">引用类型：形式参数的改变直接影响实际参数。</span><br><span class="line">成员变量和局部变量的区别?</span><br><span class="line">A:在类中的位置不同</span><br><span class="line">成员变量：在类中方法外</span><br><span class="line">局部变量：在方法定义中或者方法声明上</span><br><span class="line">B:在内存中的位置不同</span><br><span class="line">成员变量：在堆内存</span><br><span class="line">局部变量：在栈内存</span><br><span class="line">C:生命周期不同</span><br><span class="line">成员变量：随着对象的创建而存在，随着对象的消失而消失</span><br><span class="line">局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</span><br><span class="line">D:初始化值不同</span><br><span class="line">成员变量：有默认初始化值</span><br><span class="line">局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。</span><br><span class="line">注意事项：</span><br><span class="line">局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</span><br><span class="line">如果你看到了一个方法的形式参数是一个类类型(引用类型)，</span><br><span class="line">这里其实需要的是该类的对象。</span><br></pre></td></tr></table></figure><h4 id="2-5-方法、参数和返回值-27"><a href="#2-5-方法、参数和返回值-27" class="headerlink" title="2.5 方法、参数和返回值 27"></a>2.5 方法、参数和返回值 27</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)方法：就是完成特定功能的代码块。</span><br><span class="line">注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。</span><br><span class="line">(<span class="number">2</span>)格式：</span><br><span class="line">修饰符 返回值类型 方法名(参数类型 参数名<span class="number">1</span>,参数类型 参数名<span class="number">2</span>...) &#123;</span><br><span class="line">方法体语句;</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修饰符：目前就用 <span class="keyword">public</span> <span class="keyword">static</span>。后面再详细讲解其他修饰符</span><br><span class="line">返回值类型：就是功能结果的数据类型</span><br><span class="line">方法名：就是起了一个名字，方便我们调用该方法。</span><br><span class="line">参数类型：就是参数的数据类型</span><br><span class="line">参数名：就是变量</span><br><span class="line">参数分类：</span><br><span class="line">实参：实际参与运算的数据</span><br><span class="line">形参：方法上定义的，用于接收实际参数的变量</span><br><span class="line">方法体语句：就是完成功能的代码块</span><br><span class="line"><span class="keyword">return</span>：结束方法</span><br><span class="line">返回值：就是功能的结果，由<span class="keyword">return</span>带给调用者。</span><br><span class="line">(<span class="number">3</span>)两个明确：</span><br><span class="line">返回值类型：结果的数据类型</span><br><span class="line">参数列表：参数的个数及对应的数据类型</span><br><span class="line">(<span class="number">4</span>)方法调用</span><br><span class="line">A:有明确返回值的方法</span><br><span class="line">a:单独调用，没有意义</span><br><span class="line">b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。</span><br><span class="line">c:赋值调用，推荐方案</span><br><span class="line">B:<span class="keyword">void</span>类型修饰的方法</span><br><span class="line">a:单独调用</span><br><span class="line">(<span class="number">6</span>)方法的注意事项</span><br><span class="line">A:方法不调用不执行</span><br><span class="line">B:方法之间是平级关系，不能嵌套定义</span><br><span class="line">C:方法定义的时候，参数是用<span class="string">','</span>隔开的</span><br><span class="line">D:方法在调用的时候，不用在传递数据类型</span><br><span class="line">E:如果方法有明确的返回值类型，就必须有<span class="keyword">return</span>语句返回。</span><br></pre></td></tr></table></figure><h5 id="2-5-1-参数列表-27"><a href="#2-5-1-参数列表-27" class="headerlink" title="2.5.1 参数列表 27"></a>2.5.1 参数列表 27</h5><h4 id="2-6-构建一个Java程序-28"><a href="#2-6-构建一个Java程序-28" class="headerlink" title="2.6 构建一个Java程序 28"></a>2.6 构建一个Java程序 28</h4><h5 id="2-6-1-名字可见性-28"><a href="#2-6-1-名字可见性-28" class="headerlink" title="2.6.1 名字可见性 28"></a>2.6.1 名字可见性 28</h5><blockquote><p>名字空间，包</p></blockquote><h5 id="2-6-2-运用其他构件-28"><a href="#2-6-2-运用其他构件-28" class="headerlink" title="2.6.2 运用其他构件 28"></a>2.6.2 运用其他构件 28</h5><blockquote><p>import关键字</p></blockquote><h5 id="2-6-3-static-关键字-29"><a href="#2-6-3-static-关键字-29" class="headerlink" title="2.6.3 static 关键字 29"></a>2.6.3 static 关键字 29</h5><blockquote><ul><li><p>(1)静态的意思。</p><ul><li>可以修饰成员变量和成员方法。</li><li>针对多个对象有共同的这样的成员变量值的时候,Java就提供了一个关键字来修饰：static。</li></ul></li><li><p>(2)静态的特点：</p><ul><li>A:随着类的加载而加载</li><li>B:优先与对象存在</li><li>C:被类的所有对象共享<br>这其实也是我们判断该不该使用静态的依据。<ul><li>举例：饮水机和水杯的问题思考</li></ul></li><li>D:可以通过类名调用<br>既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。</li></ul></li><li><p>(3)静态的内存图</p><ul><li>静态的内容在方法区的静态区</li></ul></li><li><p>(4)静态的注意事项；</p><ul><li>A:在静态方法中没有this对象</li><li>B:静态只能访问静态</li></ul></li><li><p>(5)静态变量和成员变量的区别</p><ul><li>A:所属不同<ul><li>静态变量：属于类，类变量</li><li>成员变量：属于对象，对象变量，实例变量</li></ul></li><li>B:内存位置不同<ul><li>静态变量：方法区的静态区</li><li>成员变量：堆内存</li></ul></li><li>C:生命周期不同<ul><li>静态变量：静态变量是随着类的加载而加载，随着类的消失而消失</li><li>成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失</li></ul></li><li>D:调用不同<ul><li>静态变量：可以通过对象名调用，也可以通过类名调用</li><li>成员变量：只能通过对象名调用</li></ul></li></ul></li><li><p>(6)main方法是静态的</p><ul><li><p>public:权限最大</p></li><li><p>static:不用创建对象调用</p></li><li><p>void:返回值给jvm没有意义</p></li><li><p>main:就是一个常见的名称。</p></li><li><p>String[] args:可以接收数据，提供程序的灵活性</p></li><li><p>main方法的格式讲解：</p><ul><li><p>public static void main(String[] args) {…}</p></li><li><p>public:公共的，访问权限是最大的。由于main方法是被jvm调用，所以权限要够大。</p></li><li><p>static:静态的，不需要创建对象，通过类名就可以。方便jvm的调用。</p></li><li><p>void:因为我们曾经说过，方法的返回值是返回给调用者，而main方法是被jvm调用。你返回内容给jvm没有意义。</p></li><li><p>main:是一个常见的方法入口。我见过的语言都是以main作为入口。</p></li><li><p>String[] args:这是一个字符串数组。值去哪里了?<br>这个东西到底有什么用啊?怎么给值啊?</p></li></ul><p>这个东西早期是为了接收键盘录入的数据的。<br>格式是：</p><pre><code>java MainDemo hello world java</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MainDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;System.out.println(args); &#x2F;&#x2F;[Ljava.lang.String;@175078b</span><br><span class="line">&#x2F;&#x2F;System.out.println(args.length); &#x2F;&#x2F;0</span><br><span class="line">&#x2F;&#x2F;System.out.println(args[0]); &#x2F;&#x2F;ArrayIndexOutOfBoundsException</span><br><span class="line">&#x2F;&#x2F;接收数据后</span><br><span class="line">System.out.println(args); </span><br><span class="line">System.out.println(args.length); </span><br><span class="line">&#x2F;&#x2F;System.out.println(args[0]); </span><br><span class="line">for(int x&#x3D;0; x&lt;args.length; x++) &#123;</span><br><span class="line">System.out.println(args[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A:在静态方法中是没有this关键字的</p><ul><li>如何理解呢?<ul><li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li><li>静态比对象先存在。</li></ul></li></ul></li><li><p>B:静态方法只能访问静态的成员变量和静态的成员方法</p><ul><li>静态方法：<ul><li>成员变量：只能访问静态变量</li><li>成员方法：只能访问静态成员方法</li></ul></li><li>非静态方法：<ul><li>成员变量：可以是静态的，也可以是非静态的</li><li>成员方法：可是是静态的成员方法，也可以是非静态的成员方法。</li></ul></li><li>简单记：<ul><li>静态只能访问静态。</li></ul></li></ul></li></ul></li></ul></blockquote><h4 id="2-7-你的第一个Java程序-30"><a href="#2-7-你的第一个Java程序-30" class="headerlink" title="2.7 你的第一个Java程序 30"></a>2.7 你的第一个Java程序 30</h4><h5 id="2-7-1-编译和运行-31"><a href="#2-7-1-编译和运行-31" class="headerlink" title="2.7.1 编译和运行 31"></a>2.7.1 编译和运行 31</h5><h4 id="2-8-注释和嵌入式文档-32"><a href="#2-8-注释和嵌入式文档-32" class="headerlink" title="2.8 注释和嵌入式文档 32"></a>2.8 注释和嵌入式文档 32</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 多行注释</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure><h5 id="2-8-1-注释文档-32"><a href="#2-8-1-注释文档-32" class="headerlink" title="2.8.1 注释文档 32"></a>2.8.1 注释文档 32</h5><blockquote><p>javadoc</p></blockquote><h5 id="2-8-2-语法-33"><a href="#2-8-2-语法-33" class="headerlink" title="2.8.2 语法 33"></a>2.8.2 语法 33</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @注释文档</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><blockquote><p>javadoc只能为public 和 protected 成员进行文档注释</p></blockquote><h5 id="2-8-3-嵌入式HTML-33"><a href="#2-8-3-嵌入式HTML-33" class="headerlink" title="2.8.3 嵌入式HTML 33"></a>2.8.3 嵌入式HTML 33</h5><blockquote><p>支持html标记</p></blockquote><h5 id="2-8-4-一些标签示例-34"><a href="#2-8-4-一些标签示例-34" class="headerlink" title="2.8.4 一些标签示例 34"></a>2.8.4 一些标签示例 34</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @see: classname 引用其他类</span></span><br><span class="line"><span class="comment"> * @link: package.class#member label 用于行内，类似see</span></span><br><span class="line"><span class="comment"> * @docRoot: 产生到文档根目录的相对路径</span></span><br><span class="line"><span class="comment"> * @inheritDoc: 从当前类的最直接基类中继承相关文档到当前注释中</span></span><br><span class="line"><span class="comment"> * @version: version-information </span></span><br><span class="line"><span class="comment"> * @since: 指定代码版本，一般是jdk版本</span></span><br><span class="line"><span class="comment"> * @param: 参数</span></span><br><span class="line"><span class="comment"> * @return: 返回值</span></span><br><span class="line"><span class="comment"> * @throws: 异常</span></span><br><span class="line"><span class="comment"> * @Deprecated: 表名已不适用</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="2-8-5-文档示例-35"><a href="#2-8-5-文档示例-35" class="headerlink" title="2.8.5 文档示例 35"></a>2.8.5 文档示例 35</h5><h4 id="2-9-编码风格-36"><a href="#2-9-编码风格-36" class="headerlink" title="2.9 编码风格 36"></a>2.9 编码风格 36</h4><blockquote><p>类首字母大写；驼峰命名法</p></blockquote><h4 id="2-10-总结-36"><a href="#2-10-总结-36" class="headerlink" title="2.10 总结 36"></a>2.10 总结 36</h4><h4 id="2-11-练习-37"><a href="#2-11-练习-37" class="headerlink" title="2.11 练习 37"></a>2.11 练习 37</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想-第一章对象导论</title>
      <link href="/2019/07/01/2019-07-01-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC1%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
      <url>/2019/07/01/2019-07-01-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC1%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="第1章-对象导论-1"><a href="#第1章-对象导论-1" class="headerlink" title="第1章 对象导论 1"></a>第1章 对象导论 1</h3><blockquote><p>在第一章最前面作者就说明了一些话语，这些话语已经很明确的说出了这一章甚至这本书的某些特性：偏重与讲解Java这一面向对象编程语言与面对过程编程语言以及C++的区别，从Java其起源思想讲解Java语言特点以及用法，与市面上大部分教材以及视频直接讲解知识点不同，所以阅读这本书最重要的是要理解面向对象编程的思想。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190717111115.png" alt=""></p><blockquote><p>在阅读第一章的时候，确实看的很费神，对于作者的思想能理解，但是自己却无法转为自己的语言，因此，这一章只列出下列目录，留待以后再补上，毕竟作者自己也说了，可跳过此章</p></blockquote><h4 id="1-1-抽象过程-1"><a href="#1-1-抽象过程-1" class="headerlink" title="1.1 抽象过程 1"></a>1.1 抽象过程 1</h4><h4 id="1-2-每个对象都有一个接口-2"><a href="#1-2-每个对象都有一个接口-2" class="headerlink" title="1.2 每个对象都有一个接口 2"></a>1.2 每个对象都有一个接口 2</h4><h4 id="1-3-每个对象都提供服务-4"><a href="#1-3-每个对象都提供服务-4" class="headerlink" title="1.3 每个对象都提供服务 4"></a>1.3 每个对象都提供服务 4</h4><h4 id="1-4-被隐藏的具体实现-4"><a href="#1-4-被隐藏的具体实现-4" class="headerlink" title="1.4 被隐藏的具体实现 4"></a>1.4 被隐藏的具体实现 4</h4><h4 id="1-5-复用具体实现-5"><a href="#1-5-复用具体实现-5" class="headerlink" title="1.5 复用具体实现 5"></a>1.5 复用具体实现 5</h4><h4 id="1-6-继承-6"><a href="#1-6-继承-6" class="headerlink" title="1.6 继承 6"></a>1.6 继承 6</h4><h5 id="1-6-1-“是一个”与“像是一个”关系-8"><a href="#1-6-1-“是一个”与“像是一个”关系-8" class="headerlink" title="1.6.1 “是一个”与“像是一个”关系 8"></a>1.6.1 “是一个”与“像是一个”关系 8</h5><h4 id="1-7-伴随多态的可互换对象-8"><a href="#1-7-伴随多态的可互换对象-8" class="headerlink" title="1.7 伴随多态的可互换对象 8"></a>1.7 伴随多态的可互换对象 8</h4><h4 id="1-8-单根继承结构-11"><a href="#1-8-单根继承结构-11" class="headerlink" title="1.8 单根继承结构 11"></a>1.8 单根继承结构 11</h4><h4 id="1-9-容器-11"><a href="#1-9-容器-11" class="headerlink" title="1.9 容器 11"></a>1.9 容器 11</h4><h5 id="1-9-1-参数化类型（范型）-12"><a href="#1-9-1-参数化类型（范型）-12" class="headerlink" title="1.9.1 参数化类型（范型） 12"></a>1.9.1 参数化类型（范型） 12</h5><h4 id="1-10-对象的创建和生命期-13"><a href="#1-10-对象的创建和生命期-13" class="headerlink" title="1.10 对象的创建和生命期 13"></a>1.10 对象的创建和生命期 13</h4><h4 id="1-11-异常处理：处理错误-14"><a href="#1-11-异常处理：处理错误-14" class="headerlink" title="1.11 异常处理：处理错误 14"></a>1.11 异常处理：处理错误 14</h4><h4 id="1-12-并发编程-14"><a href="#1-12-并发编程-14" class="headerlink" title="1.12 并发编程 14"></a>1.12 并发编程 14</h4><h4 id="1-13-Java与Internet-15"><a href="#1-13-Java与Internet-15" class="headerlink" title="1.13 Java与Internet 15"></a>1.13 Java与Internet 15</h4><h5 id="1-13-1-Web是什么-15"><a href="#1-13-1-Web是什么-15" class="headerlink" title="1.13.1 Web是什么 15"></a>1.13.1 Web是什么 15</h5><h5 id="1-13-2-客户端编程-16"><a href="#1-13-2-客户端编程-16" class="headerlink" title="1.13.2 客户端编程 16"></a>1.13.2 客户端编程 16</h5><h5 id="1-13-3-服务器端编程-19"><a href="#1-13-3-服务器端编程-19" class="headerlink" title="1.13.3 服务器端编程 19"></a>1.13.3 服务器端编程 19</h5><h4 id="1-14-总结-20"><a href="#1-14-总结-20" class="headerlink" title="1.14 总结 20"></a>1.14 总结 20</h4><hr><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程思想介绍以及资源下载</title>
      <link href="/2019/06/30/2019-06-30-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-0-%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/"/>
      <url>/2019/06/30/2019-06-30-Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-0-%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Java编程思想介绍"><a href="#Java编程思想介绍" class="headerlink" title="Java编程思想介绍"></a>Java编程思想介绍</h1><hr><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/adolphmaster/hexo-next/master/blogPicture/20190716001.jpg" alt=""></p><blockquote><h2 id="书籍相关资源："><a href="#书籍相关资源：" class="headerlink" title="书籍相关资源："></a>书籍相关资源：</h2><p>pdf文档链接：<a href="https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1yuWb_kI0sB3yHLBndPcyEg</a> 提取码：scvw<br>书中demo： <a href="https://github.com/BruceEckel/TIJ4-code" target="_blank" rel="noopener">https://github.com/BruceEckel/TIJ4-code</a><br>Thinking in Java 4th英文版的课后习题答案: <a href="http://greggordon.org/java/tij4/solutions.htm" target="_blank" rel="noopener">http://greggordon.org/java/tij4/solutions.htm</a> </p><p><strong>注意</strong>：<br>　　中文版有一页（文件页码548，书籍页码515）图像缺失。不过没关系，只是一页源码以及简单说明，不影响整体知识。<br>　　网上的目前找到的所有版本此页都是缺失的。<br>　　实在要看，可以看对应的英文版本（文件658页，书籍636页），没什么难度。<br><strong>代码引入</strong>：<br>　　注解一章中，按照书中的jar包引入代码会报错，解决是引入一个另外的包，参考如下： <a href="http://blog.csdn.net/sinat_36246371/article/details/53170166" target="_blank" rel="noopener">http://blog.csdn.net/sinat_36246371/article/details/53170166</a></p><p>书籍相关资源信息参考博客：<a href="https://www.cnblogs.com/da19951208/p/9469210.html" target="_blank" rel="noopener">https://www.cnblogs.com/da19951208/p/9469210.html</a></p></blockquote><p><strong>说明以及评价：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">《Java编程思想（第4版）》以Java最新的版本JDK5.0为基础，在第3版的基础上，添加了最新的语言特性，并且对第3版的结构进行了调整，使得所有章节的安排更加遵照循序渐进的特点，同时每一章的内容在分量上也都更加均衡，这使读者能够更加容易地阅读本书并充分了解每章所讲述的内容。在这里我们再次向Bruce Eckel致敬，他不但向我们展示了什么样的书籍才是经典书籍，而且还展示了经典书籍怎样才能精益求精，长盛不衰。</span><br><span class="line"></span><br><span class="line">Java已经成为了编程语言的骄子。我们可以看到，越来越多的大学在教授数据结构、程序设计和算法分析等课程时，选择以Java语言为载体。这说明Java语言已经是人们构建软件系统时主要使用的一种编程语言。但是，掌握好Java语言并不是一件可以轻松完成的任务，如何真正掌握Java语言，从而编写出健壮的、高效的以及灵活的程序是Java程序员们面临的重大挑战。</span><br><span class="line"></span><br><span class="line">《Java编程思想（第4版）》就是一本能够让Java程序员轻松面对这一挑战，并最终取得胜利的经典书籍。本书深入浅出、循序渐进地把我们领入Java的世界，让我们在不知不觉中就学会了用Java的思想去考虑问题、解决问题。本书不仅适合Java的初学者，更适合于有经验的Java程序员，这正是本书的魅力所在。但是，书中并没有涵盖Java所有的类、接口和方法，因此，如果你希望将它当作Java的字典来使用，那么显然就要失望了。</span><br><span class="line"></span><br><span class="line">我们在翻译本书的过程中力求忠于原著，为了保持连贯性，对原书第3版中仍然保持不变的部分，我们对译文除了个别地方之外，也没做修改。对于本书中出现的大量的专业术语尽量遵循标准的译法，并在有可能引起歧义之处注有英文原文，以方便读者对照与理解。</span><br><span class="line"></span><br><span class="line">全书由陈昊鹏翻译，郭嘉也参与了部分翻译工作。由于水平有限，书中出现错误与不妥之处在所难免，恳请读者批评指正。 </span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　译 者 </span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　2007年5月</span><br><span class="line"></span><br><span class="line">读者评价</span><br><span class="line">· 每个Java程序员都应该反复研读《Think in Java》，并且随身携带以便随时参考。书中的练习颇具挑战性，而有关集合的章节已臻化境！本书不仅帮助我通过了Sun Certified Java Programmer考试，而且它还是我遇到Java问题时，求助的首选书籍。</span><br><span class="line">　　　　　　　　　　　　 ——Jim Pleger, Loudoun郡（弗吉尼亚）政府</span><br><span class="line"></span><br><span class="line">· 这本书比我见过的所有Java书都要好得多。循序渐进……非常完整，并搭配恰到好处的范例，睿智而不呆板的解说……这使本书的品质比别的书“超出了一个数量级”。与其他Java书相比，我发现本书考虑非常周全、前后一致、理性坦诚、文笔流畅、用词准确。恕我直言，这是一本学习Java的理想书籍。</span><br><span class="line">　　　　　　　　　　　　 ——Anatoly Vorobey, 以色列海法Technion大学</span><br><span class="line"></span><br><span class="line">· 在我所见过的程序设计指南中（无论何种语言），这绝对是最好的一本。</span><br><span class="line">　　　　　　　　　　　　 ——Joakim Ziegler, FIX系统管理员</span><br><span class="line"></span><br><span class="line">· 感谢您这本精彩的、令人愉快的Java书。</span><br><span class="line">　　　　　　　　　　　　 ——Dr. Gavin Pillay, 登记员, 南非爱德华八世医院</span><br><span class="line"></span><br><span class="line">· 再次感谢您这本杰出的书。作为一名不用C语言的程序员，我曾经感到（学习Java）步履维艰，但是您的书让我一目了然。能够一开始就理解底层的概念和原理，而不是通过反复试验来自己建立概念模型，真是太棒了。我希望能在不久的将来参加您的讨论课。</span><br><span class="line">　　　　　　　　　　　　 ——Randall R. Hawley, 自动化工程师, Eli Lilly公司</span><br><span class="line"></span><br><span class="line">· 我见过的计算机著作中，这是最好的一本。</span><br><span class="line">　　　　　　　　　　　　 ——Tom Holland</span><br><span class="line"></span><br><span class="line">· 这是我读过的编程语言书中最棒的一本……有关Java的书中最棒的一本。</span><br><span class="line">　　　　　　　　　　　　 ——Ravindra Pai, Oracle 公司, SUNOS 产品线部门</span><br><span class="line"></span><br><span class="line">· 我见过的最好的Java书！您做了一项了不起的工作。您的深度令人赞叹，出版的时候，我一定会购买一本。我从1996年10月就开始学习Java，其间也读过好几本这方面的书，但我觉得您这本才是“必读书”。最近几个月，我一直集中精力于一个完全用Java开发的产品。您的书帮我夯实了某些不牢固的知识点，并拓展了我的知识面。我甚至在面试签约者时引用书中的内容，作为参考的依据。通过问一些我从书中学到的知识，来判断他们对Java的理解程度（例如，数组与Vector的区别）。您的书真是伟大！</span><br><span class="line">　　　　　　　　　　　　 ——Steve Wilkinson, 资深专家, MCI 电信公司</span><br><span class="line"></span><br><span class="line">· 伟大的书。迄今为止我见过的最佳Java书籍。</span><br><span class="line">　　　　　　　　　　　　 ——Jeff Sinclair, 软件工程师, Kestral 计算技术公司</span><br><span class="line"></span><br><span class="line">? 感谢您的《Thinking in Java》。早就应该有人把仅仅介绍语言的教程编写成富有思想、分析透彻的入门指南，而不是局限于“某个公司”的语言。我阅读过许多这方面的书，但只有您和Patrick Winston的作品给我印象深刻。我已经向客户推荐这本书。再次谢谢您。</span><br><span class="line">　　　　　　　　　　　　 ——Richard Brooks, Java 咨询顾问, 达拉斯Sun专业服务部门</span><br><span class="line"></span><br><span class="line">· Bruce，您的书真是太棒了！您的讲解清晰明确。通过这本迷人的书，我获得了大量Java知识。练习题也同样令人着迷，它们对巩固各章阐述的知识起到了很好的效果。我期待您的更多作品。对您的这本著作致以谢意。阅读了《Thinking in Java》之后，我的代码质量大有改善。为此我要感激您，我相信，维护我的代码的程序员同样也会感激您。</span><br><span class="line">　　　　　　　　　　　　 ——Yvonne Watkins, Discover 技术公司</span><br><span class="line"></span><br><span class="line">作者简介</span><br><span class="line">作者：（美）埃史尔 译者：陈昊鹏</span><br><span class="line"></span><br><span class="line">Bruce Eckel是MindView公司的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想第2卷》（这两本书的英文影印版及中文版均已由机械工业出版社引进出版）及其他著作。他已经发表了150多篇论文，还经常参加世界各地的研讨会并进行演讲。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建博客</title>
      <link href="/2019/06/29/2019-06-29-Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/06/29/2019-06-29-Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：</strong><a href="https://adolphmaster.github.io/" target="_blank" rel="noopener">https://adolphmaster.github.io</a></li><li><strong>文章地址：</strong><a href="https://adolphmaster.github.io/2019/07/07/Hexo+GitHub搭建博客/" target="_blank" rel="noopener">https://adolphmaster.github.io/2019/07/07/Hexo+GitHub搭建博客/</a></li><li><strong>编&emsp;&emsp;者：adolphMaster</strong></li></ul><hr><p>[TOC]</p><h1 id="Hexo-GitHub搭建博客"><a href="#Hexo-GitHub搭建博客" class="headerlink" title="Hexo+GitHub搭建博客"></a>Hexo+GitHub搭建博客</h1><blockquote><p>在参照众多大神在网络上的文章之后，自己终于弄出个东西来了，对于我这种爱折腾的人来说，将这各过程写下来，将来绝对用得到，如果还能帮助哪位同道中人，那实在是意外之喜，值得浮一大白！</p></blockquote><h2 id="①-前期准备"><a href="#①-前期准备" class="headerlink" title="① 前期准备"></a>① 前期准备</h2><blockquote><p>前期准备就不介绍了，这个随便搜，不会有出错的</p></blockquote><ul><li><p>GitHub账号以及账号名.github.io的项目</p><blockquote><p>例如，我的就是<a href="https://github.com/adolphmaster/adolphmaster.github.io" target="_blank" rel="noopener">adolphmaster.github.io</a>，这个也是将来我们访问页面的url，一定是账号名，选择Public，勾上初始化README文件选项，借用某位大神的图片，如下：</p></blockquote><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160415123510901" alt="借用某位大神的图片"></p></li><li><p>安装Git</p></li><li><p>安装node.js</p></li></ul><h2 id="②绑定GitHub"><a href="#②绑定GitHub" class="headerlink" title="②绑定GitHub"></a>②绑定GitHub</h2><p>首先，我们需要给github添加SSH key，分两个步骤：生成SSH key和添加key到Github Pagesa.</p><p>生成SSH key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打开Git Bash,在命令行中输入，输入完第一次输入文件名，之后几次等待输入可以直接按回车：</span><br><span class="line">ssh-keygen -t rsa -C "youremail@example.com"</span><br></pre></td></tr></table></figure><blockquote><p>其中这里双引号中填写的就是自己的邮箱地址，回车之后需要你输入文件名称已经密码，借用某位大神的图片：</p></blockquote><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160413195524856?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="借用某位大神的图片"></p><p>经过以上的操作之后，在用户目录里会自动生成一个.ssh文件夹，下面会生成两个文件：ssh_key和ssh_key.pub，这两个分别是SSH key的私钥（不可泄露出去）和公钥（可以放心告诉任何人）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们可以用vim命令来查看公钥文件内容,借用某位大神的图片：</span><br><span class="line">vim ssh_key.pub</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160413204824019" alt="借用某位大神的图片"><br>​        </p><p>可以看到公钥的ssh key是刚刚设定的邮箱地址作为后缀的，复制这段key，然后准备执行下一步。</p><p>添加key到Github Pages：用我们最开始注册的GitHub账号登陆GitHub主页面，点击右上角账号管理中的Setting选项,借用某位大神的图片：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160413205103837" alt="借用某位大神的图片"></p><p>进入到设置栏之后，选中SSH and GPG keys选项，然后向SSH keys栏中添加一个新的SSH key，借用某位大神的图片：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160413205418811" alt="借用某位大神的图片">Title可以自己任意定义，把刚刚复制的ssh_key.pub中的key复制到此处填写key内容的空白处，点击添加，借用某位大神的图片：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160413205611485" alt=""></p><p>添加完成后，可以看到SSH keys栏中多出了一个key，至此我们就完成了SSH key的生成和添加，借用某位大神的图片：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160413205554344" alt="https://img-blog.csdn.net/20160413205554344"></p><p>接下来我们通过msysgit测试一下连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现最后一句话或者类似成功的信息标志着SSH key添加成功，借用某位大神的图片:</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20160413210533341" alt="https://img-blog.csdn.net/20160413210533341"></p><blockquote><p>这里报错的话，就回到 / 目录(跟目录，即cd / 回车)输入 ssh-add ssh_key，ssh_key为输入的密钥的文件名，  </p><p>如果还系统提示：could not open a connection to your authentication agent</p><p>则需要执行一下命令：ssh-agent bash  </p><p>再输入ssh-add ssh_key</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中途可能要设置全局配置user.name 和user.email   </span><br><span class="line">git config --global user.name "dolphmaster"  //(""的账号是刚才Github里面自己注册的账号) </span><br><span class="line">git config --global user.email "adolphmaster@163.com" //(""的邮箱是你自己注册的邮箱)</span><br></pre></td></tr></table></figure><h2 id="③-搭建Hexo"><a href="#③-搭建Hexo" class="headerlink" title="③ 搭建Hexo"></a>③ 搭建Hexo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全局配置设置到淘宝源：</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装hexo插件"><a href="#安装hexo插件" class="headerlink" title="安装hexo插件"></a>安装hexo插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入以下代码,借用某位大神图片：</span><br><span class="line">  cd / #进入根目录，实际上是git安装的根目录 </span><br><span class="line">  pwd /</span><br><span class="line">  npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20180515115328728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTg3OTE3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="借用某位大神图片"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">安装之后，输入以下代码：</span><br><span class="line">cd / </span><br><span class="line">hexo init Hexo </span><br><span class="line">cd /Hexo </span><br><span class="line">npm instal </span><br><span class="line">hexo generate（可简写为hexo g ， 类似编译） </span><br><span class="line">hexo sever（可简写为hexo s， 类似运行）</span><br><span class="line">这时访问http://localhost:4000，应该就能看到东西了</span><br><span class="line"></span><br><span class="line">查看hexo插件的版本</span><br><span class="line">hexo -V</span><br><span class="line">大于hexo 3.0的上传到github的方法： </span><br><span class="line">安装部署到github插件依赖</span><br><span class="line">npm install –save hexo-deployer-git</span><br></pre></td></tr></table></figure><p>添加上传信息，借用某大神图片：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20180515151502825" alt=""></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/2018051512195954" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">type: git </span><br><span class="line">repo: https://github.com/adolphmaster/adolphmaster.github.io  //（改成自己的） </span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>再将gitbash部署hexo到github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h3 id="设置自己博客的功能-Next主题设置"><a href="#设置自己博客的功能-Next主题设置" class="headerlink" title="设置自己博客的功能(Next主题设置)"></a>设置自己博客的功能(Next主题设置)</h3><h4 id="开始使用next主题"><a href="#开始使用next主题" class="headerlink" title="开始使用next主题"></a><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用next主题</a></h4><blockquote><ul><li><p>下载主题</p></li><li><p>启用主题</p></li><li><p>选择Scheme</p></li><li><p>设置语言</p></li><li><p>设置菜单</p></li><li><p>······</p></li></ul></blockquote><ul><li><p><a href="https://blog.csdn.net/linshuhe1/article/details/51146184" target="_blank" rel="noopener">参考：Github+Jekyll —— 创建个人免费博客（三）Git学习</a></p></li><li><p><a href="https://zhidao.baidu.com/question/712206549106448205.html" target="_blank" rel="noopener">参考：如何建立linux ssh信任的方法与常见问题</a></p></li><li><p><a href="https://blog.csdn.net/weixin_39879178/article/details/80319392" target="_blank" rel="noopener">参考：2018.5月使用Github+Hexo搭建自己的博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
